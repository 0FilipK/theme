/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 30);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Abide module.\n   * @module foundation.abide\n   */\n\n  var Abide = function () {\n    /**\n     * Creates a new instance of Abide.\n     * @class\n     * @fires Abide#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Abide(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Abide);\n\n      this.$element = element;\n      this.options = $.extend({}, Abide.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Abide');\n    }\n\n    /**\n     * Initializes the Abide plugin and calls functions to get Abide functioning on load.\n     * @private\n     */\n\n\n    _createClass(Abide, [{\n      key: '_init',\n      value: function _init() {\n        this.$inputs = this.$element.find('input, textarea, select');\n\n        this._events();\n      }\n\n      /**\n       * Initializes events for Abide.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this2 = this;\n\n        this.$element.off('.abide').on('reset.zf.abide', function () {\n          _this2.resetForm();\n        }).on('submit.zf.abide', function () {\n          return _this2.validateForm();\n        });\n\n        if (this.options.validateOn === 'fieldChange') {\n          this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {\n            _this2.validateInput($(e.target));\n          });\n        }\n\n        if (this.options.liveValidate) {\n          this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {\n            _this2.validateInput($(e.target));\n          });\n        }\n\n        if (this.options.validateOnBlur) {\n          this.$inputs.off('blur.zf.abide').on('blur.zf.abide', function (e) {\n            _this2.validateInput($(e.target));\n          });\n        }\n      }\n\n      /**\n       * Calls necessary functions to update Abide upon DOM change\n       * @private\n       */\n\n    }, {\n      key: '_reflow',\n      value: function _reflow() {\n        this._init();\n      }\n\n      /**\n       * Checks whether or not a form element has the required attribute and if it's checked or not\n       * @param {Object} element - jQuery object to check for required attribute\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n       */\n\n    }, {\n      key: 'requiredCheck',\n      value: function requiredCheck($el) {\n        if (!$el.attr('required')) return true;\n\n        var isGood = true;\n\n        switch ($el[0].type) {\n          case 'checkbox':\n            isGood = $el[0].checked;\n            break;\n\n          case 'select':\n          case 'select-one':\n          case 'select-multiple':\n            var opt = $el.find('option:selected');\n            if (!opt.length || !opt.val()) isGood = false;\n            break;\n\n          default:\n            if (!$el.val() || !$el.val().length) isGood = false;\n        }\n\n        return isGood;\n      }\n\n      /**\n       * Based on $el, get the first element with selector in this order:\n       * 1. The element's direct sibling('s).\n       * 3. The element's parent's children.\n       *\n       * This allows for multiple form errors per input, though if none are found, no form errors will be shown.\n       *\n       * @param {Object} $el - jQuery object to use as reference to find the form error selector.\n       * @returns {Object} jQuery object with the selector.\n       */\n\n    }, {\n      key: 'findFormError',\n      value: function findFormError($el) {\n        var $error = $el.siblings(this.options.formErrorSelector);\n\n        if (!$error.length) {\n          $error = $el.parent().find(this.options.formErrorSelector);\n        }\n\n        return $error;\n      }\n\n      /**\n       * Get the first element in this order:\n       * 2. The <label> with the attribute `[for=\"someInputId\"]`\n       * 3. The `.closest()` <label>\n       *\n       * @param {Object} $el - jQuery object to check for required attribute\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n       */\n\n    }, {\n      key: 'findLabel',\n      value: function findLabel($el) {\n        var id = $el[0].id;\n        var $label = this.$element.find('label[for=\"' + id + '\"]');\n\n        if (!$label.length) {\n          return $el.closest('label');\n        }\n\n        return $label;\n      }\n\n      /**\n       * Get the set of labels associated with a set of radio els in this order\n       * 2. The <label> with the attribute `[for=\"someInputId\"]`\n       * 3. The `.closest()` <label>\n       *\n       * @param {Object} $el - jQuery object to check for required attribute\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\n       */\n\n    }, {\n      key: 'findRadioLabels',\n      value: function findRadioLabels($els) {\n        var _this3 = this;\n\n        var labels = $els.map(function (i, el) {\n          var id = el.id;\n          var $label = _this3.$element.find('label[for=\"' + id + '\"]');\n\n          if (!$label.length) {\n            $label = $(el).closest('label');\n          }\n          return $label[0];\n        });\n\n        return $(labels);\n      }\n\n      /**\n       * Adds the CSS error class as specified by the Abide settings to the label, input, and the form\n       * @param {Object} $el - jQuery object to add the class to\n       */\n\n    }, {\n      key: 'addErrorClasses',\n      value: function addErrorClasses($el) {\n        var $label = this.findLabel($el);\n        var $formError = this.findFormError($el);\n\n        if ($label.length) {\n          $label.addClass(this.options.labelErrorClass);\n        }\n\n        if ($formError.length) {\n          $formError.addClass(this.options.formErrorClass);\n        }\n\n        $el.addClass(this.options.inputErrorClass).attr('data-invalid', '');\n      }\n\n      /**\n       * Remove CSS error classes etc from an entire radio button group\n       * @param {String} groupName - A string that specifies the name of a radio button group\n       *\n       */\n\n    }, {\n      key: 'removeRadioErrorClasses',\n      value: function removeRadioErrorClasses(groupName) {\n        var $els = this.$element.find(':radio[name=\"' + groupName + '\"]');\n        var $labels = this.findRadioLabels($els);\n        var $formErrors = this.findFormError($els);\n\n        if ($labels.length) {\n          $labels.removeClass(this.options.labelErrorClass);\n        }\n\n        if ($formErrors.length) {\n          $formErrors.removeClass(this.options.formErrorClass);\n        }\n\n        $els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\n      }\n\n      /**\n       * Removes CSS error class as specified by the Abide settings from the label, input, and the form\n       * @param {Object} $el - jQuery object to remove the class from\n       */\n\n    }, {\n      key: 'removeErrorClasses',\n      value: function removeErrorClasses($el) {\n        // radios need to clear all of the els\n        if ($el[0].type == 'radio') {\n          return this.removeRadioErrorClasses($el.attr('name'));\n        }\n\n        var $label = this.findLabel($el);\n        var $formError = this.findFormError($el);\n\n        if ($label.length) {\n          $label.removeClass(this.options.labelErrorClass);\n        }\n\n        if ($formError.length) {\n          $formError.removeClass(this.options.formErrorClass);\n        }\n\n        $el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\n      }\n\n      /**\n       * Goes through a form to find inputs and proceeds to validate them in ways specific to their type. \n       * Ignores inputs with data-abide-ignore, type=\"hidden\" or disabled attributes set\n       * @fires Abide#invalid\n       * @fires Abide#valid\n       * @param {Object} element - jQuery object to validate, should be an HTML input\n       * @returns {Boolean} goodToGo - If the input is valid or not.\n       */\n\n    }, {\n      key: 'validateInput',\n      value: function validateInput($el) {\n        var _this4 = this;\n\n        var clearRequire = this.requiredCheck($el),\n            validated = false,\n            customValidator = true,\n            validator = $el.attr('data-validator'),\n            equalTo = true;\n\n        // don't validate ignored inputs or hidden inputs or disabled inputs\n        if ($el.is('[data-abide-ignore]') || $el.is('[type=\"hidden\"]') || $el.is('[disabled]')) {\n          return true;\n        }\n\n        switch ($el[0].type) {\n          case 'radio':\n            validated = this.validateRadio($el.attr('name'));\n            break;\n\n          case 'checkbox':\n            validated = clearRequire;\n            break;\n\n          case 'select':\n          case 'select-one':\n          case 'select-multiple':\n            validated = clearRequire;\n            break;\n\n          default:\n            validated = this.validateText($el);\n        }\n\n        if (validator) {\n          customValidator = this.matchValidation($el, validator, $el.attr('required'));\n        }\n\n        if ($el.attr('data-equalto')) {\n          equalTo = this.options.validators.equalTo($el);\n        }\n\n        var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;\n        var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';\n\n        if (goodToGo) {\n          // Re-validate inputs that depend on this one with equalto\n          var dependentElements = this.$element.find('[data-equalto=\"' + $el.attr('id') + '\"]');\n          if (dependentElements.length) {\n            (function () {\n              var _this = _this4;\n              dependentElements.each(function () {\n                if ($(this).val()) {\n                  _this.validateInput($(this));\n                }\n              });\n            })();\n          }\n        }\n\n        this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);\n\n        /**\n         * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`\n         * Trigger includes the DOM element of the input.\n         * @event Abide#valid\n         * @event Abide#invalid\n         */\n        $el.trigger(message, [$el]);\n\n        return goodToGo;\n      }\n\n      /**\n       * Goes through a form and if there are any invalid inputs, it will display the form error element\n       * @returns {Boolean} noError - true if no errors were detected...\n       * @fires Abide#formvalid\n       * @fires Abide#forminvalid\n       */\n\n    }, {\n      key: 'validateForm',\n      value: function validateForm() {\n        var acc = [];\n        var _this = this;\n\n        this.$inputs.each(function () {\n          acc.push(_this.validateInput($(this)));\n        });\n\n        var noError = acc.indexOf(false) === -1;\n\n        this.$element.find('[data-abide-error]').css('display', noError ? 'none' : 'block');\n\n        /**\n         * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.\n         * Trigger includes the element of the form.\n         * @event Abide#formvalid\n         * @event Abide#forminvalid\n         */\n        this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);\n\n        return noError;\n      }\n\n      /**\n       * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.\n       * @param {Object} $el - jQuery object to validate, should be a text input HTML element\n       * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns\n       * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified\n       */\n\n    }, {\n      key: 'validateText',\n      value: function validateText($el, pattern) {\n        // A pattern can be passed to this function, or it will be infered from the input's \"pattern\" attribute, or it's \"type\" attribute\n        pattern = pattern || $el.attr('pattern') || $el.attr('type');\n        var inputText = $el.val();\n        var valid = false;\n\n        if (inputText.length) {\n          // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp\n          if (this.options.patterns.hasOwnProperty(pattern)) {\n            valid = this.options.patterns[pattern].test(inputText);\n          }\n          // If the pattern name isn't also the type attribute of the field, then test it as a regexp\n          else if (pattern !== $el.attr('type')) {\n              valid = new RegExp(pattern).test(inputText);\n            } else {\n              valid = true;\n            }\n        }\n        // An empty field is valid if it's not required\n        else if (!$el.prop('required')) {\n            valid = true;\n          }\n\n        return valid;\n      }\n\n      /**\n       * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.\n       * @param {String} groupName - A string that specifies the name of a radio button group\n       * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)\n       */\n\n    }, {\n      key: 'validateRadio',\n      value: function validateRadio(groupName) {\n        // If at least one radio in the group has the `required` attribute, the group is considered required\n        // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice\n        var $group = this.$element.find(':radio[name=\"' + groupName + '\"]');\n        var valid = false,\n            required = false;\n\n        // For the group to be required, at least one radio needs to be required\n        $group.each(function (i, e) {\n          if ($(e).attr('required')) {\n            required = true;\n          }\n        });\n        if (!required) valid = true;\n\n        if (!valid) {\n          // For the group to be valid, at least one radio needs to be checked\n          $group.each(function (i, e) {\n            if ($(e).prop('checked')) {\n              valid = true;\n            }\n          });\n        };\n\n        return valid;\n      }\n\n      /**\n       * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator=\"foo bar baz\"` in a space separated listed.\n       * @param {Object} $el - jQuery input element.\n       * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.\n       * @param {Boolean} required - self explanatory?\n       * @returns {Boolean} - true if validations passed.\n       */\n\n    }, {\n      key: 'matchValidation',\n      value: function matchValidation($el, validators, required) {\n        var _this5 = this;\n\n        required = required ? true : false;\n\n        var clear = validators.split(' ').map(function (v) {\n          return _this5.options.validators[v]($el, required, $el.parent());\n        });\n        return clear.indexOf(false) === -1;\n      }\n\n      /**\n       * Resets form inputs and styles\n       * @fires Abide#formreset\n       */\n\n    }, {\n      key: 'resetForm',\n      value: function resetForm() {\n        var $form = this.$element,\n            opts = this.options;\n\n        $('.' + opts.labelErrorClass, $form).not('small').removeClass(opts.labelErrorClass);\n        $('.' + opts.inputErrorClass, $form).not('small').removeClass(opts.inputErrorClass);\n        $(opts.formErrorSelector + '.' + opts.formErrorClass).removeClass(opts.formErrorClass);\n        $form.find('[data-abide-error]').css('display', 'none');\n        $(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');\n        $(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\n        $(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\n        /**\n         * Fires when the form has been reset.\n         * @event Abide#formreset\n         */\n        $form.trigger('formreset.zf.abide', [$form]);\n      }\n\n      /**\n       * Destroys an instance of Abide.\n       * Removes error styles and classes from elements, without resetting their values.\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        var _this = this;\n        this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');\n\n        this.$inputs.off('.abide').each(function () {\n          _this.removeErrorClasses($(this));\n        });\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Abide;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  Abide.defaults = {\n    /**\n     * The default event to validate inputs. Checkboxes and radios validate immediately.\n     * Remove or change this value for manual validation.\n     * @option\n     * @type {?string}\n     * @default 'fieldChange'\n     */\n    validateOn: 'fieldChange',\n\n    /**\n     * Class to be applied to input labels on failed validation.\n     * @option\n     * @type {string}\n     * @default 'is-invalid-label'\n     */\n    labelErrorClass: 'is-invalid-label',\n\n    /**\n     * Class to be applied to inputs on failed validation.\n     * @option\n     * @type {string}\n     * @default 'is-invalid-input'\n     */\n    inputErrorClass: 'is-invalid-input',\n\n    /**\n     * Class selector to use to target Form Errors for show/hide.\n     * @option\n     * @type {string}\n     * @default '.form-error'\n     */\n    formErrorSelector: '.form-error',\n\n    /**\n     * Class added to Form Errors on failed validation.\n     * @option\n     * @type {string}\n     * @default 'is-visible'\n     */\n    formErrorClass: 'is-visible',\n\n    /**\n     * Set to true to validate text inputs on any value change.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    liveValidate: false,\n\n    /**\n     * Set to true to validate inputs on blur.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    validateOnBlur: false,\n\n    patterns: {\n      alpha: /^[a-zA-Z]+$/,\n      alpha_numeric: /^[a-zA-Z0-9]+$/,\n      integer: /^[-+]?\\d+$/,\n      number: /^[-+]?\\d*(?:[\\.\\,]\\d+)?$/,\n\n      // amex, visa, diners\n      card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/,\n      cvv: /^([0-9]){3,4}$/,\n\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\n      email: /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,\n\n      url: /^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/,\n      // abc.de\n      domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/,\n\n      datetime: /^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/,\n      // YYYY-MM-DD\n      date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,\n      // HH:MM:SS\n      time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,\n      dateISO: /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/,\n      // MM/DD/YYYY\n      month_day_year: /^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/,\n      // DD/MM/YYYY\n      day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/,\n\n      // #FFF or #FFFFFF\n      color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/\n    },\n\n    /**\n     * Optional validation functions to be used. `equalTo` being the only default included function.\n     * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:\n     * el : The jQuery element to validate.\n     * required : Boolean value of the required attribute be present or not.\n     * parent : The direct parent of the input.\n     * @option\n     */\n    validators: {\n      equalTo: function (el, required, parent) {\n        return $('#' + el.attr('data-equalto')).val() === el.val();\n      }\n    }\n  };\n\n  // Window exports\n  Foundation.plugin(Abide, 'Abide');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5hYmlkZS5qcz8wMTQ3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIEFiaWRlIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLmFiaWRlXG4gICAqL1xuXG4gIHZhciBBYmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEFiaWRlLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBBYmlkZSNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gQWJpZGUoZWxlbWVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJpZGUpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBYmlkZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0FiaWRlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFiaWRlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBBYmlkZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBYmlkZSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kaW5wdXRzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgQWJpZGUuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykub24oJ3Jlc2V0LnpmLmFiaWRlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5yZXNldEZvcm0oKTtcbiAgICAgICAgfSkub24oJ3N1Ym1pdC56Zi5hYmlkZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnZhbGlkYXRlRm9ybSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZhbGlkYXRlT24gPT09ICdmaWVsZENoYW5nZScpIHtcbiAgICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdjaGFuZ2UuemYuYWJpZGUnKS5vbignY2hhbmdlLnpmLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzMi52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVZhbGlkYXRlKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignaW5wdXQuemYuYWJpZGUnKS5vbignaW5wdXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMyLnZhbGlkYXRlSW5wdXQoJChlLnRhcmdldCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZU9uQmx1cikge1xuICAgICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJ2JsdXIuemYuYWJpZGUnKS5vbignYmx1ci56Zi5hYmlkZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpczIudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBBYmlkZSB1cG9uIERPTSBjaGFuZ2VcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZWZsb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgYSBmb3JtIGVsZW1lbnQgaGFzIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYW5kIGlmIGl0J3MgY2hlY2tlZCBvciBub3RcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlcXVpcmVkQ2hlY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVpcmVkQ2hlY2soJGVsKSB7XG4gICAgICAgIGlmICghJGVsLmF0dHIoJ3JlcXVpcmVkJykpIHJldHVybiB0cnVlO1xuXG4gICAgICAgIHZhciBpc0dvb2QgPSB0cnVlO1xuXG4gICAgICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICBpc0dvb2QgPSAkZWxbMF0uY2hlY2tlZDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcbiAgICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgICAgdmFyIG9wdCA9ICRlbC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIGlmICghb3B0Lmxlbmd0aCB8fCAhb3B0LnZhbCgpKSBpc0dvb2QgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghJGVsLnZhbCgpIHx8ICEkZWwudmFsKCkubGVuZ3RoKSBpc0dvb2QgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0dvb2Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmFzZWQgb24gJGVsLCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBzZWxlY3RvciBpbiB0aGlzIG9yZGVyOlxuICAgICAgICogMS4gVGhlIGVsZW1lbnQncyBkaXJlY3Qgc2libGluZygncykuXG4gICAgICAgKiAzLiBUaGUgZWxlbWVudCdzIHBhcmVudCdzIGNoaWxkcmVuLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgYWxsb3dzIGZvciBtdWx0aXBsZSBmb3JtIGVycm9ycyBwZXIgaW5wdXQsIHRob3VnaCBpZiBub25lIGFyZSBmb3VuZCwgbm8gZm9ybSBlcnJvcnMgd2lsbCBiZSBzaG93bi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgcmVmZXJlbmNlIHRvIGZpbmQgdGhlIGZvcm0gZXJyb3Igc2VsZWN0b3IuXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBqUXVlcnkgb2JqZWN0IHdpdGggdGhlIHNlbGVjdG9yLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdmaW5kRm9ybUVycm9yJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRm9ybUVycm9yKCRlbCkge1xuICAgICAgICB2YXIgJGVycm9yID0gJGVsLnNpYmxpbmdzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKCEkZXJyb3IubGVuZ3RoKSB7XG4gICAgICAgICAgJGVycm9yID0gJGVsLnBhcmVudCgpLmZpbmQodGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkZXJyb3I7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBmaXJzdCBlbGVtZW50IGluIHRoaXMgb3JkZXI6XG4gICAgICAgKiAyLiBUaGUgPGxhYmVsPiB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtmb3I9XCJzb21lSW5wdXRJZFwiXWBcbiAgICAgICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZmluZExhYmVsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTGFiZWwoJGVsKSB7XG4gICAgICAgIHZhciBpZCA9ICRlbFswXS5pZDtcbiAgICAgICAgdmFyICRsYWJlbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVwiJyArIGlkICsgJ1wiXScpO1xuXG4gICAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiAkZWwuY2xvc2VzdCgnbGFiZWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkbGFiZWw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0IHRoZSBzZXQgb2YgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBhIHNldCBvZiByYWRpbyBlbHMgaW4gdGhpcyBvcmRlclxuICAgICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAgICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2ZpbmRSYWRpb0xhYmVscycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFJhZGlvTGFiZWxzKCRlbHMpIHtcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxhYmVscyA9ICRlbHMubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgIHZhciBpZCA9IGVsLmlkO1xuICAgICAgICAgIHZhciAkbGFiZWwgPSBfdGhpczMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVwiJyArIGlkICsgJ1wiXScpO1xuXG4gICAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICAkbGFiZWwgPSAkKGVsKS5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJGxhYmVsWzBdO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gJChsYWJlbHMpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgdGhlIENTUyBlcnJvciBjbGFzcyBhcyBzcGVjaWZpZWQgYnkgdGhlIEFiaWRlIHNldHRpbmdzIHRvIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSBjbGFzcyB0b1xuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdhZGRFcnJvckNsYXNzZXMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVycm9yQ2xhc3NlcygkZWwpIHtcbiAgICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XG4gICAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XG5cbiAgICAgICAgaWYgKCRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAkbGFiZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcbiAgICAgICAgICAkZm9ybUVycm9yLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cignZGF0YS1pbnZhbGlkJywgJycpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZSBDU1MgZXJyb3IgY2xhc3NlcyBldGMgZnJvbSBhbiBlbnRpcmUgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZVJhZGlvRXJyb3JDbGFzc2VzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcbiAgICAgICAgdmFyICRlbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVwiJyArIGdyb3VwTmFtZSArICdcIl0nKTtcbiAgICAgICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRSYWRpb0xhYmVscygkZWxzKTtcbiAgICAgICAgdmFyICRmb3JtRXJyb3JzID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbHMpO1xuXG4gICAgICAgIGlmICgkbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICRsYWJlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGZvcm1FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgJGZvcm1FcnJvcnMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyBmcm9tIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlbW92ZUVycm9yQ2xhc3NlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xuICAgICAgICAvLyByYWRpb3MgbmVlZCB0byBjbGVhciBhbGwgb2YgdGhlIGVsc1xuICAgICAgICBpZiAoJGVsWzBdLnR5cGUgPT0gJ3JhZGlvJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XG4gICAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XG5cbiAgICAgICAgaWYgKCRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAkbGFiZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcbiAgICAgICAgICAkZm9ybUVycm9yLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAkZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR29lcyB0aHJvdWdoIGEgZm9ybSB0byBmaW5kIGlucHV0cyBhbmQgcHJvY2VlZHMgdG8gdmFsaWRhdGUgdGhlbSBpbiB3YXlzIHNwZWNpZmljIHRvIHRoZWlyIHR5cGUuIFxuICAgICAgICogSWdub3JlcyBpbnB1dHMgd2l0aCBkYXRhLWFiaWRlLWlnbm9yZSwgdHlwZT1cImhpZGRlblwiIG9yIGRpc2FibGVkIGF0dHJpYnV0ZXMgc2V0XG4gICAgICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxuICAgICAgICogQGZpcmVzIEFiaWRlI3ZhbGlkXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd2YWxpZGF0ZUlucHV0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KCRlbCkge1xuICAgICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgICB2YXIgY2xlYXJSZXF1aXJlID0gdGhpcy5yZXF1aXJlZENoZWNrKCRlbCksXG4gICAgICAgICAgICB2YWxpZGF0ZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIGN1c3RvbVZhbGlkYXRvciA9IHRydWUsXG4gICAgICAgICAgICB2YWxpZGF0b3IgPSAkZWwuYXR0cignZGF0YS12YWxpZGF0b3InKSxcbiAgICAgICAgICAgIGVxdWFsVG8gPSB0cnVlO1xuXG4gICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIGlnbm9yZWQgaW5wdXRzIG9yIGhpZGRlbiBpbnB1dHMgb3IgZGlzYWJsZWQgaW5wdXRzXG4gICAgICAgIGlmICgkZWwuaXMoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKSB8fCAkZWwuaXMoJ1t0eXBlPVwiaGlkZGVuXCJdJykgfHwgJGVsLmlzKCdbZGlzYWJsZWRdJykpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoJGVsWzBdLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgICAgICB2YWxpZGF0ZWQgPSB0aGlzLnZhbGlkYXRlUmFkaW8oJGVsLmF0dHIoJ25hbWUnKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgIHZhbGlkYXRlZCA9IGNsZWFyUmVxdWlyZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcbiAgICAgICAgICBjYXNlICdzZWxlY3QtbXVsdGlwbGUnOlxuICAgICAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZVRleHQoJGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICBjdXN0b21WYWxpZGF0b3IgPSB0aGlzLm1hdGNoVmFsaWRhdGlvbigkZWwsIHZhbGlkYXRvciwgJGVsLmF0dHIoJ3JlcXVpcmVkJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkge1xuICAgICAgICAgIGVxdWFsVG8gPSB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKCRlbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ29vZFRvR28gPSBbY2xlYXJSZXF1aXJlLCB2YWxpZGF0ZWQsIGN1c3RvbVZhbGlkYXRvciwgZXF1YWxUb10uaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IChnb29kVG9HbyA/ICd2YWxpZCcgOiAnaW52YWxpZCcpICsgJy56Zi5hYmlkZSc7XG5cbiAgICAgICAgaWYgKGdvb2RUb0dvKSB7XG4gICAgICAgICAgLy8gUmUtdmFsaWRhdGUgaW5wdXRzIHRoYXQgZGVwZW5kIG9uIHRoaXMgb25lIHdpdGggZXF1YWx0b1xuICAgICAgICAgIHZhciBkZXBlbmRlbnRFbGVtZW50cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWx0bz1cIicgKyAkZWwuYXR0cignaWQnKSArICdcIl0nKTtcbiAgICAgICAgICBpZiAoZGVwZW5kZW50RWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfdGhpczQ7XG4gICAgICAgICAgICAgIGRlcGVuZGVudEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLnZhbCgpKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy52YWxpZGF0ZUlucHV0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbZ29vZFRvR28gPyAncmVtb3ZlRXJyb3JDbGFzc2VzJyA6ICdhZGRFcnJvckNsYXNzZXMnXSgkZWwpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBpbnB1dCBpcyBkb25lIGNoZWNraW5nIGZvciB2YWxpZGF0aW9uLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgdmFsaWQuemYuYWJpZGVgIG9yIGBpbnZhbGlkLnpmLmFiaWRlYFxuICAgICAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBET00gZWxlbWVudCBvZiB0aGUgaW5wdXQuXG4gICAgICAgICAqIEBldmVudCBBYmlkZSN2YWxpZFxuICAgICAgICAgKiBAZXZlbnQgQWJpZGUjaW52YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgJGVsLnRyaWdnZXIobWVzc2FnZSwgWyRlbF0pO1xuXG4gICAgICAgIHJldHVybiBnb29kVG9HbztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIGFuZCBpZiB0aGVyZSBhcmUgYW55IGludmFsaWQgaW5wdXRzLCBpdCB3aWxsIGRpc3BsYXkgdGhlIGZvcm0gZXJyb3IgZWxlbWVudFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IG5vRXJyb3IgLSB0cnVlIGlmIG5vIGVycm9ycyB3ZXJlIGRldGVjdGVkLi4uXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybWludmFsaWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndmFsaWRhdGVGb3JtJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICAgIHZhciBhY2MgPSBbXTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgYWNjLnB1c2goX3RoaXMudmFsaWRhdGVJbnB1dCgkKHRoaXMpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBub0Vycm9yID0gYWNjLmluZGV4T2YoZmFsc2UpID09PSAtMTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsIG5vRXJyb3IgPyAnbm9uZScgOiAnYmxvY2snKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBpcyBmaW5pc2hlZCB2YWxpZGF0aW5nLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgZm9ybXZhbGlkLnpmLmFiaWRlYCBvciBgZm9ybWludmFsaWQuemYuYWJpZGVgLlxuICAgICAgICAgKiBUcmlnZ2VyIGluY2x1ZGVzIHRoZSBlbGVtZW50IG9mIHRoZSBmb3JtLlxuICAgICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybXZhbGlkXG4gICAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtaW52YWxpZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKChub0Vycm9yID8gJ2Zvcm12YWxpZCcgOiAnZm9ybWludmFsaWQnKSArICcuemYuYWJpZGUnLCBbdGhpcy4kZWxlbWVudF0pO1xuXG4gICAgICAgIHJldHVybiBub0Vycm9yO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHRleHQgaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gdGhlIHBhdHRlcm4gc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUuIElmIG5vIG1hdGNoaW5nIHBhdHRlcm4gaXMgZm91bmQsIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSBzdHJpbmcgdmFsdWUgb2Ygb25lIG9mIHRoZSBSZWdFeCBwYXR0ZXJucyBpbiBBYmlkZS5vcHRpb25zLnBhdHRlcm5zXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCB2YWx1ZSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHNwZWNpZmllZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd2YWxpZGF0ZVRleHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlVGV4dCgkZWwsIHBhdHRlcm4pIHtcbiAgICAgICAgLy8gQSBwYXR0ZXJuIGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBiZSBpbmZlcmVkIGZyb20gdGhlIGlucHV0J3MgXCJwYXR0ZXJuXCIgYXR0cmlidXRlLCBvciBpdCdzIFwidHlwZVwiIGF0dHJpYnV0ZVxuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybiB8fCAkZWwuYXR0cigncGF0dGVybicpIHx8ICRlbC5hdHRyKCd0eXBlJyk7XG4gICAgICAgIHZhciBpbnB1dFRleHQgPSAkZWwudmFsKCk7XG4gICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbnB1dFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHBhdHRlcm4gYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50IGlzIGluIEFiaWRlJ3MgbGlzdCBvZiBwYXR0ZXJucywgdGhlbiB0ZXN0IHRoYXQgcmVnZXhwXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShwYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFsaWQgPSB0aGlzLm9wdGlvbnMucGF0dGVybnNbcGF0dGVybl0udGVzdChpbnB1dFRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiB0aGUgcGF0dGVybiBuYW1lIGlzbid0IGFsc28gdGhlIHR5cGUgYXR0cmlidXRlIG9mIHRoZSBmaWVsZCwgdGhlbiB0ZXN0IGl0IGFzIGEgcmVnZXhwXG4gICAgICAgICAgZWxzZSBpZiAocGF0dGVybiAhPT0gJGVsLmF0dHIoJ3R5cGUnKSkge1xuICAgICAgICAgICAgICB2YWxpZCA9IG5ldyBSZWdFeHAocGF0dGVybikudGVzdChpbnB1dFRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXG4gICAgICAgIGVsc2UgaWYgKCEkZWwucHJvcCgncmVxdWlyZWQnKSkge1xuICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgcmFkaW8gaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgaXQgaXMgcmVxdWlyZWQgYW5kIHNlbGVjdGVkLiBBbHRob3VnaCB0aGUgZnVuY3Rpb24gdGFyZ2V0cyBhIHNpbmdsZSBgPGlucHV0PmAsIGl0IHZhbGlkYXRlcyBieSBjaGVja2luZyB0aGUgYHJlcXVpcmVkYCBhbmQgYGNoZWNrZWRgIHByb3BlcnRpZXMgb2YgYWxsIHJhZGlvIGJ1dHRvbnMgaW4gaXRzIGdyb3VwLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwTmFtZSAtIEEgc3RyaW5nIHRoYXQgc3BlY2lmaWVzIHRoZSBuYW1lIG9mIGEgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0IGxlYXN0IG9uZSByYWRpbyBpbnB1dCBoYXMgYmVlbiBzZWxlY3RlZCAoaWYgaXQncyByZXF1aXJlZClcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndmFsaWRhdGVSYWRpbycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVSYWRpbyhncm91cE5hbWUpIHtcbiAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIHJhZGlvIGluIHRoZSBncm91cCBoYXMgdGhlIGByZXF1aXJlZGAgYXR0cmlidXRlLCB0aGUgZ3JvdXAgaXMgY29uc2lkZXJlZCByZXF1aXJlZFxuICAgICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcbiAgICAgICAgdmFyICRncm91cCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XCInICsgZ3JvdXBOYW1lICsgJ1wiXScpO1xuICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSByZXF1aXJlZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIHJlcXVpcmVkXG4gICAgICAgICRncm91cC5lYWNoKGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgICAgICAgaWYgKCQoZSkuYXR0cigncmVxdWlyZWQnKSkge1xuICAgICAgICAgICAgcmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVxdWlyZWQpIHZhbGlkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcbiAgICAgICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgaWYgKCQoZSkucHJvcCgnY2hlY2tlZCcpKSB7XG4gICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHNlbGVjdGVkIGlucHV0IHBhc3NlcyBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBNdWx0aXBsZSB2YWxpZGF0aW9ucyBjYW4gYmUgdXNlZCwgaWYgcGFzc2VkIHRvIHRoZSBlbGVtZW50IHdpdGggYGRhdGEtdmFsaWRhdG9yPVwiZm9vIGJhciBiYXpcImAgaW4gYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdGVkLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBpbnB1dCBlbGVtZW50LlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlcXVpcmVkIC0gc2VsZiBleHBsYW5hdG9yeT9cbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgdmFsaWRhdGlvbnMgcGFzc2VkLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdtYXRjaFZhbGlkYXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVmFsaWRhdGlvbigkZWwsIHZhbGlkYXRvcnMsIHJlcXVpcmVkKSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICAgIHJlcXVpcmVkID0gcmVxdWlyZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIGNsZWFyID0gdmFsaWRhdG9ycy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBfdGhpczUub3B0aW9ucy52YWxpZGF0b3JzW3ZdKCRlbCwgcmVxdWlyZWQsICRlbC5wYXJlbnQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYXIuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlc2V0cyBmb3JtIGlucHV0cyBhbmQgc3R5bGVzXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXJlc2V0XG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Jlc2V0Rm9ybScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRGb3JtKCkge1xuICAgICAgICB2YXIgJGZvcm0gPSB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICAkKCcuJyArIG9wdHMubGFiZWxFcnJvckNsYXNzLCAkZm9ybSkubm90KCdzbWFsbCcpLnJlbW92ZUNsYXNzKG9wdHMubGFiZWxFcnJvckNsYXNzKTtcbiAgICAgICAgJCgnLicgKyBvcHRzLmlucHV0RXJyb3JDbGFzcywgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmlucHV0RXJyb3JDbGFzcyk7XG4gICAgICAgICQob3B0cy5mb3JtRXJyb3JTZWxlY3RvciArICcuJyArIG9wdHMuZm9ybUVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKG9wdHMuZm9ybUVycm9yQ2xhc3MpO1xuICAgICAgICAkZm9ybS5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAkKCc6aW5wdXQnLCAkZm9ybSkubm90KCc6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4sIDpyYWRpbywgOmNoZWNrYm94LCBbZGF0YS1hYmlkZS1pZ25vcmVdJykudmFsKCcnKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcbiAgICAgICAgJCgnOmlucHV0OnJhZGlvJywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSkucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XG4gICAgICAgICQoJzppbnB1dDpjaGVja2JveCcsICRmb3JtKS5ub3QoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBoYXMgYmVlbiByZXNldC5cbiAgICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm1yZXNldFxuICAgICAgICAgKi9cbiAgICAgICAgJGZvcm0udHJpZ2dlcignZm9ybXJlc2V0LnpmLmFiaWRlJywgWyRmb3JtXSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgQWJpZGUuXG4gICAgICAgKiBSZW1vdmVzIGVycm9yIHN0eWxlcyBhbmQgY2xhc3NlcyBmcm9tIGVsZW1lbnRzLCB3aXRob3V0IHJlc2V0dGluZyB0aGVpciB2YWx1ZXMuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKS5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJy5hYmlkZScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLnJlbW92ZUVycm9yQ2xhc3NlcygkKHRoaXMpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBYmlkZTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovXG5cblxuICBBYmlkZS5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBldmVudCB0byB2YWxpZGF0ZSBpbnB1dHMuIENoZWNrYm94ZXMgYW5kIHJhZGlvcyB2YWxpZGF0ZSBpbW1lZGlhdGVseS5cbiAgICAgKiBSZW1vdmUgb3IgY2hhbmdlIHRoaXMgdmFsdWUgZm9yIG1hbnVhbCB2YWxpZGF0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnZmllbGRDaGFuZ2UnXG4gICAgICovXG4gICAgdmFsaWRhdGVPbjogJ2ZpZWxkQ2hhbmdlJyxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXQgbGFiZWxzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdpcy1pbnZhbGlkLWxhYmVsJ1xuICAgICAqL1xuICAgIGxhYmVsRXJyb3JDbGFzczogJ2lzLWludmFsaWQtbGFiZWwnLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byBpbnB1dHMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2lzLWludmFsaWQtaW5wdXQnXG4gICAgICovXG4gICAgaW5wdXRFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1pbnB1dCcsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBzZWxlY3RvciB0byB1c2UgdG8gdGFyZ2V0IEZvcm0gRXJyb3JzIGZvciBzaG93L2hpZGUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJy5mb3JtLWVycm9yJ1xuICAgICAqL1xuICAgIGZvcm1FcnJvclNlbGVjdG9yOiAnLmZvcm0tZXJyb3InLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYWRkZWQgdG8gRm9ybSBFcnJvcnMgb24gZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2lzLXZpc2libGUnXG4gICAgICovXG4gICAgZm9ybUVycm9yQ2xhc3M6ICdpcy12aXNpYmxlJyxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIHRleHQgaW5wdXRzIG9uIGFueSB2YWx1ZSBjaGFuZ2UuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgbGl2ZVZhbGlkYXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHZhbGlkYXRlIGlucHV0cyBvbiBibHVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHZhbGlkYXRlT25CbHVyOiBmYWxzZSxcblxuICAgIHBhdHRlcm5zOiB7XG4gICAgICBhbHBoYTogL15bYS16QS1aXSskLyxcbiAgICAgIGFscGhhX251bWVyaWM6IC9eW2EtekEtWjAtOV0rJC8sXG4gICAgICBpbnRlZ2VyOiAvXlstK10/XFxkKyQvLFxuICAgICAgbnVtYmVyOiAvXlstK10/XFxkKig/OltcXC5cXCxdXFxkKyk/JC8sXG5cbiAgICAgIC8vIGFtZXgsIHZpc2EsIGRpbmVyc1xuICAgICAgY2FyZDogL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcZHszfSlcXGR7MTF9KSQvLFxuICAgICAgY3Z2OiAvXihbMC05XSl7Myw0fSQvLFxuXG4gICAgICAvLyBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9zdGF0ZXMtb2YtdGhlLXR5cGUtYXR0cmlidXRlLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbiAgICAgIGVtYWlsOiAvXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyxcblxuICAgICAgdXJsOiAvXihodHRwcz98ZnRwfGZpbGV8c3NoKTpcXC9cXC8oKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OikqQCk/KCgoXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pKXwoKChbYS16QS1aXXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2EtekEtWl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4/KSg6XFxkKik/KShcXC8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKyhcXC8oKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkqKSopPyk/KFxcPygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8W1xcdUUwMDAtXFx1RjhGRl18XFwvfFxcPykqKT8oXFwjKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxcXC98XFw/KSopPyQvLFxuICAgICAgLy8gYWJjLmRlXG4gICAgICBkb21haW46IC9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXC1dezAsNjF9W2EtekEtWjAtOV0pP1xcLikrW2EtekEtWl17Miw4fSQvLFxuXG4gICAgICBkYXRldGltZTogL14oWzAtMl1bMC05XXszfSlcXC0oWzAtMV1bMC05XSlcXC0oWzAtM11bMC05XSlUKFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pXFw6KFswLTVdWzAtOV0pKFp8KFtcXC1cXCtdKFswLTFdWzAtOV0pXFw6MDApKSQvLFxuICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgZGF0ZTogLyg/OjE5fDIwKVswLTldezJ9LSg/Oig/OjBbMS05XXwxWzAtMl0pLSg/OjBbMS05XXwxWzAtOV18MlswLTldKXwoPzooPyEwMikoPzowWzEtOV18MVswLTJdKS0oPzozMCkpfCg/Oig/OjBbMTM1NzhdfDFbMDJdKS0zMSkpJC8sXG4gICAgICAvLyBISDpNTTpTU1xuICAgICAgdGltZTogL14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLFxuICAgICAgZGF0ZUlTTzogL15cXGR7NH1bXFwvXFwtXVxcZHsxLDJ9W1xcL1xcLV1cXGR7MSwyfSQvLFxuICAgICAgLy8gTU0vREQvWVlZWVxuICAgICAgbW9udGhfZGF5X3llYXI6IC9eKDBbMS05XXwxWzAxMl0pWy0gXFwvLl0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXC8uXVxcZHs0fSQvLFxuICAgICAgLy8gREQvTU0vWVlZWVxuICAgICAgZGF5X21vbnRoX3llYXI6IC9eKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFwvLl0oMFsxLTldfDFbMDEyXSlbLSBcXC8uXVxcZHs0fSQvLFxuXG4gICAgICAvLyAjRkZGIG9yICNGRkZGRkZcbiAgICAgIGNvbG9yOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIHZhbGlkYXRpb24gZnVuY3Rpb25zIHRvIGJlIHVzZWQuIGBlcXVhbFRvYCBiZWluZyB0aGUgb25seSBkZWZhdWx0IGluY2x1ZGVkIGZ1bmN0aW9uLlxuICAgICAqIEZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIG9ubHkgYSBib29sZWFuIGlmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuIEZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgICogZWwgOiBUaGUgalF1ZXJ5IGVsZW1lbnQgdG8gdmFsaWRhdGUuXG4gICAgICogcmVxdWlyZWQgOiBCb29sZWFuIHZhbHVlIG9mIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGUgYmUgcHJlc2VudCBvciBub3QuXG4gICAgICogcGFyZW50IDogVGhlIGRpcmVjdCBwYXJlbnQgb2YgdGhlIGlucHV0LlxuICAgICAqIEBvcHRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0b3JzOiB7XG4gICAgICBlcXVhbFRvOiBmdW5jdGlvbiAoZWwsIHJlcXVpcmVkLCBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuICQoJyMnICsgZWwuYXR0cignZGF0YS1lcXVhbHRvJykpLnZhbCgpID09PSBlbC52YWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oQWJpZGUsICdBYmlkZScpO1xufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLmFiaWRlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Accordion module.\n   * @module foundation.accordion\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.motion\n   */\n\n  var Accordion = function () {\n    /**\n     * Creates a new instance of an accordion.\n     * @class\n     * @fires Accordion#init\n     * @param {jQuery} element - jQuery object to make into an accordion.\n     * @param {Object} options - a plain object with settings to override the default options.\n     */\n    function Accordion(element, options) {\n      _classCallCheck(this, Accordion);\n\n      this.$element = element;\n      this.options = $.extend({}, Accordion.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Accordion');\n      Foundation.Keyboard.register('Accordion', {\n        'ENTER': 'toggle',\n        'SPACE': 'toggle',\n        'ARROW_DOWN': 'next',\n        'ARROW_UP': 'previous'\n      });\n    }\n\n    /**\n     * Initializes the accordion by animating the preset active pane(s).\n     * @private\n     */\n\n\n    _createClass(Accordion, [{\n      key: '_init',\n      value: function _init() {\n        this.$element.attr('role', 'tablist');\n        this.$tabs = this.$element.children('[data-accordion-item]');\n\n        this.$tabs.each(function (idx, el) {\n          var $el = $(el),\n              $content = $el.children('[data-tab-content]'),\n              id = $content[0].id || Foundation.GetYoDigits(6, 'accordion'),\n              linkId = el.id || id + '-label';\n\n          $el.find('a:first').attr({\n            'aria-controls': id,\n            'role': 'tab',\n            'id': linkId,\n            'aria-expanded': false,\n            'aria-selected': false\n          });\n\n          $content.attr({ 'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id });\n        });\n        var $initActive = this.$element.find('.is-active').children('[data-tab-content]');\n        if ($initActive.length) {\n          this.down($initActive, true);\n        }\n        this._events();\n      }\n\n      /**\n       * Adds event handlers for items within the accordion.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        this.$tabs.each(function () {\n          var $elem = $(this);\n          var $tabContent = $elem.children('[data-tab-content]');\n          if ($tabContent.length) {\n            $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {\n              e.preventDefault();\n              _this.toggle($tabContent);\n            }).on('keydown.zf.accordion', function (e) {\n              Foundation.Keyboard.handleKey(e, 'Accordion', {\n                toggle: function () {\n                  _this.toggle($tabContent);\n                },\n                next: function () {\n                  var $a = $elem.next().find('a').focus();\n                  if (!_this.options.multiExpand) {\n                    $a.trigger('click.zf.accordion');\n                  }\n                },\n                previous: function () {\n                  var $a = $elem.prev().find('a').focus();\n                  if (!_this.options.multiExpand) {\n                    $a.trigger('click.zf.accordion');\n                  }\n                },\n                handled: function () {\n                  e.preventDefault();\n                  e.stopPropagation();\n                }\n              });\n            });\n          }\n        });\n      }\n\n      /**\n       * Toggles the selected content pane's open/close state.\n       * @param {jQuery} $target - jQuery object of the pane to toggle (`.accordion-content`).\n       * @function\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle($target) {\n        if ($target.parent().hasClass('is-active')) {\n          this.up($target);\n        } else {\n          this.down($target);\n        }\n      }\n\n      /**\n       * Opens the accordion tab defined by `$target`.\n       * @param {jQuery} $target - Accordion pane to open (`.accordion-content`).\n       * @param {Boolean} firstTime - flag to determine if reflow should happen.\n       * @fires Accordion#down\n       * @function\n       */\n\n    }, {\n      key: 'down',\n      value: function down($target, firstTime) {\n        var _this2 = this;\n\n        $target.attr('aria-hidden', false).parent('[data-tab-content]').addBack().parent().addClass('is-active');\n\n        if (!this.options.multiExpand && !firstTime) {\n          var $currentActive = this.$element.children('.is-active').children('[data-tab-content]');\n          if ($currentActive.length) {\n            this.up($currentActive.not($target));\n          }\n        }\n\n        $target.slideDown(this.options.slideSpeed, function () {\n          /**\n           * Fires when the tab is done opening.\n           * @event Accordion#down\n           */\n          _this2.$element.trigger('down.zf.accordion', [$target]);\n        });\n\n        $('#' + $target.attr('aria-labelledby')).attr({\n          'aria-expanded': true,\n          'aria-selected': true\n        });\n      }\n\n      /**\n       * Closes the tab defined by `$target`.\n       * @param {jQuery} $target - Accordion tab to close (`.accordion-content`).\n       * @fires Accordion#up\n       * @function\n       */\n\n    }, {\n      key: 'up',\n      value: function up($target) {\n        var $aunts = $target.parent().siblings(),\n            _this = this;\n\n        if (!this.options.allowAllClosed && !$aunts.hasClass('is-active') || !$target.parent().hasClass('is-active')) {\n          return;\n        }\n\n        // Foundation.Move(this.options.slideSpeed, $target, function(){\n        $target.slideUp(_this.options.slideSpeed, function () {\n          /**\n           * Fires when the tab is done collapsing up.\n           * @event Accordion#up\n           */\n          _this.$element.trigger('up.zf.accordion', [$target]);\n        });\n        // });\n\n        $target.attr('aria-hidden', true).parent().removeClass('is-active');\n\n        $('#' + $target.attr('aria-labelledby')).attr({\n          'aria-expanded': false,\n          'aria-selected': false\n        });\n      }\n\n      /**\n       * Destroys an instance of an accordion.\n       * @fires Accordion#destroyed\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');\n        this.$element.find('a').off('.zf.accordion');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Accordion;\n  }();\n\n  Accordion.defaults = {\n    /**\n     * Amount of time to animate the opening of an accordion pane.\n     * @option\n     * @type {number}\n     * @default 250\n     */\n    slideSpeed: 250,\n    /**\n     * Allow the accordion to have multiple open panes.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    multiExpand: false,\n    /**\n     * Allow the accordion to close all panes.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    allowAllClosed: false\n  };\n\n  // Window exports\n  Foundation.plugin(Accordion, 'Accordion');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5hY2NvcmRpb24uanM/Y2UxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBBY2NvcmRpb24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAgICovXG5cbiAgdmFyIEFjY29yZGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIGEgcGxhaW4gb2JqZWN0IHdpdGggc2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBY2NvcmRpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY29yZGlvbik7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIEFjY29yZGlvbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0FjY29yZGlvbicpO1xuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uJywge1xuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxuICAgICAgICAnQVJST1dfVVAnOiAncHJldmlvdXMnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhBY2NvcmRpb24sIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigncm9sZScsICd0YWJsaXN0Jyk7XG4gICAgICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1hY2NvcmRpb24taXRlbV0nKTtcblxuICAgICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKGlkeCwgZWwpIHtcbiAgICAgICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgICAgICRjb250ZW50ID0gJGVsLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKSxcbiAgICAgICAgICAgICAgaWQgPSAkY29udGVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2NvcmRpb24nKSxcbiAgICAgICAgICAgICAgbGlua0lkID0gZWwuaWQgfHwgaWQgKyAnLWxhYmVsJztcblxuICAgICAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGlkLFxuICAgICAgICAgICAgJ3JvbGUnOiAndGFiJyxcbiAgICAgICAgICAgICdpZCc6IGxpbmtJZCxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGZhbHNlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkY29udGVudC5hdHRyKHsgJ3JvbGUnOiAndGFicGFuZWwnLCAnYXJpYS1sYWJlbGxlZGJ5JzogbGlua0lkLCAnYXJpYS1oaWRkZW4nOiB0cnVlLCAnaWQnOiBpZCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciAkaW5pdEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcbiAgICAgICAgaWYgKCRpbml0QWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZG93bigkaW5pdEFjdGl2ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICRlbGVtID0gJCh0aGlzKTtcbiAgICAgICAgICB2YXIgJHRhYkNvbnRlbnQgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XG4gICAgICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvbicpLm9uKCdjbGljay56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XG4gICAgICAgICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnQWNjb3JkaW9uJywge1xuICAgICAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCR0YWJDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciAkYSA9ICRlbGVtLm5leHQoKS5maW5kKCdhJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xuICAgICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5wcmV2KCkuZmluZCgnYScpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIHNlbGVjdGVkIGNvbnRlbnQgcGFuZSdzIG9wZW4vY2xvc2Ugc3RhdGUuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb2YgdGhlIHBhbmUgdG8gdG9nZ2xlIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9nZ2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCkge1xuICAgICAgICBpZiAoJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcbiAgICAgICAgICB0aGlzLnVwKCR0YXJnZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIHRoZSBhY2NvcmRpb24gdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBBY2NvcmRpb24gcGFuZSB0byBvcGVuIChgLmFjY29yZGlvbi1jb250ZW50YCkuXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpcnN0VGltZSAtIGZsYWcgdG8gZGV0ZXJtaW5lIGlmIHJlZmxvdyBzaG91bGQgaGFwcGVuLlxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG93bigkdGFyZ2V0LCBmaXJzdFRpbWUpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKS5wYXJlbnQoJ1tkYXRhLXRhYi1jb250ZW50XScpLmFkZEJhY2soKS5wYXJlbnQoKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQgJiYgIWZpcnN0VGltZSkge1xuICAgICAgICAgIHZhciAkY3VycmVudEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XG4gICAgICAgICAgaWYgKCRjdXJyZW50QWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy51cCgkY3VycmVudEFjdGl2ZS5ub3QoJHRhcmdldCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICR0YXJnZXQuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI2Rvd25cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKCcjJyArICR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JykpLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSxcbiAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiB0YWIgdG8gY2xvc2UgKGAuYWNjb3JkaW9uLWNvbnRlbnRgKS5cbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdXAoJHRhcmdldCkge1xuICAgICAgICB2YXIgJGF1bnRzID0gJHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkICYmICEkYXVudHMuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpIHx8ICEkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcbiAgICAgICAgJHRhcmdldC5zbGlkZVVwKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXG4gICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiN1cFxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICAkdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAgICQoJyMnICsgJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcbiAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zdG9wKHRydWUpLnNsaWRlVXAoMCkuY3NzKCdkaXNwbGF5JywgJycpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKS5vZmYoJy56Zi5hY2NvcmRpb24nKTtcblxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFjY29yZGlvbjtcbiAgfSgpO1xuXG4gIEFjY29yZGlvbi5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGFuIGFjY29yZGlvbiBwYW5lLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAqL1xuICAgIHNsaWRlU3BlZWQ6IDI1MCxcbiAgICAvKipcbiAgICAgKiBBbGxvdyB0aGUgYWNjb3JkaW9uIHRvIGhhdmUgbXVsdGlwbGUgb3BlbiBwYW5lcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBtdWx0aUV4cGFuZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYWxsb3dBbGxDbG9zZWQ6IGZhbHNlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uLCAnQWNjb3JkaW9uJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uYWNjb3JkaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * AccordionMenu module.\n   * @module foundation.accordionMenu\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.motion\n   * @requires foundation.util.nest\n   */\n\n  var AccordionMenu = function () {\n    /**\n     * Creates a new instance of an accordion menu.\n     * @class\n     * @fires AccordionMenu#init\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function AccordionMenu(element, options) {\n      _classCallCheck(this, AccordionMenu);\n\n      this.$element = element;\n      this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);\n\n      Foundation.Nest.Feather(this.$element, 'accordion');\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'AccordionMenu');\n      Foundation.Keyboard.register('AccordionMenu', {\n        'ENTER': 'toggle',\n        'SPACE': 'toggle',\n        'ARROW_RIGHT': 'open',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'close',\n        'ESCAPE': 'closeAll'\n      });\n    }\n\n    /**\n     * Initializes the accordion menu by hiding all nested menus.\n     * @private\n     */\n\n\n    _createClass(AccordionMenu, [{\n      key: '_init',\n      value: function _init() {\n        this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');\n        this.$element.attr({\n          'role': 'menu',\n          'aria-multiselectable': this.options.multiOpen\n        });\n\n        this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');\n        this.$menuLinks.each(function () {\n          var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),\n              $elem = $(this),\n              $sub = $elem.children('[data-submenu]'),\n              subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),\n              isActive = $sub.hasClass('is-active');\n          $elem.attr({\n            'aria-controls': subId,\n            'aria-expanded': isActive,\n            'role': 'menuitem',\n            'id': linkId\n          });\n          $sub.attr({\n            'aria-labelledby': linkId,\n            'aria-hidden': !isActive,\n            'role': 'menu',\n            'id': subId\n          });\n        });\n        var initPanes = this.$element.find('.is-active');\n        if (initPanes.length) {\n          var _this = this;\n          initPanes.each(function () {\n            _this.down($(this));\n          });\n        }\n        this._events();\n      }\n\n      /**\n       * Adds event handlers for items within the menu.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        this.$element.find('li').each(function () {\n          var $submenu = $(this).children('[data-submenu]');\n\n          if ($submenu.length) {\n            $(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\n              e.preventDefault();\n\n              _this.toggle($submenu);\n            });\n          }\n        }).on('keydown.zf.accordionmenu', function (e) {\n          var $element = $(this),\n              $elements = $element.parent('ul').children('li'),\n              $prevElement,\n              $nextElement,\n              $target = $element.children('[data-submenu]');\n\n          $elements.each(function (i) {\n            if ($(this).is($element)) {\n              $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();\n\n              if ($(this).children('[data-submenu]:visible').length) {\n                // has open sub menu\n                $nextElement = $element.find('li:first-child').find('a').first();\n              }\n              if ($(this).is(':first-child')) {\n                // is first element of sub menu\n                $prevElement = $element.parents('li').first().find('a').first();\n              } else if ($prevElement.parents('li').first().children('[data-submenu]:visible').length) {\n                // if previous element has open sub menu\n                $prevElement = $prevElement.parents('li').find('li:last-child').find('a').first();\n              }\n              if ($(this).is(':last-child')) {\n                // is last element of sub menu\n                $nextElement = $element.parents('li').first().next('li').find('a').first();\n              }\n\n              return;\n            }\n          });\n\n          Foundation.Keyboard.handleKey(e, 'AccordionMenu', {\n            open: function () {\n              if ($target.is(':hidden')) {\n                _this.down($target);\n                $target.find('li').first().find('a').first().focus();\n              }\n            },\n            close: function () {\n              if ($target.length && !$target.is(':hidden')) {\n                // close active sub of this item\n                _this.up($target);\n              } else if ($element.parent('[data-submenu]').length) {\n                // close currently open sub\n                _this.up($element.parent('[data-submenu]'));\n                $element.parents('li').first().find('a').first().focus();\n              }\n            },\n            up: function () {\n              $prevElement.focus();\n              return true;\n            },\n            down: function () {\n              $nextElement.focus();\n              return true;\n            },\n            toggle: function () {\n              if ($element.children('[data-submenu]').length) {\n                _this.toggle($element.children('[data-submenu]'));\n              }\n            },\n            closeAll: function () {\n              _this.hideAll();\n            },\n            handled: function (preventDefault) {\n              if (preventDefault) {\n                e.preventDefault();\n              }\n              e.stopImmediatePropagation();\n            }\n          });\n        }); //.attr('tabindex', 0);\n      }\n\n      /**\n       * Closes all panes of the menu.\n       * @function\n       */\n\n    }, {\n      key: 'hideAll',\n      value: function hideAll() {\n        this.up(this.$element.find('[data-submenu]'));\n      }\n\n      /**\n       * Opens all panes of the menu.\n       * @function\n       */\n\n    }, {\n      key: 'showAll',\n      value: function showAll() {\n        this.down(this.$element.find('[data-submenu]'));\n      }\n\n      /**\n       * Toggles the open/close state of a submenu.\n       * @function\n       * @param {jQuery} $target - the submenu to toggle\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle($target) {\n        if (!$target.is(':animated')) {\n          if (!$target.is(':hidden')) {\n            this.up($target);\n          } else {\n            this.down($target);\n          }\n        }\n      }\n\n      /**\n       * Opens the sub-menu defined by `$target`.\n       * @param {jQuery} $target - Sub-menu to open.\n       * @fires AccordionMenu#down\n       */\n\n    }, {\n      key: 'down',\n      value: function down($target) {\n        var _this = this;\n\n        if (!this.options.multiOpen) {\n          this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));\n        }\n\n        $target.addClass('is-active').attr({ 'aria-hidden': false }).parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });\n\n        //Foundation.Move(this.options.slideSpeed, $target, function() {\n        $target.slideDown(_this.options.slideSpeed, function () {\n          /**\n           * Fires when the menu is done opening.\n           * @event AccordionMenu#down\n           */\n          _this.$element.trigger('down.zf.accordionMenu', [$target]);\n        });\n        //});\n      }\n\n      /**\n       * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.\n       * @param {jQuery} $target - Sub-menu to close.\n       * @fires AccordionMenu#up\n       */\n\n    }, {\n      key: 'up',\n      value: function up($target) {\n        var _this = this;\n        //Foundation.Move(this.options.slideSpeed, $target, function(){\n        $target.slideUp(_this.options.slideSpeed, function () {\n          /**\n           * Fires when the menu is done collapsing up.\n           * @event AccordionMenu#up\n           */\n          _this.$element.trigger('up.zf.accordionMenu', [$target]);\n        });\n        //});\n\n        var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);\n\n        $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);\n      }\n\n      /**\n       * Destroys an instance of accordion menu.\n       * @fires AccordionMenu#destroyed\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.find('[data-submenu]').slideDown(0).css('display', '');\n        this.$element.find('a').off('click.zf.accordionMenu');\n\n        Foundation.Nest.Burn(this.$element, 'accordion');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return AccordionMenu;\n  }();\n\n  AccordionMenu.defaults = {\n    /**\n     * Amount of time to animate the opening of a submenu in ms.\n     * @option\n     * @type {number}\n     * @default 250\n     */\n    slideSpeed: 250,\n    /**\n     * Allow the menu to have multiple open panes.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    multiOpen: true\n  };\n\n  // Window exports\n  Foundation.plugin(AccordionMenu, 'AccordionMenu');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5hY2NvcmRpb25NZW51LmpzPzU4NDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25NZW51XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XG4gICAqL1xuXG4gIHZhciBBY2NvcmRpb25NZW51ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFjY29yZGlvbk1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFjY29yZGlvbk1lbnUpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb25NZW51LmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICAgIEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdBY2NvcmRpb25NZW51Jyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdBY2NvcmRpb25NZW51Jywge1xuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcbiAgICAgICAgJ1NQQUNFJzogJ3RvZ2dsZScsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICdvcGVuJyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ2Nsb3NlJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZUFsbCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gbWVudSBieSBoaWRpbmcgYWxsIG5lc3RlZCBtZW51cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQWNjb3JkaW9uTWVudSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLm5vdCgnLmlzLWFjdGl2ZScpLnNsaWRlVXAoMCk7IC8vLmZpbmQoJ2EnKS5jc3MoJ3BhZGRpbmctbGVmdCcsICcxcmVtJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgJ3JvbGUnOiAnbWVudScsXG4gICAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogdGhpcy5vcHRpb25zLm11bHRpT3BlblxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiRtZW51TGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgICAgdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBsaW5rSWQgPSB0aGlzLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2FjYy1tZW51LWxpbmsnKSxcbiAgICAgICAgICAgICAgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyksXG4gICAgICAgICAgICAgIHN1YklkID0gJHN1YlswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2MtbWVudScpLFxuICAgICAgICAgICAgICBpc0FjdGl2ZSA9ICRzdWIuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgICAgICRlbGVtLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzdWJJZCxcbiAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogaXNBY3RpdmUsXG4gICAgICAgICAgICAncm9sZSc6ICdtZW51aXRlbScsXG4gICAgICAgICAgICAnaWQnOiBsaW5rSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkc3ViLmF0dHIoe1xuICAgICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxpbmtJZCxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnLFxuICAgICAgICAgICAgJ2lkJzogc3ViSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbml0UGFuZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKTtcbiAgICAgICAgaWYgKGluaXRQYW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIGluaXRQYW5lcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmRvd24oJCh0aGlzKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBtZW51LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICRzdWJtZW51ID0gJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcblxuICAgICAgICAgIGlmICgkc3VibWVudS5sZW5ndGgpIHtcbiAgICAgICAgICAgICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnKS5vbignY2xpY2suemYuYWNjb3JkaW9uTWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50LFxuICAgICAgICAgICAgICAkdGFyZ2V0ID0gJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7XG5cbiAgICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKCQodGhpcykuaXMoJGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSkuZmluZCgnYScpLmZpcnN0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKCQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LmZpbmQoJ2xpOmZpcnN0LWNoaWxkJykuZmluZCgnYScpLmZpcnN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XTp2aXNpYmxlJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxuICAgICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRwcmV2RWxlbWVudC5wYXJlbnRzKCdsaScpLmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygnOmxhc3QtY2hpbGQnKSkge1xuICAgICAgICAgICAgICAgIC8vIGlzIGxhc3QgZWxlbWVudCBvZiBzdWIgbWVudVxuICAgICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5uZXh0KCdsaScpLmZpbmQoJ2EnKS5maXJzdCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0FjY29yZGlvbk1lbnUnLCB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgICAgICAgICAgICR0YXJnZXQuZmluZCgnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIGFjdGl2ZSBzdWIgb2YgdGhpcyBpdGVtXG4gICAgICAgICAgICAgICAgX3RoaXMudXAoJHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGNsb3NlIGN1cnJlbnRseSBvcGVuIHN1YlxuICAgICAgICAgICAgICAgIF90aGlzLnVwKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKSk7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b2dnbGUoJGVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2VBbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuaGlkZUFsbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7IC8vLmF0dHIoJ3RhYmluZGV4JywgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoaWRlQWxsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQWxsKCkge1xuICAgICAgICB0aGlzLnVwKHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Nob3dBbGwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dBbGwoKSB7XG4gICAgICAgIHRoaXMuZG93bih0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2Ugc3RhdGUgb2YgYSBzdWJtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIHRoZSBzdWJtZW51IHRvIHRvZ2dsZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgkdGFyZ2V0KSB7XG4gICAgICAgIGlmICghJHRhcmdldC5pcygnOmFuaW1hdGVkJykpIHtcbiAgICAgICAgICBpZiAoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgICAgdGhpcy51cCgkdGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIHRoZSBzdWItbWVudSBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gU3ViLW1lbnUgdG8gb3Blbi5cbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rvd25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZG93bigkdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlPcGVuKSB7XG4gICAgICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5ub3QoJHRhcmdldC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKCR0YXJnZXQpKSk7XG4gICAgICAgIH1cblxuICAgICAgICAkdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogZmFsc2UgfSkucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7ICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSB9KTtcblxuICAgICAgICAvL0ZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICR0YXJnZXQuc2xpZGVEb3duKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBvcGVuaW5nLlxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I2Rvd25cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdkb3duLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy99KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLiBBbGwgc3ViLW1lbnVzIGluc2lkZSB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xvc2VkIGFzIHdlbGwuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjdXBcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndXAnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwKCR0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy9Gb3VuZGF0aW9uLk1vdmUodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsICR0YXJnZXQsIGZ1bmN0aW9uKCl7XG4gICAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGRvbmUgY29sbGFwc2luZyB1cC5cbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbk1lbnUnLCBbJHRhcmdldF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy99KTtcblxuICAgICAgICB2YXIgJG1lbnVzID0gJHRhcmdldC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG5cbiAgICAgICAgJG1lbnVzLnBhcmVudCgnLmlzLWFjY29yZGlvbi1zdWJtZW51LXBhcmVudCcpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYWNjb3JkaW9uIG1lbnUuXG4gICAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkZXN0cm95ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlRG93bigwKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpO1xuXG4gICAgICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBY2NvcmRpb25NZW51O1xuICB9KCk7XG5cbiAgQWNjb3JkaW9uTWVudS5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGEgc3VibWVudSBpbiBtcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAyNTBcbiAgICAgKi9cbiAgICBzbGlkZVNwZWVkOiAyNTAsXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIG1lbnUgdG8gaGF2ZSBtdWx0aXBsZSBvcGVuIHBhbmVzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgbXVsdGlPcGVuOiB0cnVlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uTWVudSwgJ0FjY29yZGlvbk1lbnUnKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5hY2NvcmRpb25NZW51LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

eval("!function ($) {\n\n  \"use strict\";\n\n  var FOUNDATION_VERSION = '6.3.1';\n\n  // Global Foundation object\n  // This is attached to the window, or used as a module for AMD/Browserify\n  var Foundation = {\n    version: FOUNDATION_VERSION,\n\n    /**\n     * Stores initialized plugins.\n     */\n    _plugins: {},\n\n    /**\n     * Stores generated unique ids for plugin instances\n     */\n    _uuids: [],\n\n    /**\n     * Returns a boolean for RTL support\n     */\n    rtl: function () {\n      return $('html').attr('dir') === 'rtl';\n    },\n    /**\n     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\n     * @param {Object} plugin - The constructor of the plugin.\n     */\n    plugin: function (plugin, name) {\n      // Object key to use when adding to global Foundation object\n      // Examples: Foundation.Reveal, Foundation.OffCanvas\n      var className = name || functionName(plugin);\n      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\n      // Examples: data-reveal, data-off-canvas\n      var attrName = hyphenate(className);\n\n      // Add to the Foundation object and the plugins list (for reflowing)\n      this._plugins[attrName] = this[className] = plugin;\n    },\n    /**\n     * @function\n     * Populates the _uuids array with pointers to each individual plugin instance.\n     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\n     * Also fires the initialization event for each plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @param {String} name - the name of the plugin, passed as a camelCased string.\n     * @fires Plugin#init\n     */\n    registerPlugin: function (plugin, name) {\n      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\n      plugin.uuid = this.GetYoDigits(6, pluginName);\n\n      if (!plugin.$element.attr('data-' + pluginName)) {\n        plugin.$element.attr('data-' + pluginName, plugin.uuid);\n      }\n      if (!plugin.$element.data('zfPlugin')) {\n        plugin.$element.data('zfPlugin', plugin);\n      }\n      /**\n       * Fires when the plugin has initialized.\n       * @event Plugin#init\n       */\n      plugin.$element.trigger('init.zf.' + pluginName);\n\n      this._uuids.push(plugin.uuid);\n\n      return;\n    },\n    /**\n     * @function\n     * Removes the plugins uuid from the _uuids array.\n     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\n     * Also fires the destroyed event for the plugin, consolidating repetitive code.\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\n     * @fires Plugin#destroyed\n     */\n    unregisterPlugin: function (plugin) {\n      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\n\n      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\n      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')\n      /**\n       * Fires when the plugin has been destroyed.\n       * @event Plugin#destroyed\n       */\n      .trigger('destroyed.zf.' + pluginName);\n      for (var prop in plugin) {\n        plugin[prop] = null; //clean up script to prep for garbage collection.\n      }\n      return;\n    },\n\n    /**\n     * @function\n     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\n     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\n     * @default If no argument is passed, reflow all currently active plugins.\n     */\n    reInit: function (plugins) {\n      var isJQ = plugins instanceof $;\n      try {\n        if (isJQ) {\n          plugins.each(function () {\n            $(this).data('zfPlugin')._init();\n          });\n        } else {\n          var type = typeof plugins,\n              _this = this,\n              fns = {\n            'object': function (plgs) {\n              plgs.forEach(function (p) {\n                p = hyphenate(p);\n                $('[data-' + p + ']').foundation('_init');\n              });\n            },\n            'string': function () {\n              plugins = hyphenate(plugins);\n              $('[data-' + plugins + ']').foundation('_init');\n            },\n            'undefined': function () {\n              this['object'](Object.keys(_this._plugins));\n            }\n          };\n          fns[type](plugins);\n        }\n      } catch (err) {\n        console.error(err);\n      } finally {\n        return plugins;\n      }\n    },\n\n    /**\n     * returns a random base-36 uid with namespacing\n     * @function\n     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\n     * @param {String} namespace - name of plugin to be incorporated in uid, optional.\n     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\n     * @returns {String} - unique id\n     */\n    GetYoDigits: function (length, namespace) {\n      length = length || 6;\n      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');\n    },\n    /**\n     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\n     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\n     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\n     */\n    reflow: function (elem, plugins) {\n\n      // If plugins is undefined, just grab everything\n      if (typeof plugins === 'undefined') {\n        plugins = Object.keys(this._plugins);\n      }\n      // If plugins is a string, convert it to an array with one item\n      else if (typeof plugins === 'string') {\n          plugins = [plugins];\n        }\n\n      var _this = this;\n\n      // Iterate through each plugin\n      $.each(plugins, function (i, name) {\n        // Get the current plugin\n        var plugin = _this._plugins[name];\n\n        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\n        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');\n\n        // For each plugin found, initialize it\n        $elem.each(function () {\n          var $el = $(this),\n              opts = {};\n          // Don't double-dip on plugins\n          if ($el.data('zfPlugin')) {\n            console.warn(\"Tried to initialize \" + name + \" on an element that already has a Foundation plugin.\");\n            return;\n          }\n\n          if ($el.attr('data-options')) {\n            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\n              var opt = e.split(':').map(function (el) {\n                return el.trim();\n              });\n              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\n            });\n          }\n          try {\n            $el.data('zfPlugin', new plugin($(this), opts));\n          } catch (er) {\n            console.error(er);\n          } finally {\n            return;\n          }\n        });\n      });\n    },\n    getFnName: functionName,\n    transitionend: function ($elem) {\n      var transitions = {\n        'transition': 'transitionend',\n        'WebkitTransition': 'webkitTransitionEnd',\n        'MozTransition': 'transitionend',\n        'OTransition': 'otransitionend'\n      };\n      var elem = document.createElement('div'),\n          end;\n\n      for (var t in transitions) {\n        if (typeof elem.style[t] !== 'undefined') {\n          end = transitions[t];\n        }\n      }\n      if (end) {\n        return end;\n      } else {\n        end = setTimeout(function () {\n          $elem.triggerHandler('transitionend', [$elem]);\n        }, 1);\n        return 'transitionend';\n      }\n    }\n  };\n\n  Foundation.util = {\n    /**\n     * Function for applying a debounce effect to a function call.\n     * @function\n     * @param {Function} func - Function to be called at end of timeout.\n     * @param {Number} delay - Time in ms to delay the call of `func`.\n     * @returns function\n     */\n    throttle: function (func, delay) {\n      var timer = null;\n\n      return function () {\n        var context = this,\n            args = arguments;\n\n        if (timer === null) {\n          timer = setTimeout(function () {\n            func.apply(context, args);\n            timer = null;\n          }, delay);\n        }\n      };\n    }\n  };\n\n  // TODO: consider not making this a jQuery function\n  // TODO: need way to reflow vs. re-initialize\n  /**\n   * The Foundation jQuery method.\n   * @param {String|Array} method - An action to perform on the current jQuery object.\n   */\n  var foundation = function (method) {\n    var type = typeof method,\n        $meta = $('meta.foundation-mq'),\n        $noJS = $('.no-js');\n\n    if (!$meta.length) {\n      $('<meta class=\"foundation-mq\">').appendTo(document.head);\n    }\n    if ($noJS.length) {\n      $noJS.removeClass('no-js');\n    }\n\n    if (type === 'undefined') {\n      //needs to initialize the Foundation object, or an individual plugin.\n      Foundation.MediaQuery._init();\n      Foundation.reflow(this);\n    } else if (type === 'string') {\n      //an individual method to invoke on a plugin or group of plugins\n      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\n      var plugClass = this.data('zfPlugin'); //determine the class of plugin\n\n      if (plugClass !== undefined && plugClass[method] !== undefined) {\n        //make sure both the class and method exist\n        if (this.length === 1) {\n          //if there's only one, call it directly.\n          plugClass[method].apply(plugClass, args);\n        } else {\n          this.each(function (i, el) {\n            //otherwise loop through the jQuery collection and invoke the method on each\n            plugClass[method].apply($(el).data('zfPlugin'), args);\n          });\n        }\n      } else {\n        //error for no class or no method\n        throw new ReferenceError(\"We're sorry, '\" + method + \"' is not an available method for \" + (plugClass ? functionName(plugClass) : 'this element') + '.');\n      }\n    } else {\n      //error for invalid argument type\n      throw new TypeError('We\\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');\n    }\n    return this;\n  };\n\n  window.Foundation = Foundation;\n  $.fn.foundation = foundation;\n\n  // Polyfill for requestAnimationFrame\n  (function () {\n    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\n      return new Date().getTime();\n    };\n\n    var vendors = ['webkit', 'moz'];\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n      var vp = vendors[i];\n      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\n      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\n    }\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n      var lastTime = 0;\n      window.requestAnimationFrame = function (callback) {\n        var now = Date.now();\n        var nextTime = Math.max(lastTime + 16, now);\n        return setTimeout(function () {\n          callback(lastTime = nextTime);\n        }, nextTime - now);\n      };\n      window.cancelAnimationFrame = clearTimeout;\n    }\n    /**\n     * Polyfill for performance.now, required by rAF\n     */\n    if (!window.performance || !window.performance.now) {\n      window.performance = {\n        start: Date.now(),\n        now: function () {\n          return Date.now() - this.start;\n        }\n      };\n    }\n  })();\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n      if (typeof this !== 'function') {\n        // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n      }\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP = function () {},\n          fBound = function () {\n        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n      if (this.prototype) {\n        // native functions don't have a prototype\n        fNOP.prototype = this.prototype;\n      }\n      fBound.prototype = new fNOP();\n\n      return fBound;\n    };\n  }\n  // Polyfill to get the name of a function in IE9\n  function functionName(fn) {\n    if (Function.prototype.name === undefined) {\n      var funcNameRegex = /function\\s([^(]{1,})\\(/;\n      var results = funcNameRegex.exec(fn.toString());\n      return results && results.length > 1 ? results[1].trim() : \"\";\n    } else if (fn.prototype === undefined) {\n      return fn.constructor.name;\n    } else {\n      return fn.prototype.constructor.name;\n    }\n  }\n  function parseValue(str) {\n    if ('true' === str) return true;else if ('false' === str) return false;else if (!isNaN(str * 1)) return parseFloat(str);\n    return str;\n  }\n  // Convert PascalCase to kebab-case\n  // Thank you: http://stackoverflow.com/a/8955580\n  function hyphenate(str) {\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5jb3JlLmpzPzdjZDUiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uICgkKSB7XG5cbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIEZPVU5EQVRJT05fVkVSU0lPTiA9ICc2LjMuMSc7XG5cbiAgLy8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4gIC8vIFRoaXMgaXMgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdywgb3IgdXNlZCBhcyBhIG1vZHVsZSBmb3IgQU1EL0Jyb3dzZXJpZnlcbiAgdmFyIEZvdW5kYXRpb24gPSB7XG4gICAgdmVyc2lvbjogRk9VTkRBVElPTl9WRVJTSU9OLFxuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGluaXRpYWxpemVkIHBsdWdpbnMuXG4gICAgICovXG4gICAgX3BsdWdpbnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXG4gICAgICovXG4gICAgX3V1aWRzOiBbXSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxuICAgICAqL1xuICAgIHJ0bDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICQoJ2h0bWwnKS5hdHRyKCdkaXInKSA9PT0gJ3J0bCc7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cbiAgICAgKi9cbiAgICBwbHVnaW46IGZ1bmN0aW9uIChwbHVnaW4sIG5hbWUpIHtcbiAgICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxuICAgICAgLy8gRXhhbXBsZXM6IEZvdW5kYXRpb24uUmV2ZWFsLCBGb3VuZGF0aW9uLk9mZkNhbnZhc1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IG5hbWUgfHwgZnVuY3Rpb25OYW1lKHBsdWdpbik7XG4gICAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbiAgICAgIC8vIEV4YW1wbGVzOiBkYXRhLXJldmVhbCwgZGF0YS1vZmYtY2FudmFzXG4gICAgICB2YXIgYXR0ck5hbWUgPSBoeXBoZW5hdGUoY2xhc3NOYW1lKTtcblxuICAgICAgLy8gQWRkIHRvIHRoZSBGb3VuZGF0aW9uIG9iamVjdCBhbmQgdGhlIHBsdWdpbnMgbGlzdCAoZm9yIHJlZmxvd2luZylcbiAgICAgIHRoaXMuX3BsdWdpbnNbYXR0ck5hbWVdID0gdGhpc1tjbGFzc05hbWVdID0gcGx1Z2luO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxuICAgICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cbiAgICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxuICAgICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxuICAgICAqL1xuICAgIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiAocGx1Z2luLCBuYW1lKSB7XG4gICAgICB2YXIgcGx1Z2luTmFtZSA9IG5hbWUgPyBoeXBoZW5hdGUobmFtZSkgOiBmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcGx1Z2luLnV1aWQgPSB0aGlzLkdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xuXG4gICAgICBpZiAoIXBsdWdpbi4kZWxlbWVudC5hdHRyKCdkYXRhLScgKyBwbHVnaW5OYW1lKSkge1xuICAgICAgICBwbHVnaW4uJGVsZW1lbnQuYXR0cignZGF0YS0nICsgcGx1Z2luTmFtZSwgcGx1Z2luLnV1aWQpO1xuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nKSkge1xuICAgICAgICBwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCBwbHVnaW4pO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxuICAgICAgICogQGV2ZW50IFBsdWdpbiNpbml0XG4gICAgICAgKi9cbiAgICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKCdpbml0LnpmLicgKyBwbHVnaW5OYW1lKTtcblxuICAgICAgdGhpcy5fdXVpZHMucHVzaChwbHVnaW4udXVpZCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIFJlbW92ZXMgdGhlIHBsdWdpbnMgdXVpZCBmcm9tIHRoZSBfdXVpZHMgYXJyYXkuXG4gICAgICogUmVtb3ZlcyB0aGUgemZQbHVnaW4gZGF0YSBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGRhdGEtcGx1Z2luLW5hbWUgYXR0cmlidXRlLlxuICAgICAqIEFsc28gZmlyZXMgdGhlIGRlc3Ryb3llZCBldmVudCBmb3IgdGhlIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBsdWdpbiAtIGFuIGluc3RhbmNlIG9mIGEgcGx1Z2luLCB1c3VhbGx5IGB0aGlzYCBpbiBjb250ZXh0LlxuICAgICAqIEBmaXJlcyBQbHVnaW4jZGVzdHJveWVkXG4gICAgICovXG4gICAgdW5yZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XG5cbiAgICAgIHRoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHBsdWdpbi51dWlkKSwgMSk7XG4gICAgICBwbHVnaW4uJGVsZW1lbnQucmVtb3ZlQXR0cignZGF0YS0nICsgcGx1Z2luTmFtZSkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxuICAgICAgLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgICAqL1xuICAgICAgLnRyaWdnZXIoJ2Rlc3Ryb3llZC56Zi4nICsgcGx1Z2luTmFtZSk7XG4gICAgICBmb3IgKHZhciBwcm9wIGluIHBsdWdpbikge1xuICAgICAgICBwbHVnaW5bcHJvcF0gPSBudWxsOyAvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIENhdXNlcyBvbmUgb3IgbW9yZSBhY3RpdmUgcGx1Z2lucyB0byByZS1pbml0aWFsaXplLCByZXNldHRpbmcgZXZlbnQgbGlzdGVuZXJzLCByZWNhbGN1bGF0aW5nIHBvc2l0aW9ucywgZXRjLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcbiAgICAgKiBAZGVmYXVsdCBJZiBubyBhcmd1bWVudCBpcyBwYXNzZWQsIHJlZmxvdyBhbGwgY3VycmVudGx5IGFjdGl2ZSBwbHVnaW5zLlxuICAgICAqL1xuICAgIHJlSW5pdDogZnVuY3Rpb24gKHBsdWdpbnMpIHtcbiAgICAgIHZhciBpc0pRID0gcGx1Z2lucyBpbnN0YW5jZW9mICQ7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNKUSkge1xuICAgICAgICAgIHBsdWdpbnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ3pmUGx1Z2luJykuX2luaXQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBwbHVnaW5zLFxuICAgICAgICAgICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICAgIGZucyA9IHtcbiAgICAgICAgICAgICdvYmplY3QnOiBmdW5jdGlvbiAocGxncykge1xuICAgICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBwID0gaHlwaGVuYXRlKHApO1xuICAgICAgICAgICAgICAgICQoJ1tkYXRhLScgKyBwICsgJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnc3RyaW5nJzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xuICAgICAgICAgICAgICAkKCdbZGF0YS0nICsgcGx1Z2lucyArICddJykuZm91bmRhdGlvbignX2luaXQnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGlzWydvYmplY3QnXShPYmplY3Qua2V5cyhfdGhpcy5fcGx1Z2lucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZm5zW3R5cGVdKHBsdWdpbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbnM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSByYW5kb20gYmFzZS0zNiB1aWQgd2l0aCBuYW1lc3BhY2luZ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggLSBudW1iZXIgb2YgcmFuZG9tIGJhc2UtMzYgZGlnaXRzIGRlc2lyZWQuIEluY3JlYXNlIGZvciBtb3JlIHJhbmRvbSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBuYW1lIG9mIHBsdWdpbiB0byBiZSBpbmNvcnBvcmF0ZWQgaW4gdWlkLCBvcHRpb25hbC5cbiAgICAgKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSB1bmlxdWUgaWRcbiAgICAgKi9cbiAgICBHZXRZb0RpZ2l0czogZnVuY3Rpb24gKGxlbmd0aCwgbmFtZXNwYWNlKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfHwgNjtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGgucG93KDM2LCBsZW5ndGggKyAxKSAtIE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygzNiwgbGVuZ3RoKSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpICsgKG5hbWVzcGFjZSA/ICctJyArIG5hbWVzcGFjZSA6ICcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgcGx1Z2lucyBvbiBhbnkgZWxlbWVudHMgd2l0aGluIGBlbGVtYCAoYW5kIGBlbGVtYCBpdHNlbGYpIHRoYXQgYXJlbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGx1Z2lucyAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUuIExlYXZlIHRoaXMgb3V0IHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy5cbiAgICAgKi9cbiAgICByZWZsb3c6IGZ1bmN0aW9uIChlbGVtLCBwbHVnaW5zKSB7XG5cbiAgICAgIC8vIElmIHBsdWdpbnMgaXMgdW5kZWZpbmVkLCBqdXN0IGdyYWIgZXZlcnl0aGluZ1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwbHVnaW5zID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucyk7XG4gICAgICB9XG4gICAgICAvLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHBsdWdpbnMgPSBbcGx1Z2luc107XG4gICAgICAgIH1cblxuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcGx1Z2luXG4gICAgICAkLmVhY2gocGx1Z2lucywgZnVuY3Rpb24gKGksIG5hbWUpIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHBsdWdpblxuICAgICAgICB2YXIgcGx1Z2luID0gX3RoaXMuX3BsdWdpbnNbbmFtZV07XG5cbiAgICAgICAgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxuICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pLmZpbmQoJ1tkYXRhLScgKyBuYW1lICsgJ10nKS5hZGRCYWNrKCdbZGF0YS0nICsgbmFtZSArICddJyk7XG5cbiAgICAgICAgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XG4gICAgICAgICRlbGVtLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciAkZWwgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgLy8gRG9uJ3QgZG91YmxlLWRpcCBvbiBwbHVnaW5zXG4gICAgICAgICAgaWYgKCRlbC5kYXRhKCd6ZlBsdWdpbicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcmllZCB0byBpbml0aWFsaXplIFwiICsgbmFtZSArIFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKSB7XG4gICAgICAgICAgICB2YXIgdGhpbmcgPSAkZWwuYXR0cignZGF0YS1vcHRpb25zJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgICAgIHZhciBvcHQgPSBlLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC50cmltKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAob3B0WzBdKSBvcHRzW29wdFswXV0gPSBwYXJzZVZhbHVlKG9wdFsxXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICRlbC5kYXRhKCd6ZlBsdWdpbicsIG5ldyBwbHVnaW4oJCh0aGlzKSwgb3B0cykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldEZuTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgIHRyYW5zaXRpb25lbmQ6IGZ1bmN0aW9uICgkZWxlbSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25zID0ge1xuICAgICAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAgICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgICAgICdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuICAgICAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXG4gICAgICB9O1xuICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICBlbmQ7XG5cbiAgICAgIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGVuZCA9IHRyYW5zaXRpb25zW3RdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkZWxlbS50cmlnZ2VySGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIFskZWxlbV0pO1xuICAgICAgICB9LCAxKTtcbiAgICAgICAgcmV0dXJuICd0cmFuc2l0aW9uZW5kJztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRm91bmRhdGlvbi51dGlsID0ge1xuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIGZvciBhcHBseWluZyBhIGRlYm91bmNlIGVmZmVjdCB0byBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBUaW1lIGluIG1zIHRvIGRlbGF5IHRoZSBjYWxsIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgICAqL1xuICAgIHRocm90dGxlOiBmdW5jdGlvbiAoZnVuYywgZGVsYXkpIHtcbiAgICAgIHZhciB0aW1lciA9IG51bGw7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgaWYgKHRpbWVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiBjb25zaWRlciBub3QgbWFraW5nIHRoaXMgYSBqUXVlcnkgZnVuY3Rpb25cbiAgLy8gVE9ETzogbmVlZCB3YXkgdG8gcmVmbG93IHZzLiByZS1pbml0aWFsaXplXG4gIC8qKlxuICAgKiBUaGUgRm91bmRhdGlvbiBqUXVlcnkgbWV0aG9kLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbWV0aG9kIC0gQW4gYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGN1cnJlbnQgalF1ZXJ5IG9iamVjdC5cbiAgICovXG4gIHZhciBmb3VuZGF0aW9uID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG1ldGhvZCxcbiAgICAgICAgJG1ldGEgPSAkKCdtZXRhLmZvdW5kYXRpb24tbXEnKSxcbiAgICAgICAgJG5vSlMgPSAkKCcubm8tanMnKTtcblxuICAgIGlmICghJG1ldGEubGVuZ3RoKSB7XG4gICAgICAkKCc8bWV0YSBjbGFzcz1cImZvdW5kYXRpb24tbXFcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKTtcbiAgICB9XG4gICAgaWYgKCRub0pTLmxlbmd0aCkge1xuICAgICAgJG5vSlMucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cbiAgICAgIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5faW5pdCgpO1xuICAgICAgRm91bmRhdGlvbi5yZWZsb3codGhpcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgLy9hbiBpbmRpdmlkdWFsIG1ldGhvZCB0byBpbnZva2Ugb24gYSBwbHVnaW4gb3IgZ3JvdXAgb2YgcGx1Z2luc1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxuICAgICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsgLy9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxuXG4gICAgICBpZiAocGx1Z0NsYXNzICE9PSB1bmRlZmluZWQgJiYgcGx1Z0NsYXNzW21ldGhvZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvL21ha2Ugc3VyZSBib3RoIHRoZSBjbGFzcyBhbmQgbWV0aG9kIGV4aXN0XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vaWYgdGhlcmUncyBvbmx5IG9uZSwgY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbiAgICAgICAgICAgIHBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KCQoZWwpLmRhdGEoJ3pmUGx1Z2luJyksIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2Vycm9yIGZvciBubyBjbGFzcyBvciBubyBtZXRob2RcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiV2UncmUgc29ycnksICdcIiArIG1ldGhvZCArIFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXCIgKyAocGx1Z0NsYXNzID8gZnVuY3Rpb25OYW1lKHBsdWdDbGFzcykgOiAndGhpcyBlbGVtZW50JykgKyAnLicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dlXFwncmUgc29ycnksICcgKyB0eXBlICsgJyBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIuIFlvdSBtdXN0IHVzZSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1ldGhvZCB5b3Ugd2lzaCB0byBpbnZva2UuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHdpbmRvdy5Gb3VuZGF0aW9uID0gRm91bmRhdGlvbjtcbiAgJC5mbi5mb3VuZGF0aW9uID0gZm91bmRhdGlvbjtcblxuICAvLyBQb2x5ZmlsbCBmb3IgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFEYXRlLm5vdyB8fCAhd2luZG93LkRhdGUubm93KSB3aW5kb3cuRGF0ZS5ub3cgPSBEYXRlLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9O1xuXG4gICAgdmFyIHZlbmRvcnMgPSBbJ3dlYmtpdCcsICdtb3onXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZwICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ10gfHwgd2luZG93W3ZwICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgIH1cbiAgICBpZiAoL2lQKGFkfGhvbmV8b2QpLipPUyA2Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdmFyIG5leHRUaW1lID0gTWF0aC5tYXgobGFzdFRpbWUgKyAxNiwgbm93KTtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKGxhc3RUaW1lID0gbmV4dFRpbWUpO1xuICAgICAgICB9LCBuZXh0VGltZSAtIG5vdyk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gY2xlYXJUaW1lb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmb3IgcGVyZm9ybWFuY2Uubm93LCByZXF1aXJlZCBieSByQUZcbiAgICAgKi9cbiAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSB8fCAhd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlID0ge1xuICAgICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSkoKTtcbiAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKG9UaGlzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XG4gICAgICAgIC8vIGludGVybmFsIElzQ2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcbiAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcbiAgICAgICAgICBmTk9QID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAgICAgZkJvdW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCA/IHRoaXMgOiBvVGhpcywgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xuICAgICAgICAvLyBuYXRpdmUgZnVuY3Rpb25zIGRvbid0IGhhdmUgYSBwcm90b3R5cGVcbiAgICAgICAgZk5PUC5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICAgIH1cbiAgICAgIGZCb3VuZC5wcm90b3R5cGUgPSBuZXcgZk5PUCgpO1xuXG4gICAgICByZXR1cm4gZkJvdW5kO1xuICAgIH07XG4gIH1cbiAgLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmbikge1xuICAgIGlmIChGdW5jdGlvbi5wcm90b3R5cGUubmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxccyhbXihdezEsfSlcXCgvO1xuICAgICAgdmFyIHJlc3VsdHMgPSBmdW5jTmFtZVJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XG4gICAgICByZXR1cm4gcmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzWzFdLnRyaW0oKSA6IFwiXCI7XG4gICAgfSBlbHNlIGlmIChmbi5wcm90b3R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZuLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VWYWx1ZShzdHIpIHtcbiAgICBpZiAoJ3RydWUnID09PSBzdHIpIHJldHVybiB0cnVlO2Vsc2UgaWYgKCdmYWxzZScgPT09IHN0cikgcmV0dXJuIGZhbHNlO2Vsc2UgaWYgKCFpc05hTihzdHIgKiAxKSkgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIC8vIENvbnZlcnQgUGFzY2FsQ2FzZSB0byBrZWJhYi1jYXNlXG4gIC8vIFRoYW5rIHlvdTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODk1NTU4MFxuICBmdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuICB9XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Drilldown module.\n   * @module foundation.drilldown\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.motion\n   * @requires foundation.util.nest\n   */\n\n  var Drilldown = function () {\n    /**\n     * Creates a new instance of a drilldown menu.\n     * @class\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Drilldown(element, options) {\n      _classCallCheck(this, Drilldown);\n\n      this.$element = element;\n      this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);\n\n      Foundation.Nest.Feather(this.$element, 'drilldown');\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Drilldown');\n      Foundation.Keyboard.register('Drilldown', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'previous',\n        'ESCAPE': 'close',\n        'TAB': 'down',\n        'SHIFT_TAB': 'up'\n      });\n    }\n\n    /**\n     * Initializes the drilldown by creating jQuery collections of elements\n     * @private\n     */\n\n\n    _createClass(Drilldown, [{\n      key: '_init',\n      value: function _init() {\n        this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');\n        this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]');\n        this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem').find('a');\n        this.$element.attr('data-mutate', this.$element.attr('data-drilldown') || Foundation.GetYoDigits(6, 'drilldown'));\n\n        this._prepareMenu();\n        this._registerEvents();\n\n        this._keyboardEvents();\n      }\n\n      /**\n       * prepares drilldown menu by setting attributes to links and elements\n       * sets a min height to prevent content jumping\n       * wraps the element if not already wrapped\n       * @private\n       * @function\n       */\n\n    }, {\n      key: '_prepareMenu',\n      value: function _prepareMenu() {\n        var _this = this;\n        // if(!this.options.holdOpen){\n        //   this._menuLinkEvents();\n        // }\n        this.$submenuAnchors.each(function () {\n          var $link = $(this);\n          var $sub = $link.parent();\n          if (_this.options.parentLink) {\n            $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>');\n          }\n          $link.data('savedHref', $link.attr('href')).removeAttr('href').attr('tabindex', 0);\n          $link.children('[data-submenu]').attr({\n            'aria-hidden': true,\n            'tabindex': 0,\n            'role': 'menu'\n          });\n          _this._events($link);\n        });\n        this.$submenus.each(function () {\n          var $menu = $(this),\n              $back = $menu.find('.js-drilldown-back');\n          if (!$back.length) {\n            switch (_this.options.backButtonPosition) {\n              case \"bottom\":\n                $menu.append(_this.options.backButton);\n                break;\n              case \"top\":\n                $menu.prepend(_this.options.backButton);\n                break;\n              default:\n                console.error(\"Unsupported backButtonPosition value '\" + _this.options.backButtonPosition + \"'\");\n            }\n          }\n          _this._back($menu);\n        });\n\n        this.$submenus.addClass('invisible');\n        if (!this.options.autoHeight) {\n          this.$submenus.addClass('drilldown-submenu-cover-previous');\n        }\n\n        // create a wrapper on element if it doesn't exist.\n        if (!this.$element.parent().hasClass('is-drilldown')) {\n          this.$wrapper = $(this.options.wrapper).addClass('is-drilldown');\n          if (this.options.animateHeight) this.$wrapper.addClass('animate-height');\n          this.$element.wrap(this.$wrapper);\n        }\n        // set wrapper\n        this.$wrapper = this.$element.parent();\n        this.$wrapper.css(this._getMaxDims());\n      }\n    }, {\n      key: '_resize',\n      value: function _resize() {\n        this.$wrapper.css({ 'max-width': 'none', 'min-height': 'none' });\n        // _getMaxDims has side effects (boo) but calling it should update all other necessary heights & widths\n        this.$wrapper.css(this._getMaxDims());\n      }\n\n      /**\n       * Adds event handlers to elements in the menu.\n       * @function\n       * @private\n       * @param {jQuery} $elem - the current menu item to add handlers to.\n       */\n\n    }, {\n      key: '_events',\n      value: function _events($elem) {\n        var _this = this;\n\n        $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\n          if ($(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n          }\n\n          // if(e.target !== e.currentTarget.firstElementChild){\n          //   return false;\n          // }\n          _this._show($elem.parent('li'));\n\n          if (_this.options.closeOnClick) {\n            var $body = $('body');\n            $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {\n              if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {\n                return;\n              }\n              e.preventDefault();\n              _this._hideAll();\n              $body.off('.zf.drilldown');\n            });\n          }\n        });\n        this.$element.on('mutateme.zf.trigger', this._resize.bind(this));\n      }\n\n      /**\n       * Adds event handlers to the menu element.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_registerEvents',\n      value: function _registerEvents() {\n        if (this.options.scrollTop) {\n          this._bindHandler = this._scrollTop.bind(this);\n          this.$element.on('open.zf.drilldown hide.zf.drilldown closed.zf.drilldown', this._bindHandler);\n        }\n      }\n\n      /**\n       * Scroll to Top of Element or data-scroll-top-element\n       * @function\n       * @fires Drilldown#scrollme\n       */\n\n    }, {\n      key: '_scrollTop',\n      value: function _scrollTop() {\n        var _this = this;\n        var $scrollTopElement = _this.options.scrollTopElement != '' ? $(_this.options.scrollTopElement) : _this.$element,\n            scrollPos = parseInt($scrollTopElement.offset().top + _this.options.scrollTopOffset);\n        $('html, body').stop(true).animate({ scrollTop: scrollPos }, _this.options.animationDuration, _this.options.animationEasing, function () {\n          /**\n            * Fires after the menu has scrolled\n            * @event Drilldown#scrollme\n            */\n          if (this === $('html')[0]) _this.$element.trigger('scrollme.zf.drilldown');\n        });\n      }\n\n      /**\n       * Adds keydown event listener to `li`'s in the menu.\n       * @private\n       */\n\n    }, {\n      key: '_keyboardEvents',\n      value: function _keyboardEvents() {\n        var _this = this;\n\n        this.$menuItems.add(this.$element.find('.js-drilldown-back > a, .is-submenu-parent-item > a')).on('keydown.zf.drilldown', function (e) {\n          var $element = $(this),\n              $elements = $element.parent('li').parent('ul').children('li').children('a'),\n              $prevElement,\n              $nextElement;\n\n          $elements.each(function (i) {\n            if ($(this).is($element)) {\n              $prevElement = $elements.eq(Math.max(0, i - 1));\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\n              return;\n            }\n          });\n\n          Foundation.Keyboard.handleKey(e, 'Drilldown', {\n            next: function () {\n              if ($element.is(_this.$submenuAnchors)) {\n                _this._show($element.parent('li'));\n                $element.parent('li').one(Foundation.transitionend($element), function () {\n                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\n                });\n                return true;\n              }\n            },\n            previous: function () {\n              _this._hide($element.parent('li').parent('ul'));\n              $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {\n                setTimeout(function () {\n                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();\n                }, 1);\n              });\n              return true;\n            },\n            up: function () {\n              $prevElement.focus();\n              // Don't tap focus on first element in root ul\n              return !$element.is(_this.$element.find('> li:first-child > a'));\n            },\n            down: function () {\n              $nextElement.focus();\n              // Don't tap focus on last element in root ul\n              return !$element.is(_this.$element.find('> li:last-child > a'));\n            },\n            close: function () {\n              // Don't close on element in root ul\n              if (!$element.is(_this.$element.find('> li > a'))) {\n                _this._hide($element.parent().parent());\n                $element.parent().parent().siblings('a').focus();\n              }\n            },\n            open: function () {\n              if (!$element.is(_this.$menuItems)) {\n                // not menu item means back button\n                _this._hide($element.parent('li').parent('ul'));\n                $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {\n                  setTimeout(function () {\n                    $element.parent('li').parent('ul').parent('li').children('a').first().focus();\n                  }, 1);\n                });\n                return true;\n              } else if ($element.is(_this.$submenuAnchors)) {\n                _this._show($element.parent('li'));\n                $element.parent('li').one(Foundation.transitionend($element), function () {\n                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\n                });\n                return true;\n              }\n            },\n            handled: function (preventDefault) {\n              if (preventDefault) {\n                e.preventDefault();\n              }\n              e.stopImmediatePropagation();\n            }\n          });\n        }); // end keyboardAccess\n      }\n\n      /**\n       * Closes all open elements, and returns to root menu.\n       * @function\n       * @fires Drilldown#closed\n       */\n\n    }, {\n      key: '_hideAll',\n      value: function _hideAll() {\n        var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');\n        if (this.options.autoHeight) this.$wrapper.css({ height: $elem.parent().closest('ul').data('calcHeight') });\n        $elem.one(Foundation.transitionend($elem), function (e) {\n          $elem.removeClass('is-active is-closing');\n        });\n        /**\n         * Fires when the menu is fully closed.\n         * @event Drilldown#closed\n         */\n        this.$element.trigger('closed.zf.drilldown');\n      }\n\n      /**\n       * Adds event listener for each `back` button, and closes open menus.\n       * @function\n       * @fires Drilldown#back\n       * @param {jQuery} $elem - the current sub-menu to add `back` event.\n       */\n\n    }, {\n      key: '_back',\n      value: function _back($elem) {\n        var _this = this;\n        $elem.off('click.zf.drilldown');\n        $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {\n          e.stopImmediatePropagation();\n          // console.log('mouseup on back');\n          _this._hide($elem);\n\n          // If there is a parent submenu, call show\n          var parentSubMenu = $elem.parent('li').parent('ul').parent('li');\n          if (parentSubMenu.length) {\n            _this._show(parentSubMenu);\n          }\n        });\n      }\n\n      /**\n       * Adds event listener to menu items w/o submenus to close open menus on click.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_menuLinkEvents',\n      value: function _menuLinkEvents() {\n        var _this = this;\n        this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\n          // e.stopImmediatePropagation();\n          setTimeout(function () {\n            _this._hideAll();\n          }, 0);\n        });\n      }\n\n      /**\n       * Opens a submenu.\n       * @function\n       * @fires Drilldown#open\n       * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.\n       */\n\n    }, {\n      key: '_show',\n      value: function _show($elem) {\n        if (this.options.autoHeight) this.$wrapper.css({ height: $elem.children('[data-submenu]').data('calcHeight') });\n        $elem.attr('aria-expanded', true);\n        $elem.children('[data-submenu]').addClass('is-active').removeClass('invisible').attr('aria-hidden', false);\n        /**\n         * Fires when the submenu has opened.\n         * @event Drilldown#open\n         */\n        this.$element.trigger('open.zf.drilldown', [$elem]);\n      }\n    }, {\n      key: '_hide',\n\n\n      /**\n       * Hides a submenu\n       * @function\n       * @fires Drilldown#hide\n       * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.\n       */\n      value: function _hide($elem) {\n        if (this.options.autoHeight) this.$wrapper.css({ height: $elem.parent().closest('ul').data('calcHeight') });\n        var _this = this;\n        $elem.parent('li').attr('aria-expanded', false);\n        $elem.attr('aria-hidden', true).addClass('is-closing');\n        $elem.addClass('is-closing').one(Foundation.transitionend($elem), function () {\n          $elem.removeClass('is-active is-closing');\n          $elem.blur().addClass('invisible');\n        });\n        /**\n         * Fires when the submenu has closed.\n         * @event Drilldown#hide\n         */\n        $elem.trigger('hide.zf.drilldown', [$elem]);\n      }\n\n      /**\n       * Iterates through the nested menus to calculate the min-height, and max-width for the menu.\n       * Prevents content jumping.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_getMaxDims',\n      value: function _getMaxDims() {\n        var maxHeight = 0,\n            result = {},\n            _this = this;\n        this.$submenus.add(this.$element).each(function () {\n          var numOfElems = $(this).children('li').length;\n          var height = Foundation.Box.GetDimensions(this).height;\n          maxHeight = height > maxHeight ? height : maxHeight;\n          if (_this.options.autoHeight) {\n            $(this).data('calcHeight', height);\n            if (!$(this).hasClass('is-drilldown-submenu')) result['height'] = height;\n          }\n        });\n\n        if (!this.options.autoHeight) result['min-height'] = maxHeight + 'px';\n\n        result['max-width'] = this.$element[0].getBoundingClientRect().width + 'px';\n\n        return result;\n      }\n\n      /**\n       * Destroys the Drilldown Menu\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        if (this.options.scrollTop) this.$element.off('.zf.drilldown', this._bindHandler);\n        this._hideAll();\n        this.$element.off('mutateme.zf.trigger');\n        Foundation.Nest.Burn(this.$element, 'drilldown');\n        this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');\n        this.$submenuAnchors.each(function () {\n          $(this).off('.zf.drilldown');\n        });\n\n        this.$submenus.removeClass('drilldown-submenu-cover-previous');\n\n        this.$element.find('a').each(function () {\n          var $link = $(this);\n          $link.removeAttr('tabindex');\n          if ($link.data('savedHref')) {\n            $link.attr('href', $link.data('savedHref')).removeData('savedHref');\n          } else {\n            return;\n          }\n        });\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Drilldown;\n  }();\n\n  Drilldown.defaults = {\n    /**\n     * Markup used for JS generated back button. Prepended  or appended (see backButtonPosition) to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\\`) if copy and pasting.\n     * @option\n     * @type {string}\n     * @default '<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>'\n     */\n    backButton: '<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>',\n    /**\n     * Position the back button either at the top or bottom of drilldown submenus. Can be `'left'` or `'bottom'`.\n     * @option\n     * @type {string}\n     * @default top\n     */\n    backButtonPosition: 'top',\n    /**\n     * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\\`) if copy and pasting.\n     * @option\n     * @type {string}\n     * @default '<div></div>'\n     */\n    wrapper: '<div></div>',\n    /**\n     * Adds the parent link to the submenu.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    parentLink: false,\n    /**\n     * Allow the menu to return to root list on body click.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    closeOnClick: false,\n    /**\n     * Allow the menu to auto adjust height.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    autoHeight: false,\n    /**\n     * Animate the auto adjust height.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    animateHeight: false,\n    /**\n     * Scroll to the top of the menu after opening a submenu or navigating back using the menu back button\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    scrollTop: false,\n    /**\n     * String jquery selector (for example 'body') of element to take offset().top from, if empty string the drilldown menu offset().top is taken\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    scrollTopElement: '',\n    /**\n     * ScrollTop offset\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    scrollTopOffset: 0,\n    /**\n     * Scroll animation duration\n     * @option\n     * @type {number}\n     * @default 500\n     */\n    animationDuration: 500,\n    /**\n     * Scroll animation easing. Can be `'swing'` or `'linear'`.\n     * @option\n     * @type {string}\n     * @see {@link https://api.jquery.com/animate|JQuery animate}\n     * @default 'swing'\n     */\n    animationEasing: 'swing'\n    // holdOpen: false\n  };\n\n  // Window exports\n  Foundation.plugin(Drilldown, 'Drilldown');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5kcmlsbGRvd24uanM/OWIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBEcmlsbGRvd24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XG4gICAqL1xuXG4gIHZhciBEcmlsbGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyaWxsZG93biBtZW51LlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERyaWxsZG93bihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHJpbGxkb3duKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJpbGxkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICAgIEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdkcmlsbGRvd24nKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdEcmlsbGRvd24nKTtcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicsIHtcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcbiAgICAgICAgJ0FSUk9XX0RPV04nOiAnZG93bicsXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZScsXG4gICAgICAgICdUQUInOiAnZG93bicsXG4gICAgICAgICdTSElGVF9UQUInOiAndXAnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZHJpbGxkb3duIGJ5IGNyZWF0aW5nIGpRdWVyeSBjb2xsZWN0aW9ucyBvZiBlbGVtZW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhEcmlsbGRvd24sIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKS5jaGlsZHJlbignYScpO1xuICAgICAgICB0aGlzLiRzdWJtZW51cyA9IHRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudCgnbGknKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTtcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrJykuYXR0cigncm9sZScsICdtZW51aXRlbScpLmZpbmQoJ2EnKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScsIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1kcmlsbGRvd24nKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdkcmlsbGRvd24nKSk7XG5cbiAgICAgICAgdGhpcy5fcHJlcGFyZU1lbnUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcblxuICAgICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXBhcmVzIGRyaWxsZG93biBtZW51IGJ5IHNldHRpbmcgYXR0cmlidXRlcyB0byBsaW5rcyBhbmQgZWxlbWVudHNcbiAgICAgICAqIHNldHMgYSBtaW4gaGVpZ2h0IHRvIHByZXZlbnQgY29udGVudCBqdW1waW5nXG4gICAgICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wcmVwYXJlTWVudScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBpZighdGhpcy5vcHRpb25zLmhvbGRPcGVuKXtcbiAgICAgICAgLy8gICB0aGlzLl9tZW51TGlua0V2ZW50cygpO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciAkbGluayA9ICQodGhpcyk7XG4gICAgICAgICAgdmFyICRzdWIgPSAkbGluay5wYXJlbnQoKTtcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XG4gICAgICAgICAgICAkbGluay5jbG9uZSgpLnByZXBlbmRUbygkc3ViLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKS53cmFwKCc8bGkgY2xhc3M9XCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXCIgcm9sZT1cIm1lbnUtaXRlbVwiPjwvbGk+Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicsICRsaW5rLmF0dHIoJ2hyZWYnKSkucmVtb3ZlQXR0cignaHJlZicpLmF0dHIoJ3RhYmluZGV4JywgMCk7XG4gICAgICAgICAgJGxpbmsuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogMCxcbiAgICAgICAgICAgICdyb2xlJzogJ21lbnUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMuX2V2ZW50cygkbGluayk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgJG1lbnUgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAkYmFjayA9ICRtZW51LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaycpO1xuICAgICAgICAgIGlmICghJGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvblBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAkbWVudS5hcHBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICRtZW51LnByZXBlbmQoX3RoaXMub3B0aW9ucy5iYWNrQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5zdXBwb3J0ZWQgYmFja0J1dHRvblBvc2l0aW9uIHZhbHVlICdcIiArIF90aGlzLm9wdGlvbnMuYmFja0J1dHRvblBvc2l0aW9uICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5fYmFjaygkbWVudSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdpbnZpc2libGUnKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuJHN1Ym1lbnVzLmFkZENsYXNzKCdkcmlsbGRvd24tc3VibWVudS1jb3Zlci1wcmV2aW91cycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgd3JhcHBlciBvbiBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgIGlmICghdGhpcy4kZWxlbWVudC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtZHJpbGxkb3duJykpIHtcbiAgICAgICAgICB0aGlzLiR3cmFwcGVyID0gJCh0aGlzLm9wdGlvbnMud3JhcHBlcikuYWRkQ2xhc3MoJ2lzLWRyaWxsZG93bicpO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZUhlaWdodCkgdGhpcy4kd3JhcHBlci5hZGRDbGFzcygnYW5pbWF0ZS1oZWlnaHQnKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHdyYXBwZXJcbiAgICAgICAgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQucGFyZW50KCk7XG4gICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc2l6ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy4kd3JhcHBlci5jc3MoeyAnbWF4LXdpZHRoJzogJ25vbmUnLCAnbWluLWhlaWdodCc6ICdub25lJyB9KTtcbiAgICAgICAgLy8gX2dldE1heERpbXMgaGFzIHNpZGUgZWZmZWN0cyAoYm9vKSBidXQgY2FsbGluZyBpdCBzaG91bGQgdXBkYXRlIGFsbCBvdGhlciBuZWNlc3NhcnkgaGVpZ2h0cyAmIHdpZHRoc1xuICAgICAgICB0aGlzLiR3cmFwcGVyLmNzcyh0aGlzLl9nZXRNYXhEaW1zKCkpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCRlbGVtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpZiAoJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdsaScpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKSkge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZihlLnRhcmdldCAhPT0gZS5jdXJyZW50VGFyZ2V0LmZpcnN0RWxlbWVudENoaWxkKXtcbiAgICAgICAgICAvLyAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW0ucGFyZW50KCdsaScpKTtcblxuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xuICAgICAgICAgICAgdmFyICRib2R5ID0gJCgnYm9keScpO1xuICAgICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcbiAgICAgICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtdXRhdGVtZS56Zi50cmlnZ2VyJywgdGhpcy5fcmVzaXplLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG1lbnUgZWxlbWVudC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlZ2lzdGVyRXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJFdmVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgdGhpcy5fYmluZEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxUb3AuYmluZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdvcGVuLnpmLmRyaWxsZG93biBoaWRlLnpmLmRyaWxsZG93biBjbG9zZWQuemYuZHJpbGxkb3duJywgdGhpcy5fYmluZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIHRvIFRvcCBvZiBFbGVtZW50IG9yIGRhdGEtc2Nyb2xsLXRvcC1lbGVtZW50XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jc2Nyb2xsbWVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Njcm9sbFRvcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Njcm9sbFRvcCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICRzY3JvbGxUb3BFbGVtZW50ID0gX3RoaXMub3B0aW9ucy5zY3JvbGxUb3BFbGVtZW50ICE9ICcnID8gJChfdGhpcy5vcHRpb25zLnNjcm9sbFRvcEVsZW1lbnQpIDogX3RoaXMuJGVsZW1lbnQsXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSBwYXJzZUludCgkc2Nyb2xsVG9wRWxlbWVudC5vZmZzZXQoKS50b3AgKyBfdGhpcy5vcHRpb25zLnNjcm9sbFRvcE9mZnNldCk7XG4gICAgICAgICQoJ2h0bWwsIGJvZHknKS5zdG9wKHRydWUpLmFuaW1hdGUoeyBzY3JvbGxUb3A6IHNjcm9sbFBvcyB9LCBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLCBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBGaXJlcyBhZnRlciB0aGUgbWVudSBoYXMgc2Nyb2xsZWRcbiAgICAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNzY3JvbGxtZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGhpcyA9PT0gJCgnaHRtbCcpWzBdKSBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzY3JvbGxtZS56Zi5kcmlsbGRvd24nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBrZXlkb3duIGV2ZW50IGxpc3RlbmVyIHRvIGBsaWAncyBpbiB0aGUgbWVudS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19rZXlib2FyZEV2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2tleWJvYXJkRXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2sgPiBhLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbSA+IGEnKSkub24oJ2tleWRvd24uemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLmNoaWxkcmVuKCdhJyksXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5tYXgoMCwgaSAtIDEpKTtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnRHJpbGxkb3duJywge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoJGVsZW1lbnQuaXMoX3RoaXMuJHN1Ym1lbnVBbmNob3JzKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykuZmluZCgndWwgbGkgYScpLmZpbHRlcihfdGhpcy4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcbiAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgdGFwIGZvY3VzIG9uIGZpcnN0IGVsZW1lbnQgaW4gcm9vdCB1bFxuICAgICAgICAgICAgICByZXR1cm4gISRlbGVtZW50LmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJz4gbGk6Zmlyc3QtY2hpbGQgPiBhJykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgIC8vIERvbid0IHRhcCBmb2N1cyBvbiBsYXN0IGVsZW1lbnQgaW4gcm9vdCB1bFxuICAgICAgICAgICAgICByZXR1cm4gISRlbGVtZW50LmlzKF90aGlzLiRlbGVtZW50LmZpbmQoJz4gbGk6bGFzdC1jaGlsZCA+IGEnKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgY2xvc2Ugb24gZWxlbWVudCBpbiByb290IHVsXG4gICAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnPiBsaSA+IGEnKSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoKS5wYXJlbnQoKSk7XG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCkucGFyZW50KCkuc2libGluZ3MoJ2EnKS5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKF90aGlzLiRtZW51SXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IG1lbnUgaXRlbSBtZWFucyBiYWNrIGJ1dHRvblxuICAgICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpO1xuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5jaGlsZHJlbignYScpLmZpcnN0KCkuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpO1xuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5maWx0ZXIoX3RoaXMuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTsgLy8gZW5kIGtleWJvYXJkQWNjZXNzXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIGFsbCBvcGVuIGVsZW1lbnRzLCBhbmQgcmV0dXJucyB0byByb290IG1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jY2xvc2VkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oaWRlQWxsJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZUFsbCgpIHtcbiAgICAgICAgdmFyICRlbGVtID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlJykuYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB0aGlzLiR3cmFwcGVyLmNzcyh7IGhlaWdodDogJGVsZW0ucGFyZW50KCkuY2xvc2VzdCgndWwnKS5kYXRhKCdjYWxjSGVpZ2h0JykgfSk7XG4gICAgICAgICRlbGVtLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgY2xvc2VkLlxuICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBldmVudCBsaXN0ZW5lciBmb3IgZWFjaCBgYmFja2AgYnV0dG9uLCBhbmQgY2xvc2VzIG9wZW4gbWVudXMuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jYmFja1xuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gYWRkIGBiYWNrYCBldmVudC5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2JhY2snLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrKCRlbGVtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJyk7XG4gICAgICAgICRlbGVtLmNoaWxkcmVuKCcuanMtZHJpbGxkb3duLWJhY2snKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtb3VzZXVwIG9uIGJhY2snKTtcbiAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG5cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCBzdWJtZW51LCBjYWxsIHNob3dcbiAgICAgICAgICB2YXIgcGFyZW50U3ViTWVudSA9ICRlbGVtLnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xuICAgICAgICAgIGlmIChwYXJlbnRTdWJNZW51Lmxlbmd0aCkge1xuICAgICAgICAgICAgX3RoaXMuX3Nob3cocGFyZW50U3ViTWVudSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIHRvIG1lbnUgaXRlbXMgdy9vIHN1Ym1lbnVzIHRvIGNsb3NlIG9wZW4gbWVudXMgb24gY2xpY2suXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19tZW51TGlua0V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21lbnVMaW5rRXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLiRtZW51SXRlbXMubm90KCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50Jykub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAvLyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2hpZGVBbGwoKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogT3BlbnMgYSBzdWJtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgRHJpbGxkb3duI29wZW5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gb3BlbiwgaS5lLiB0aGUgYGxpYCB0YWcuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zaG93JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkZWxlbSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKHsgaGVpZ2h0OiAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5kYXRhKCdjYWxjSGVpZ2h0JykgfSk7XG4gICAgICAgICRlbGVtLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpbnZpc2libGUnKS5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIG9wZW5lZC5cbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNvcGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2hpZGUnLFxuXG5cbiAgICAgIC8qKlxuICAgICAgICogSGlkZXMgYSBzdWJtZW51XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jaGlkZVxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgc3ViLW1lbnUgdG8gaGlkZSwgaS5lLiB0aGUgYHVsYCB0YWcuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgkZWxlbSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9IZWlnaHQpIHRoaXMuJHdyYXBwZXIuY3NzKHsgaGVpZ2h0OiAkZWxlbS5wYXJlbnQoKS5jbG9zZXN0KCd1bCcpLmRhdGEoJ2NhbGNIZWlnaHQnKSB9KTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgJGVsZW0ucGFyZW50KCdsaScpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgICRlbGVtLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSkuYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKTtcbiAgICAgICAgJGVsZW0uYWRkQ2xhc3MoJ2lzLWNsb3NpbmcnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xuICAgICAgICAgICRlbGVtLmJsdXIoKS5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxuICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2hpZGVcbiAgICAgICAgICovXG4gICAgICAgICRlbGVtLnRyaWdnZXIoJ2hpZGUuemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSXRlcmF0ZXMgdGhyb3VnaCB0aGUgbmVzdGVkIG1lbnVzIHRvIGNhbGN1bGF0ZSB0aGUgbWluLWhlaWdodCwgYW5kIG1heC13aWR0aCBmb3IgdGhlIG1lbnUuXG4gICAgICAgKiBQcmV2ZW50cyBjb250ZW50IGp1bXBpbmcuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRNYXhEaW1zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4RGltcygpIHtcbiAgICAgICAgdmFyIG1heEhlaWdodCA9IDAsXG4gICAgICAgICAgICByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBudW1PZkVsZW1zID0gJCh0aGlzKS5jaGlsZHJlbignbGknKS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcykuaGVpZ2h0O1xuICAgICAgICAgIG1heEhlaWdodCA9IGhlaWdodCA+IG1heEhlaWdodCA/IGhlaWdodCA6IG1heEhlaWdodDtcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgICAgICAkKHRoaXMpLmRhdGEoJ2NhbGNIZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKCEkKHRoaXMpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudScpKSByZXN1bHRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYXV0b0hlaWdodCkgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBtYXhIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIHJlc3VsdFsnbWF4LXdpZHRoJ10gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgJ3B4JztcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2Nyb2xsVG9wKSB0aGlzLiRlbGVtZW50Lm9mZignLnpmLmRyaWxsZG93bicsIHRoaXMuX2JpbmRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5faGlkZUFsbCgpO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xuICAgICAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbScpLnJlbW92ZSgpLmVuZCgpLmZpbmQoJy5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnUnKS5lbmQoKS5maW5kKCdbZGF0YS1zdWJtZW51XScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGUnKTtcbiAgICAgICAgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJCh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kc3VibWVudXMucmVtb3ZlQ2xhc3MoJ2RyaWxsZG93bi1zdWJtZW51LWNvdmVyLXByZXZpb3VzJyk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICRsaW5rID0gJCh0aGlzKTtcbiAgICAgICAgICAkbGluay5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xuICAgICAgICAgICAgJGxpbmsuYXR0cignaHJlZicsICRsaW5rLmRhdGEoJ3NhdmVkSHJlZicpKS5yZW1vdmVEYXRhKCdzYXZlZEhyZWYnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRHJpbGxkb3duO1xuICB9KCk7XG5cbiAgRHJpbGxkb3duLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCAgb3IgYXBwZW5kZWQgKHNlZSBiYWNrQnV0dG9uUG9zaXRpb24pIHRvIHN1Ym1lbnUgbGlzdHMgYW5kIGRlbGV0ZWQgb24gYGRlc3Ryb3lgIG1ldGhvZCwgJ2pzLWRyaWxsZG93bi1iYWNrJyBjbGFzcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJzxsaSBjbGFzcz1cImpzLWRyaWxsZG93bi1iYWNrXCI+PGEgdGFiaW5kZXg9XCIwXCI+QmFjazwvYT48L2xpPidcbiAgICAgKi9cbiAgICBiYWNrQnV0dG9uOiAnPGxpIGNsYXNzPVwianMtZHJpbGxkb3duLWJhY2tcIj48YSB0YWJpbmRleD1cIjBcIj5CYWNrPC9hPjwvbGk+JyxcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB0aGUgYmFjayBidXR0b24gZWl0aGVyIGF0IHRoZSB0b3Agb3IgYm90dG9tIG9mIGRyaWxsZG93biBzdWJtZW51cy4gQ2FuIGJlIGAnbGVmdCdgIG9yIGAnYm90dG9tJ2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgdG9wXG4gICAgICovXG4gICAgYmFja0J1dHRvblBvc2l0aW9uOiAndG9wJyxcbiAgICAvKipcbiAgICAgKiBNYXJrdXAgdXNlZCB0byB3cmFwIGRyaWxsZG93biBtZW51LiBVc2UgYSBjbGFzcyBuYW1lIGZvciBpbmRlcGVuZGVudCBzdHlsaW5nOyB0aGUgSlMgYXBwbGllZCBjbGFzczogYGlzLWRyaWxsZG93bmAgaXMgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxgKSBpZiBjb3B5IGFuZCBwYXN0aW5nLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICc8ZGl2PjwvZGl2PidcbiAgICAgKi9cbiAgICB3cmFwcGVyOiAnPGRpdj48L2Rpdj4nLFxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIHBhcmVudCBsaW5rIHRvIHRoZSBzdWJtZW51LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHBhcmVudExpbms6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93IHRoZSBtZW51IHRvIHJldHVybiB0byByb290IGxpc3Qgb24gYm9keSBjbGljay5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBjbG9zZU9uQ2xpY2s6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93IHRoZSBtZW51IHRvIGF1dG8gYWRqdXN0IGhlaWdodC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhdXRvSGVpZ2h0OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHRoZSBhdXRvIGFkanVzdCBoZWlnaHQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYW5pbWF0ZUhlaWdodDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogU2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIG1lbnUgYWZ0ZXIgb3BlbmluZyBhIHN1Ym1lbnUgb3IgbmF2aWdhdGluZyBiYWNrIHVzaW5nIHRoZSBtZW51IGJhY2sgYnV0dG9uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgc2Nyb2xsVG9wOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBTdHJpbmcganF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSAnYm9keScpIG9mIGVsZW1lbnQgdG8gdGFrZSBvZmZzZXQoKS50b3AgZnJvbSwgaWYgZW1wdHkgc3RyaW5nIHRoZSBkcmlsbGRvd24gbWVudSBvZmZzZXQoKS50b3AgaXMgdGFrZW5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIHNjcm9sbFRvcEVsZW1lbnQ6ICcnLFxuICAgIC8qKlxuICAgICAqIFNjcm9sbFRvcCBvZmZzZXRcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2Nyb2xsVG9wT2Zmc2V0OiAwLFxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBhbmltYXRpb24gZHVyYXRpb25cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgKi9cbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBhbmltYXRpb24gZWFzaW5nLiBDYW4gYmUgYCdzd2luZydgIG9yIGAnbGluZWFyJ2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpRdWVyeSBhbmltYXRlfVxuICAgICAqIEBkZWZhdWx0ICdzd2luZydcbiAgICAgKi9cbiAgICBhbmltYXRpb25FYXNpbmc6ICdzd2luZydcbiAgICAvLyBob2xkT3BlbjogZmFsc2VcbiAgfTtcblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihEcmlsbGRvd24sICdEcmlsbGRvd24nKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5kcmlsbGRvd24uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 5 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Dropdown module.\n   * @module foundation.dropdown\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.box\n   * @requires foundation.util.triggers\n   */\n\n  var Dropdown = function () {\n    /**\n     * Creates a new instance of a dropdown.\n     * @class\n     * @param {jQuery} element - jQuery object to make into a dropdown.\n     *        Object should be of the dropdown panel, rather than its anchor.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Dropdown(element, options) {\n      _classCallCheck(this, Dropdown);\n\n      this.$element = element;\n      this.options = $.extend({}, Dropdown.defaults, this.$element.data(), options);\n      this._init();\n\n      Foundation.registerPlugin(this, 'Dropdown');\n      Foundation.Keyboard.register('Dropdown', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.\n     * @function\n     * @private\n     */\n\n\n    _createClass(Dropdown, [{\n      key: '_init',\n      value: function _init() {\n        var $id = this.$element.attr('id');\n\n        this.$anchor = $('[data-toggle=\"' + $id + '\"]').length ? $('[data-toggle=\"' + $id + '\"]') : $('[data-open=\"' + $id + '\"]');\n        this.$anchor.attr({\n          'aria-controls': $id,\n          'data-is-focus': false,\n          'data-yeti-box': $id,\n          'aria-haspopup': true,\n          'aria-expanded': false\n\n        });\n\n        if (this.options.parentClass) {\n          this.$parent = this.$element.parents('.' + this.options.parentClass);\n        } else {\n          this.$parent = null;\n        }\n        this.options.positionClass = this.getPositionClass();\n        this.counter = 4;\n        this.usedPositions = [];\n        this.$element.attr({\n          'aria-hidden': 'true',\n          'data-yeti-box': $id,\n          'data-resize': $id,\n          'aria-labelledby': this.$anchor[0].id || Foundation.GetYoDigits(6, 'dd-anchor')\n        });\n        this._events();\n      }\n\n      /**\n       * Helper function to determine current orientation of dropdown pane.\n       * @function\n       * @returns {String} position - string value of a position class.\n       */\n\n    }, {\n      key: 'getPositionClass',\n      value: function getPositionClass() {\n        var verticalPosition = this.$element[0].className.match(/(top|left|right|bottom)/g);\n        verticalPosition = verticalPosition ? verticalPosition[0] : '';\n        var horizontalPosition = /float-(\\S+)/.exec(this.$anchor[0].className);\n        horizontalPosition = horizontalPosition ? horizontalPosition[1] : '';\n        var position = horizontalPosition ? horizontalPosition + ' ' + verticalPosition : verticalPosition;\n\n        return position;\n      }\n\n      /**\n       * Adjusts the dropdown panes orientation by adding/removing positioning classes.\n       * @function\n       * @private\n       * @param {String} position - position class to remove.\n       */\n\n    }, {\n      key: '_reposition',\n      value: function _reposition(position) {\n        this.usedPositions.push(position ? position : 'bottom');\n        //default, try switching to opposite side\n        if (!position && this.usedPositions.indexOf('top') < 0) {\n          this.$element.addClass('top');\n        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {\n          this.$element.removeClass(position);\n        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {\n          this.$element.removeClass(position).addClass('right');\n        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {\n          this.$element.removeClass(position).addClass('left');\n        }\n\n        //if default change didn't work, try bottom or left first\n        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {\n            this.$element.addClass('left');\n          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {\n            this.$element.removeClass(position).addClass('left');\n          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {\n            this.$element.removeClass(position);\n          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {\n            this.$element.removeClass(position);\n          }\n          //if nothing cleared, set to bottom\n          else {\n              this.$element.removeClass(position);\n            }\n        this.classChanged = true;\n        this.counter--;\n      }\n\n      /**\n       * Sets the position and orientation of the dropdown pane, checks for collisions.\n       * Recursively calls itself if a collision is detected, with a new position class.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_setPosition',\n      value: function _setPosition() {\n        if (this.$anchor.attr('aria-expanded') === 'false') {\n          return false;\n        }\n        var position = this.getPositionClass(),\n            $eleDims = Foundation.Box.GetDimensions(this.$element),\n            $anchorDims = Foundation.Box.GetDimensions(this.$anchor),\n            _this = this,\n            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',\n            param = direction === 'top' ? 'height' : 'width',\n            offset = param === 'height' ? this.options.vOffset : this.options.hOffset;\n\n        if ($eleDims.width >= $eleDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.$element, this.$parent)) {\n          var newWidth = $eleDims.windowDims.width,\n              parentHOffset = 0;\n          if (this.$parent) {\n            var $parentDims = Foundation.Box.GetDimensions(this.$parent),\n                parentHOffset = $parentDims.offset.left;\n            if ($parentDims.width < newWidth) {\n              newWidth = $parentDims.width;\n            }\n          }\n\n          this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, 'center bottom', this.options.vOffset, this.options.hOffset + parentHOffset, true)).css({\n            'width': newWidth - this.options.hOffset * 2,\n            'height': 'auto'\n          });\n          this.classChanged = true;\n          return false;\n        }\n\n        this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, position, this.options.vOffset, this.options.hOffset));\n\n        while (!Foundation.Box.ImNotTouchingYou(this.$element, this.$parent, true) && this.counter) {\n          this._reposition(position);\n          this._setPosition();\n        }\n      }\n\n      /**\n       * Adds event listeners to the element utilizing the triggers utility library.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n        this.$element.on({\n          'open.zf.trigger': this.open.bind(this),\n          'close.zf.trigger': this.close.bind(this),\n          'toggle.zf.trigger': this.toggle.bind(this),\n          'resizeme.zf.trigger': this._setPosition.bind(this)\n        });\n\n        if (this.options.hover) {\n          this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\n            var bodyData = $('body').data();\n            if (typeof bodyData.whatinput === 'undefined' || bodyData.whatinput === 'mouse') {\n              clearTimeout(_this.timeout);\n              _this.timeout = setTimeout(function () {\n                _this.open();\n                _this.$anchor.data('hover', true);\n              }, _this.options.hoverDelay);\n            }\n          }).on('mouseleave.zf.dropdown', function () {\n            clearTimeout(_this.timeout);\n            _this.timeout = setTimeout(function () {\n              _this.close();\n              _this.$anchor.data('hover', false);\n            }, _this.options.hoverDelay);\n          });\n          if (this.options.hoverPane) {\n            this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\n              clearTimeout(_this.timeout);\n            }).on('mouseleave.zf.dropdown', function () {\n              clearTimeout(_this.timeout);\n              _this.timeout = setTimeout(function () {\n                _this.close();\n                _this.$anchor.data('hover', false);\n              }, _this.options.hoverDelay);\n            });\n          }\n        }\n        this.$anchor.add(this.$element).on('keydown.zf.dropdown', function (e) {\n\n          var $target = $(this),\n              visibleFocusableElements = Foundation.Keyboard.findFocusable(_this.$element);\n\n          Foundation.Keyboard.handleKey(e, 'Dropdown', {\n            open: function () {\n              if ($target.is(_this.$anchor)) {\n                _this.open();\n                _this.$element.attr('tabindex', -1).focus();\n                e.preventDefault();\n              }\n            },\n            close: function () {\n              _this.close();\n              _this.$anchor.focus();\n            }\n          });\n        });\n      }\n\n      /**\n       * Adds an event handler to the body to close any dropdowns on a click.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_addBodyHandler',\n      value: function _addBodyHandler() {\n        var $body = $(document.body).not(this.$element),\n            _this = this;\n        $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {\n          if (_this.$anchor.is(e.target) || _this.$anchor.find(e.target).length) {\n            return;\n          }\n          if (_this.$element.find(e.target).length) {\n            return;\n          }\n          _this.close();\n          $body.off('click.zf.dropdown');\n        });\n      }\n\n      /**\n       * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.\n       * @function\n       * @fires Dropdown#closeme\n       * @fires Dropdown#show\n       */\n\n    }, {\n      key: 'open',\n      value: function open() {\n        // var _this = this;\n        /**\n         * Fires to close other open dropdowns, typically when dropdown is opening\n         * @event Dropdown#closeme\n         */\n        this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));\n        this.$anchor.addClass('hover').attr({ 'aria-expanded': true });\n        // this.$element/*.show()*/;\n        this._setPosition();\n        this.$element.addClass('is-open').attr({ 'aria-hidden': false });\n\n        if (this.options.autoFocus) {\n          var $focusable = Foundation.Keyboard.findFocusable(this.$element);\n          if ($focusable.length) {\n            $focusable.eq(0).focus();\n          }\n        }\n\n        if (this.options.closeOnClick) {\n          this._addBodyHandler();\n        }\n\n        if (this.options.trapFocus) {\n          Foundation.Keyboard.trapFocus(this.$element);\n        }\n\n        /**\n         * Fires once the dropdown is visible.\n         * @event Dropdown#show\n         */\n        this.$element.trigger('show.zf.dropdown', [this.$element]);\n      }\n\n      /**\n       * Closes the open dropdown pane.\n       * @function\n       * @fires Dropdown#hide\n       */\n\n    }, {\n      key: 'close',\n      value: function close() {\n        if (!this.$element.hasClass('is-open')) {\n          return false;\n        }\n        this.$element.removeClass('is-open').attr({ 'aria-hidden': true });\n\n        this.$anchor.removeClass('hover').attr('aria-expanded', false);\n\n        if (this.classChanged) {\n          var curPositionClass = this.getPositionClass();\n          if (curPositionClass) {\n            this.$element.removeClass(curPositionClass);\n          }\n          this.$element.addClass(this.options.positionClass)\n          /*.hide()*/.css({ height: '', width: '' });\n          this.classChanged = false;\n          this.counter = 4;\n          this.usedPositions.length = 0;\n        }\n        /**\n         * Fires once the dropdown is no longer visible.\n         * @event Dropdown#hide\n         */\n        this.$element.trigger('hide.zf.dropdown', [this.$element]);\n\n        if (this.options.trapFocus) {\n          Foundation.Keyboard.releaseFocus(this.$element);\n        }\n      }\n\n      /**\n       * Toggles the dropdown pane's visibility.\n       * @function\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle() {\n        if (this.$element.hasClass('is-open')) {\n          if (this.$anchor.data('hover')) return;\n          this.close();\n        } else {\n          this.open();\n        }\n      }\n\n      /**\n       * Destroys the dropdown.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.off('.zf.trigger').hide();\n        this.$anchor.off('.zf.dropdown');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Dropdown;\n  }();\n\n  Dropdown.defaults = {\n    /**\n     * Class that designates bounding container of Dropdown (default: window)\n     * @option\n     * @type {?string}\n     * @default null\n     */\n    parentClass: null,\n    /**\n     * Amount of time to delay opening a submenu on hover event.\n     * @option\n     * @type {number}\n     * @default 250\n     */\n    hoverDelay: 250,\n    /**\n     * Allow submenus to open on hover events\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    hover: false,\n    /**\n     * Don't close dropdown when hovering over dropdown pane\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    hoverPane: false,\n    /**\n     * Number of pixels between the dropdown pane and the triggering element on open.\n     * @option\n     * @type {number}\n     * @default 1\n     */\n    vOffset: 1,\n    /**\n     * Number of pixels between the dropdown pane and the triggering element on open.\n     * @option\n     * @type {number}\n     * @default 1\n     */\n    hOffset: 1,\n    /**\n     * Class applied to adjust open position. JS will test and fill this in.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    positionClass: '',\n    /**\n     * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    trapFocus: false,\n    /**\n     * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    autoFocus: false,\n    /**\n     * Allows a click on the body to close the dropdown.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    closeOnClick: false\n  };\n\n  // Window exports\n  Foundation.plugin(Dropdown, 'Dropdown');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5kcm9wZG93bi5qcz9kNjg5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIERyb3Bkb3duIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICAgKi9cblxuICB2YXIgRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyb3Bkb3duLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cbiAgICAgKiAgICAgICAgT2JqZWN0IHNob3VsZCBiZSBvZiB0aGUgZHJvcGRvd24gcGFuZWwsIHJhdGhlciB0aGFuIGl0cyBhbmNob3IuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERyb3Bkb3duKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bik7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyb3Bkb3duLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0Ryb3Bkb3duJyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bicsIHtcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxuICAgICAgICAnU1BBQ0UnOiAnb3BlbicsXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IHNldHRpbmcvY2hlY2tpbmcgb3B0aW9ucyBhbmQgYXR0cmlidXRlcywgYWRkaW5nIGhlbHBlciB2YXJpYWJsZXMsIGFuZCBzYXZpbmcgdGhlIGFuY2hvci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHZhciAkaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XG5cbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJCgnW2RhdGEtdG9nZ2xlPVwiJyArICRpZCArICdcIl0nKS5sZW5ndGggPyAkKCdbZGF0YS10b2dnbGU9XCInICsgJGlkICsgJ1wiXScpIDogJCgnW2RhdGEtb3Blbj1cIicgKyAkaWQgKyAnXCJdJyk7XG4gICAgICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6ICRpZCxcbiAgICAgICAgICAnZGF0YS1pcy1mb2N1cyc6IGZhbHNlLFxuICAgICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxuICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlXG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnRDbGFzcykge1xuICAgICAgICAgIHRoaXMuJHBhcmVudCA9IHRoaXMuJGVsZW1lbnQucGFyZW50cygnLicgKyB0aGlzLm9wdGlvbnMucGFyZW50Q2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJHBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gNDtcbiAgICAgICAgdGhpcy51c2VkUG9zaXRpb25zID0gW107XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxuICAgICAgICAgICdkYXRhLXlldGktYm94JzogJGlkLFxuICAgICAgICAgICdkYXRhLXJlc2l6ZSc6ICRpZCxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy4kYW5jaG9yWzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2RkLWFuY2hvcicpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgb3JpZW50YXRpb24gb2YgZHJvcGRvd24gcGFuZS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gcG9zaXRpb24gLSBzdHJpbmcgdmFsdWUgb2YgYSBwb3NpdGlvbiBjbGFzcy5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0UG9zaXRpb25DbGFzcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb25DbGFzcygpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsUG9zaXRpb24gPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7XG4gICAgICAgIHZlcnRpY2FsUG9zaXRpb24gPSB2ZXJ0aWNhbFBvc2l0aW9uID8gdmVydGljYWxQb3NpdGlvblswXSA6ICcnO1xuICAgICAgICB2YXIgaG9yaXpvbnRhbFBvc2l0aW9uID0gL2Zsb2F0LShcXFMrKS8uZXhlYyh0aGlzLiRhbmNob3JbMF0uY2xhc3NOYW1lKTtcbiAgICAgICAgaG9yaXpvbnRhbFBvc2l0aW9uID0gaG9yaXpvbnRhbFBvc2l0aW9uID8gaG9yaXpvbnRhbFBvc2l0aW9uWzFdIDogJyc7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGhvcml6b250YWxQb3NpdGlvbiA/IGhvcml6b250YWxQb3NpdGlvbiArICcgJyArIHZlcnRpY2FsUG9zaXRpb24gOiB2ZXJ0aWNhbFBvc2l0aW9uO1xuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGp1c3RzIHRoZSBkcm9wZG93biBwYW5lcyBvcmllbnRhdGlvbiBieSBhZGRpbmcvcmVtb3ZpbmcgcG9zaXRpb25pbmcgY2xhc3Nlcy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbiAtIHBvc2l0aW9uIGNsYXNzIHRvIHJlbW92ZS5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlcG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uID8gcG9zaXRpb24gOiAnYm90dG9tJyk7XG4gICAgICAgIC8vZGVmYXVsdCwgdHJ5IHN3aXRjaGluZyB0byBvcHBvc2l0ZSBzaWRlXG4gICAgICAgIGlmICghcG9zaXRpb24gJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ3RvcCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAndG9wJyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygncmlnaHQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbiAgICAgICAgZWxzZSBpZiAoIXBvc2l0aW9uICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdsZWZ0Jyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdyaWdodCcpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vaWYgbm90aGluZyBjbGVhcmVkLCBzZXQgdG8gYm90dG9tXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY291bnRlci0tO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiB0aGUgZHJvcGRvd24gcGFuZSwgY2hlY2tzIGZvciBjb2xsaXNpb25zLlxuICAgICAgICogUmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIGlmIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkLCB3aXRoIGEgbmV3IHBvc2l0aW9uIGNsYXNzLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0UG9zaXRpb24nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuJGFuY2hvci5hdHRyKCdhcmlhLWV4cGFuZGVkJykgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksXG4gICAgICAgICAgICAkZWxlRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXG4gICAgICAgICAgICAkYW5jaG9yRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kYW5jaG9yKSxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAnbGVmdCcgOiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnLFxuICAgICAgICAgICAgcGFyYW0gPSBkaXJlY3Rpb24gPT09ICd0b3AnID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyYW0gPT09ICdoZWlnaHQnID8gdGhpcy5vcHRpb25zLnZPZmZzZXQgOiB0aGlzLm9wdGlvbnMuaE9mZnNldDtcblxuICAgICAgICBpZiAoJGVsZURpbXMud2lkdGggPj0gJGVsZURpbXMud2luZG93RGltcy53aWR0aCB8fCAhdGhpcy5jb3VudGVyICYmICFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQsIHRoaXMuJHBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgbmV3V2lkdGggPSAkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoLFxuICAgICAgICAgICAgICBwYXJlbnRIT2Zmc2V0ID0gMDtcbiAgICAgICAgICBpZiAodGhpcy4kcGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgJHBhcmVudERpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJHBhcmVudCksXG4gICAgICAgICAgICAgICAgcGFyZW50SE9mZnNldCA9ICRwYXJlbnREaW1zLm9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgaWYgKCRwYXJlbnREaW1zLndpZHRoIDwgbmV3V2lkdGgpIHtcbiAgICAgICAgICAgICAgbmV3V2lkdGggPSAkcGFyZW50RGltcy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQgKyBwYXJlbnRIT2Zmc2V0LCB0cnVlKSkuY3NzKHtcbiAgICAgICAgICAgICd3aWR0aCc6IG5ld1dpZHRoIC0gdGhpcy5vcHRpb25zLmhPZmZzZXQgKiAyLFxuICAgICAgICAgICAgJ2hlaWdodCc6ICdhdXRvJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgcG9zaXRpb24sIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCkpO1xuXG4gICAgICAgIHdoaWxlICghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50LCB0aGlzLiRwYXJlbnQsIHRydWUpICYmIHRoaXMuY291bnRlcikge1xuICAgICAgICAgIHRoaXMuX3JlcG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudCB1dGlsaXppbmcgdGhlIHRyaWdnZXJzIHV0aWxpdHkgbGlicmFyeS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIpIHtcbiAgICAgICAgICB0aGlzLiRhbmNob3Iub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBib2R5RGF0YSA9ICQoJ2JvZHknKS5kYXRhKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJvZHlEYXRhLndoYXRpbnB1dCA9PT0gJ3VuZGVmaW5lZCcgfHwgYm9keURhdGEud2hhdGlucHV0ID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJQYW5lKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kYW5jaG9yLmFkZCh0aGlzLiRlbGVtZW50KS5vbigna2V5ZG93bi56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XG5cbiAgICAgICAgICB2YXIgJHRhcmdldCA9ICQodGhpcyksXG4gICAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpcy4kZWxlbWVudCk7XG5cbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnRHJvcGRvd24nLCB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKF90aGlzLiRhbmNob3IpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGFuIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGJvZHkgdG8gY2xvc2UgYW55IGRyb3Bkb3ducyBvbiBhIGNsaWNrLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkQm9keUhhbmRsZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcbiAgICAgICAgdmFyICRib2R5ID0gJChkb2N1bWVudC5ib2R5KS5ub3QodGhpcy4kZWxlbWVudCksXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgICRib2R5Lm9mZignY2xpY2suemYuZHJvcGRvd24nKS5vbignY2xpY2suemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChfdGhpcy4kYW5jaG9yLmlzKGUudGFyZ2V0KSB8fCBfdGhpcy4kYW5jaG9yLmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgJGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd24jY2xvc2VtZVxuICAgICAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb3BlbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgLy8gdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zLCB0eXBpY2FsbHkgd2hlbiBkcm9wZG93biBpcyBvcGVuaW5nXG4gICAgICAgICAqIEBldmVudCBEcm9wZG93biNjbG9zZW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgICAgICB0aGlzLiRhbmNob3IuYWRkQ2xhc3MoJ2hvdmVyJykuYXR0cih7ICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSB9KTtcbiAgICAgICAgLy8gdGhpcy4kZWxlbWVudC8qLnNob3coKSovO1xuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1vcGVuJykuYXR0cih7ICdhcmlhLWhpZGRlbic6IGZhbHNlIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdmFyICRmb2N1c2FibGUgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7XG4gICAgICAgICAgaWYgKCRmb2N1c2FibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAkZm9jdXNhYmxlLmVxKDApLmZvY3VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyB2aXNpYmxlLlxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd24jc2hvd1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIERyb3Bkb3duI2hpZGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2xvc2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJykuYXR0cih7ICdhcmlhLWhpZGRlbic6IHRydWUgfSk7XG5cbiAgICAgICAgdGhpcy4kYW5jaG9yLnJlbW92ZUNsYXNzKCdob3ZlcicpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xhc3NDaGFuZ2VkKSB7XG4gICAgICAgICAgdmFyIGN1clBvc2l0aW9uQ2xhc3MgPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTtcbiAgICAgICAgICBpZiAoY3VyUG9zaXRpb25DbGFzcykge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjdXJQb3NpdGlvbkNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcylcbiAgICAgICAgICAvKi5oaWRlKCkqLy5jc3MoeyBoZWlnaHQ6ICcnLCB3aWR0aDogJycgfSk7XG4gICAgICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyBubyBsb25nZXIgdmlzaWJsZS5cbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duI2hpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bicsIFt0aGlzLiRlbGVtZW50XSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlbGVhc2VGb2N1cyh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIGRyb3Bkb3duIHBhbmUncyB2aXNpYmlsaXR5LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvZ2dsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJGFuY2hvci5kYXRhKCdob3ZlcicpKSByZXR1cm47XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIGRyb3Bkb3duLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlcicpLmhpZGUoKTtcbiAgICAgICAgdGhpcy4kYW5jaG9yLm9mZignLnpmLmRyb3Bkb3duJyk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEcm9wZG93bjtcbiAgfSgpO1xuXG4gIERyb3Bkb3duLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIENsYXNzIHRoYXQgZGVzaWduYXRlcyBib3VuZGluZyBjb250YWluZXIgb2YgRHJvcGRvd24gKGRlZmF1bHQ6IHdpbmRvdylcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHBhcmVudENsYXNzOiBudWxsLFxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IG9wZW5pbmcgYSBzdWJtZW51IG9uIGhvdmVyIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAqL1xuICAgIGhvdmVyRGVsYXk6IDI1MCxcbiAgICAvKipcbiAgICAgKiBBbGxvdyBzdWJtZW51cyB0byBvcGVuIG9uIGhvdmVyIGV2ZW50c1xuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGhvdmVyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBEb24ndCBjbG9zZSBkcm9wZG93biB3aGVuIGhvdmVyaW5nIG92ZXIgZHJvcGRvd24gcGFuZVxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGhvdmVyUGFuZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSBkcm9wZG93biBwYW5lIGFuZCB0aGUgdHJpZ2dlcmluZyBlbGVtZW50IG9uIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHZPZmZzZXQ6IDEsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBiZXR3ZWVuIHRoZSBkcm9wZG93biBwYW5lIGFuZCB0aGUgdHJpZ2dlcmluZyBlbGVtZW50IG9uIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIGhPZmZzZXQ6IDEsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBhZGp1c3Qgb3BlbiBwb3NpdGlvbi4gSlMgd2lsbCB0ZXN0IGFuZCBmaWxsIHRoaXMgaW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJydcbiAgICAgKi9cbiAgICBwb3NpdGlvbkNsYXNzOiAnJyxcbiAgICAvKipcbiAgICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHRyYXAgZm9jdXMgdG8gdGhlIGRyb3Bkb3duIHBhbmUgaWYgb3BlbmVkIHdpdGgga2V5Ym9hcmQgY29tbWFuZHMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgdHJhcEZvY3VzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBBbGxvdyB0aGUgcGx1Z2luIHRvIHNldCBmb2N1cyB0byB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBwYW5lLCByZWdhcmRsZXNzIG9mIG1ldGhvZCBvZiBvcGVuaW5nLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGF1dG9Gb2N1czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkgdG8gY2xvc2UgdGhlIGRyb3Bkb3duLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGNsb3NlT25DbGljazogZmFsc2VcbiAgfTtcblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93biwgJ0Ryb3Bkb3duJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uZHJvcGRvd24uanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * DropdownMenu module.\n   * @module foundation.dropdown-menu\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.box\n   * @requires foundation.util.nest\n   */\n\n  var DropdownMenu = function () {\n    /**\n     * Creates a new instance of DropdownMenu.\n     * @class\n     * @fires DropdownMenu#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function DropdownMenu(element, options) {\n      _classCallCheck(this, DropdownMenu);\n\n      this.$element = element;\n      this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);\n\n      Foundation.Nest.Feather(this.$element, 'dropdown');\n      this._init();\n\n      Foundation.registerPlugin(this, 'DropdownMenu');\n      Foundation.Keyboard.register('DropdownMenu', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'up',\n        'ARROW_DOWN': 'down',\n        'ARROW_LEFT': 'previous',\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the plugin, and calls _prepareMenu\n     * @private\n     * @function\n     */\n\n\n    _createClass(DropdownMenu, [{\n      key: '_init',\n      value: function _init() {\n        var subs = this.$element.find('li.is-dropdown-submenu-parent');\n        this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\n\n        this.$menuItems = this.$element.find('[role=\"menuitem\"]');\n        this.$tabs = this.$element.children('[role=\"menuitem\"]');\n        this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\n\n        if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {\n          this.options.alignment = 'right';\n          subs.addClass('opens-left');\n        } else {\n          subs.addClass('opens-right');\n        }\n        this.changed = false;\n        this._events();\n      }\n    }, {\n      key: '_isVertical',\n      value: function _isVertical() {\n        return this.$tabs.css('display') === 'block';\n      }\n\n      /**\n       * Adds event listeners to elements within the menu\n       * @private\n       * @function\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this,\n            hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\n            parClass = 'is-dropdown-submenu-parent';\n\n        // used for onClick and in the keyboard handlers\n        var handleClickFn = function (e) {\n          var $elem = $(e.target).parentsUntil('ul', '.' + parClass),\n              hasSub = $elem.hasClass(parClass),\n              hasClicked = $elem.attr('data-is-click') === 'true',\n              $sub = $elem.children('.is-dropdown-submenu');\n\n          if (hasSub) {\n            if (hasClicked) {\n              if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\n                return;\n              } else {\n                e.stopImmediatePropagation();\n                e.preventDefault();\n                _this._hide($elem);\n              }\n            } else {\n              e.preventDefault();\n              e.stopImmediatePropagation();\n              _this._show($sub);\n              $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);\n            }\n          }\n        };\n\n        if (this.options.clickOpen || hasTouch) {\n          this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\n        }\n\n        // Handle Leaf element Clicks\n        if (_this.options.closeOnClickInside) {\n          this.$menuItems.on('click.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n            if (!hasSub) {\n              _this._hide();\n            }\n          });\n        }\n\n        if (!this.options.disableHover) {\n          this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n\n            if (hasSub) {\n              clearTimeout($elem.data('_delay'));\n              $elem.data('_delay', setTimeout(function () {\n                _this._show($elem.children('.is-dropdown-submenu'));\n              }, _this.options.hoverDelay));\n            }\n          }).on('mouseleave.zf.dropdownmenu', function (e) {\n            var $elem = $(this),\n                hasSub = $elem.hasClass(parClass);\n            if (hasSub && _this.options.autoclose) {\n              if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\n                return false;\n              }\n\n              clearTimeout($elem.data('_delay'));\n              $elem.data('_delay', setTimeout(function () {\n                _this._hide($elem);\n              }, _this.options.closingTime));\n            }\n          });\n        }\n        this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {\n          var $element = $(e.target).parentsUntil('ul', '[role=\"menuitem\"]'),\n              isTab = _this.$tabs.index($element) > -1,\n              $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\n              $prevElement,\n              $nextElement;\n\n          $elements.each(function (i) {\n            if ($(this).is($element)) {\n              $prevElement = $elements.eq(i - 1);\n              $nextElement = $elements.eq(i + 1);\n              return;\n            }\n          });\n\n          var nextSibling = function () {\n            if (!$element.is(':last-child')) {\n              $nextElement.children('a:first').focus();\n              e.preventDefault();\n            }\n          },\n              prevSibling = function () {\n            $prevElement.children('a:first').focus();\n            e.preventDefault();\n          },\n              openSub = function () {\n            var $sub = $element.children('ul.is-dropdown-submenu');\n            if ($sub.length) {\n              _this._show($sub);\n              $element.find('li > a:first').focus();\n              e.preventDefault();\n            } else {\n              return;\n            }\n          },\n              closeSub = function () {\n            //if ($element.is(':first-child')) {\n            var close = $element.parent('ul').parent('li');\n            close.children('a:first').focus();\n            _this._hide(close);\n            e.preventDefault();\n            //}\n          };\n          var functions = {\n            open: openSub,\n            close: function () {\n              _this._hide(_this.$element);\n              _this.$menuItems.find('a:first').focus(); // focus to first element\n              e.preventDefault();\n            },\n            handled: function () {\n              e.stopImmediatePropagation();\n            }\n          };\n\n          if (isTab) {\n            if (_this._isVertical()) {\n              // vertical menu\n              if (Foundation.rtl()) {\n                // right aligned\n                $.extend(functions, {\n                  down: nextSibling,\n                  up: prevSibling,\n                  next: closeSub,\n                  previous: openSub\n                });\n              } else {\n                // left aligned\n                $.extend(functions, {\n                  down: nextSibling,\n                  up: prevSibling,\n                  next: openSub,\n                  previous: closeSub\n                });\n              }\n            } else {\n              // horizontal menu\n              if (Foundation.rtl()) {\n                // right aligned\n                $.extend(functions, {\n                  next: prevSibling,\n                  previous: nextSibling,\n                  down: openSub,\n                  up: closeSub\n                });\n              } else {\n                // left aligned\n                $.extend(functions, {\n                  next: nextSibling,\n                  previous: prevSibling,\n                  down: openSub,\n                  up: closeSub\n                });\n              }\n            }\n          } else {\n            // not tabs -> one sub\n            if (Foundation.rtl()) {\n              // right aligned\n              $.extend(functions, {\n                next: closeSub,\n                previous: openSub,\n                down: nextSibling,\n                up: prevSibling\n              });\n            } else {\n              // left aligned\n              $.extend(functions, {\n                next: openSub,\n                previous: closeSub,\n                down: nextSibling,\n                up: prevSibling\n              });\n            }\n          }\n          Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);\n        });\n      }\n\n      /**\n       * Adds an event handler to the body to close any dropdowns on a click.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_addBodyHandler',\n      value: function _addBodyHandler() {\n        var $body = $(document.body),\n            _this = this;\n        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {\n          var $link = _this.$element.find(e.target);\n          if ($link.length) {\n            return;\n          }\n\n          _this._hide();\n          $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\n        });\n      }\n\n      /**\n       * Opens a dropdown pane, and checks for collisions first.\n       * @param {jQuery} $sub - ul element that is a submenu to show\n       * @function\n       * @private\n       * @fires DropdownMenu#show\n       */\n\n    }, {\n      key: '_show',\n      value: function _show($sub) {\n        var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\n          return $(el).find($sub).length > 0;\n        }));\n        var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\n        this._hide($sibs, idx);\n        $sub.css('visibility', 'hidden').addClass('js-dropdown-active').parent('li.is-dropdown-submenu-parent').addClass('is-active');\n        var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n        if (!clear) {\n          var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\n              $parentLi = $sub.parent('.is-dropdown-submenu-parent');\n          $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);\n          clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\n          if (!clear) {\n            $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');\n          }\n          this.changed = true;\n        }\n        $sub.css('visibility', '');\n        if (this.options.closeOnClick) {\n          this._addBodyHandler();\n        }\n        /**\n         * Fires when the new dropdown pane is visible.\n         * @event DropdownMenu#show\n         */\n        this.$element.trigger('show.zf.dropdownmenu', [$sub]);\n      }\n\n      /**\n       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\n       * @function\n       * @param {jQuery} $elem - element with a submenu to hide\n       * @param {Number} idx - index of the $tabs collection to hide\n       * @private\n       */\n\n    }, {\n      key: '_hide',\n      value: function _hide($elem, idx) {\n        var $toClose;\n        if ($elem && $elem.length) {\n          $toClose = $elem;\n        } else if (idx !== undefined) {\n          $toClose = this.$tabs.not(function (i, el) {\n            return i === idx;\n          });\n        } else {\n          $toClose = this.$element;\n        }\n        var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\n\n        if (somethingToClose) {\n          $toClose.find('li.is-active').add($toClose).attr({\n            'data-is-click': false\n          }).removeClass('is-active');\n\n          $toClose.find('ul.js-dropdown-active').removeClass('js-dropdown-active');\n\n          if (this.changed || $toClose.find('opens-inner').length) {\n            var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\n            $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);\n            this.changed = false;\n          }\n          /**\n           * Fires when the open menus are closed.\n           * @event DropdownMenu#hide\n           */\n          this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\n        }\n      }\n\n      /**\n       * Destroys the plugin.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\n        $(document.body).off('.zf.dropdownmenu');\n        Foundation.Nest.Burn(this.$element, 'dropdown');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return DropdownMenu;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  DropdownMenu.defaults = {\n    /**\n     * Disallows hover events from opening submenus\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    disableHover: false,\n    /**\n     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    autoclose: true,\n    /**\n     * Amount of time to delay opening a submenu on hover event.\n     * @option\n     * @type {number}\n     * @default 50\n     */\n    hoverDelay: 50,\n    /**\n     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    clickOpen: false,\n    /**\n     * Amount of time to delay closing a submenu on a mouseleave event.\n     * @option\n     * @type {number}\n     * @default 500\n     */\n\n    closingTime: 500,\n    /**\n     * Position of the menu relative to what direction the submenus should open. Handled by JS. Can be `'left'` or `'right'`.\n     * @option\n     * @type {string}\n     * @default 'left'\n     */\n    alignment: 'left',\n    /**\n     * Allow clicks on the body to close any open submenus.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClick: true,\n    /**\n     * Allow clicks on leaf anchor links to close any open submenus.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClickInside: true,\n    /**\n     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\n     * @option\n     * @type {string}\n     * @default 'vertical'\n     */\n    verticalClass: 'vertical',\n    /**\n     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\n     * @option\n     * @type {string}\n     * @default 'align-right'\n     */\n    rightClass: 'align-right',\n    /**\n     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    forceFollow: true\n  };\n\n  // Window exports\n  Foundation.plugin(DropdownMenu, 'DropdownMenu');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5kcm9wZG93bk1lbnUuanM/NDUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd24tbWVudVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICAgKi9cblxuICB2YXIgRHJvcGRvd25NZW51ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd25NZW51LlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEcm9wZG93bk1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duTWVudSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIERyb3Bkb3duTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRHJvcGRvd25NZW51Jyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLCB7XG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxuICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxuICAgICAgICAnQVJST1dfTEVGVCc6ICdwcmV2aW91cycsXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luLCBhbmQgY2FsbHMgX3ByZXBhcmVNZW51XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duTWVudSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Jyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKCdmaXJzdC1zdWInKTtcblxuICAgICAgICB0aGlzLiRtZW51SXRlbXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tyb2xlPVwibWVudWl0ZW1cIl0nKTtcbiAgICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tyb2xlPVwibWVudWl0ZW1cIl0nKTtcbiAgICAgICAgdGhpcy4kdGFicy5maW5kKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpO1xuXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKSB8fCB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnIHx8IEZvdW5kYXRpb24ucnRsKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKCcudG9wLWJhci1yaWdodCcpLmlzKCcqJykpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Vicy5hZGRDbGFzcygnb3BlbnMtcmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2lzVmVydGljYWwnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kdGFicy5jc3MoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIGhhc1RvdWNoID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93IHx8IHR5cGVvZiB3aW5kb3cub250b3VjaHN0YXJ0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgIHBhckNsYXNzID0gJ2lzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JztcblxuICAgICAgICAvLyB1c2VkIGZvciBvbkNsaWNrIGFuZCBpbiB0aGUga2V5Ym9hcmQgaGFuZGxlcnNcbiAgICAgICAgdmFyIGhhbmRsZUNsaWNrRm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciAkZWxlbSA9ICQoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnLicgKyBwYXJDbGFzcyksXG4gICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKSxcbiAgICAgICAgICAgICAgaGFzQ2xpY2tlZCA9ICRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKSA9PT0gJ3RydWUnLFxuICAgICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XG5cbiAgICAgICAgICBpZiAoaGFzU3ViKSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2xpY2tlZCkge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8ICFfdGhpcy5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaGFzVG91Y2ggfHwgX3RoaXMub3B0aW9ucy5mb3JjZUZvbGxvdyAmJiBoYXNUb3VjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJHN1Yik7XG4gICAgICAgICAgICAgICRlbGVtLmFkZCgkZWxlbS5wYXJlbnRzVW50aWwoX3RoaXMuJGVsZW1lbnQsICcuJyArIHBhckNsYXNzKSkuYXR0cignZGF0YS1pcy1jbGljaycsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrT3BlbiB8fCBoYXNUb3VjaCkge1xuICAgICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vbignY2xpY2suemYuZHJvcGRvd25tZW51IHRvdWNoc3RhcnQuemYuZHJvcGRvd25tZW51JywgaGFuZGxlQ2xpY2tGbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgTGVhZiBlbGVtZW50IENsaWNrc1xuICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2tJbnNpZGUpIHtcbiAgICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2NsaWNrLnpmLmRyb3Bkb3dubWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcbiAgICAgICAgICAgIGlmICghaGFzU3ViKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcbiAgICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAoaGFzU3ViKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCgkZWxlbS5kYXRhKCdfZGVsYXknKSk7XG4gICAgICAgICAgICAgICRlbGVtLmRhdGEoJ19kZWxheScsIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICAgaGFzU3ViID0gJGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO1xuICAgICAgICAgICAgaWYgKGhhc1N1YiAmJiBfdGhpcy5vcHRpb25zLmF1dG9jbG9zZSkge1xuICAgICAgICAgICAgICBpZiAoJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScgJiYgX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoJGVsZW0uZGF0YSgnX2RlbGF5JykpO1xuICAgICAgICAgICAgICAkZWxlbS5kYXRhKCdfZGVsYXknLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2xvc2luZ1RpbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2tleWRvd24uemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywgJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSxcbiAgICAgICAgICAgICAgaXNUYWIgPSBfdGhpcy4kdGFicy5pbmRleCgkZWxlbWVudCkgPiAtMSxcbiAgICAgICAgICAgICAgJGVsZW1lbnRzID0gaXNUYWIgPyBfdGhpcy4kdGFicyA6ICRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSAtIDEpO1xuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoaSArIDEpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISRlbGVtZW50LmlzKCc6bGFzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcmV2U2libGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICRwcmV2RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb3BlblN1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkc3ViID0gJGVsZW1lbnQuY2hpbGRyZW4oJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcbiAgICAgICAgICAgIGlmICgkc3ViLmxlbmd0aCkge1xuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkc3ViKTtcbiAgICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnbGkgPiBhOmZpcnN0JykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNsb3NlU3ViID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy9pZiAoJGVsZW1lbnQuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2UgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpO1xuICAgICAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xuICAgICAgICAgICAgX3RoaXMuX2hpZGUoY2xvc2UpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgZnVuY3Rpb25zID0ge1xuICAgICAgICAgICAgb3Blbjogb3BlblN1YixcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtcbiAgICAgICAgICAgICAgX3RoaXMuJG1lbnVJdGVtcy5maW5kKCdhOmZpcnN0JykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoaXNUYWIpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faXNWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgICAgIC8vIHZlcnRpY2FsIG1lbnVcbiAgICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcbiAgICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiBjbG9zZVN1YlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBob3Jpem9udGFsIG1lbnVcbiAgICAgICAgICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkpIHtcbiAgICAgICAgICAgICAgICAvLyByaWdodCBhbGlnbmVkXG4gICAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgICBuZXh0OiBwcmV2U2libGluZyxcbiAgICAgICAgICAgICAgICAgIHByZXZpb3VzOiBuZXh0U2libGluZyxcbiAgICAgICAgICAgICAgICAgIGRvd246IG9wZW5TdWIsXG4gICAgICAgICAgICAgICAgICB1cDogY2xvc2VTdWJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcbiAgICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgIG5leHQ6IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZTaWJsaW5nLFxuICAgICAgICAgICAgICAgICAgZG93bjogb3BlblN1YixcbiAgICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcbiAgICAgICAgICAgIGlmIChGb3VuZGF0aW9uLnJ0bCgpKSB7XG4gICAgICAgICAgICAgIC8vIHJpZ2h0IGFsaWduZWRcbiAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWIsXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXG4gICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXG4gICAgICAgICAgICAgICQuZXh0ZW5kKGZ1bmN0aW9ucywge1xuICAgICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViLFxuICAgICAgICAgICAgICAgIGRvd246IG5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ0Ryb3Bkb3duTWVudScsIGZ1bmN0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZGRCb2R5SGFuZGxlcicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCkge1xuICAgICAgICB2YXIgJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuICAgICAgICAkYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpLm9uKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciAkbGluayA9IF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpO1xuICAgICAgICAgIGlmICgkbGluay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5faGlkZSgpO1xuICAgICAgICAgICRib2R5Lm9mZignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIGEgZHJvcGRvd24gcGFuZSwgYW5kIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBmaXJzdC5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkc3ViIC0gdWwgZWxlbWVudCB0aGF0IGlzIGEgc3VibWVudSB0byBzaG93XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I3Nob3dcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Nob3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KCRzdWIpIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuJHRhYnMuaW5kZXgodGhpcy4kdGFicy5maWx0ZXIoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQoZWwpLmZpbmQoJHN1YikubGVuZ3RoID4gMDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgJHNpYnMgPSAkc3ViLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5zaWJsaW5ncygnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgICAgdGhpcy5faGlkZSgkc2licywgaWR4KTtcbiAgICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJykuYWRkQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpLnBhcmVudCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICAgIHZhciBjbGVhciA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGlmICghY2xlYXIpIHtcbiAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAnLXJpZ2h0JyA6ICctbGVmdCcsXG4gICAgICAgICAgICAgICRwYXJlbnRMaSA9ICRzdWIucGFyZW50KCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTtcbiAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zJyArIG9sZENsYXNzKS5hZGRDbGFzcygnb3BlbnMtJyArIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpO1xuICAgICAgICAgIGNsZWFyID0gRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICBpZiAoIWNsZWFyKSB7XG4gICAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zLScgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcygnb3BlbnMtaW5uZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAkc3ViLmNzcygndmlzaWJpbGl0eScsICcnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I3Nob3dcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bm1lbnUnLCBbJHN1Yl0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGVzIGEgc2luZ2xlLCBjdXJyZW50bHkgb3BlbiBkcm9wZG93biBwYW5lLCBpZiBwYXNzZWQgYSBwYXJhbWV0ZXIsIG90aGVyd2lzZSwgaGlkZXMgZXZlcnl0aGluZy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlICR0YWJzIGNvbGxlY3Rpb24gdG8gaGlkZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hpZGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCRlbGVtLCBpZHgpIHtcbiAgICAgICAgdmFyICR0b0Nsb3NlO1xuICAgICAgICBpZiAoJGVsZW0gJiYgJGVsZW0ubGVuZ3RoKSB7XG4gICAgICAgICAgJHRvQ2xvc2UgPSAkZWxlbTtcbiAgICAgICAgfSBlbHNlIGlmIChpZHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICR0b0Nsb3NlID0gdGhpcy4kdGFicy5ub3QoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gaSA9PT0gaWR4O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICR0b0Nsb3NlID0gdGhpcy4kZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29tZXRoaW5nVG9DbG9zZSA9ICR0b0Nsb3NlLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSB8fCAkdG9DbG9zZS5maW5kKCcuaXMtYWN0aXZlJykubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiAoc29tZXRoaW5nVG9DbG9zZSkge1xuICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWFjdGl2ZScpLmFkZCgkdG9DbG9zZSkuYXR0cih7XG4gICAgICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXG4gICAgICAgICAgfSkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXG4gICAgICAgICAgJHRvQ2xvc2UuZmluZCgndWwuanMtZHJvcGRvd24tYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2pzLWRyb3Bkb3duLWFjdGl2ZScpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2hhbmdlZCB8fCAkdG9DbG9zZS5maW5kKCdvcGVucy1pbm5lcicpLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKS5yZW1vdmVDbGFzcygnb3BlbnMtaW5uZXIgb3BlbnMtJyArIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKCdvcGVucy0nICsgb2xkQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9wZW4gbWVudXMgYXJlIGNsb3NlZC5cbiAgICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I2hpZGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd25tZW51JywgWyR0b0Nsb3NlXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJG1lbnVJdGVtcy5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKS5yZW1vdmVBdHRyKCdkYXRhLWlzLWNsaWNrJykucmVtb3ZlQ2xhc3MoJ2lzLXJpZ2h0LWFycm93IGlzLWxlZnQtYXJyb3cgaXMtZG93bi1hcnJvdyBvcGVucy1yaWdodCBvcGVucy1sZWZ0IG9wZW5zLWlubmVyJyk7XG4gICAgICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKCcuemYuZHJvcGRvd25tZW51Jyk7XG4gICAgICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERyb3Bkb3duTWVudTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovXG5cblxuICBEcm9wZG93bk1lbnUuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudCwgaWYgbm90IGNsaWNrZWQgb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGF1dG9jbG9zZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCA1MFxuICAgICAqL1xuICAgIGhvdmVyRGVsYXk6IDUwLFxuICAgIC8qKlxuICAgICAqIEFsbG93IGEgc3VibWVudSB0byBvcGVuL3JlbWFpbiBvcGVuIG9uIHBhcmVudCBjbGljayBldmVudC4gQWxsb3dzIGN1cnNvciB0byBtb3ZlIGF3YXkgZnJvbSBtZW51LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGNsaWNrT3BlbjogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgY2xvc2luZyBhIHN1Ym1lbnUgb24gYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAqL1xuXG4gICAgY2xvc2luZ1RpbWU6IDUwMCxcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgbWVudSByZWxhdGl2ZSB0byB3aGF0IGRpcmVjdGlvbiB0aGUgc3VibWVudXMgc2hvdWxkIG9wZW4uIEhhbmRsZWQgYnkgSlMuIENhbiBiZSBgJ2xlZnQnYCBvciBgJ3JpZ2h0J2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2xlZnQnXG4gICAgICovXG4gICAgYWxpZ25tZW50OiAnbGVmdCcsXG4gICAgLyoqXG4gICAgICogQWxsb3cgY2xpY2tzIG9uIHRoZSBib2R5IHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEFsbG93IGNsaWNrcyBvbiBsZWFmIGFuY2hvciBsaW5rcyB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGNsb3NlT25DbGlja0luc2lkZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHZlcnRpY2FsIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYHZlcnRpY2FsYC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqL1xuICAgIHZlcnRpY2FsQ2xhc3M6ICd2ZXJ0aWNhbCcsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byByaWdodC1zaWRlIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYGFsaWduLXJpZ2h0YC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ2FsaWduLXJpZ2h0J1xuICAgICAqL1xuICAgIHJpZ2h0Q2xhc3M6ICdhbGlnbi1yaWdodCcsXG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0byBmb3JjZSBvdmVyaWRlIHRoZSBjbGlja2luZyBvZiBsaW5rcyB0byBwZXJmb3JtIGRlZmF1bHQgYWN0aW9uLCBvbiBzZWNvbmQgdG91Y2ggZXZlbnQgZm9yIG1vYmlsZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGZvcmNlRm9sbG93OiB0cnVlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oRHJvcGRvd25NZW51LCAnRHJvcGRvd25NZW51Jyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uZHJvcGRvd25NZW51LmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Equalizer module.\n   * @module foundation.equalizer\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.timerAndImageLoader if equalizer contains images\n   */\n\n  var Equalizer = function () {\n    /**\n     * Creates a new instance of Equalizer.\n     * @class\n     * @fires Equalizer#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Equalizer(element, options) {\n      _classCallCheck(this, Equalizer);\n\n      this.$element = element;\n      this.options = $.extend({}, Equalizer.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Equalizer');\n    }\n\n    /**\n     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.\n     * @private\n     */\n\n\n    _createClass(Equalizer, [{\n      key: '_init',\n      value: function _init() {\n        var eqId = this.$element.attr('data-equalizer') || '';\n        var $watched = this.$element.find('[data-equalizer-watch=\"' + eqId + '\"]');\n\n        this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');\n        this.$element.attr('data-resize', eqId || Foundation.GetYoDigits(6, 'eq'));\n        this.$element.attr('data-mutate', eqId || Foundation.GetYoDigits(6, 'eq'));\n\n        this.hasNested = this.$element.find('[data-equalizer]').length > 0;\n        this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;\n        this.isOn = false;\n        this._bindHandler = {\n          onResizeMeBound: this._onResizeMe.bind(this),\n          onPostEqualizedBound: this._onPostEqualized.bind(this)\n        };\n\n        var imgs = this.$element.find('img');\n        var tooSmall;\n        if (this.options.equalizeOn) {\n          tooSmall = this._checkMQ();\n          $(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));\n        } else {\n          this._events();\n        }\n        if (tooSmall !== undefined && tooSmall === false || tooSmall === undefined) {\n          if (imgs.length) {\n            Foundation.onImagesLoaded(imgs, this._reflow.bind(this));\n          } else {\n            this._reflow();\n          }\n        }\n      }\n\n      /**\n       * Removes event listeners if the breakpoint is too small.\n       * @private\n       */\n\n    }, {\n      key: '_pauseEvents',\n      value: function _pauseEvents() {\n        this.isOn = false;\n        this.$element.off({\n          '.zf.equalizer': this._bindHandler.onPostEqualizedBound,\n          'resizeme.zf.trigger': this._bindHandler.onResizeMeBound,\n          'mutateme.zf.trigger': this._bindHandler.onResizeMeBound\n        });\n      }\n\n      /**\n       * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound\n       * @private\n       */\n\n    }, {\n      key: '_onResizeMe',\n      value: function _onResizeMe(e) {\n        this._reflow();\n      }\n\n      /**\n       * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound\n       * @private\n       */\n\n    }, {\n      key: '_onPostEqualized',\n      value: function _onPostEqualized(e) {\n        if (e.target !== this.$element[0]) {\n          this._reflow();\n        }\n      }\n\n      /**\n       * Initializes events for Equalizer.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n        this._pauseEvents();\n        if (this.hasNested) {\n          this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);\n        } else {\n          this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);\n          this.$element.on('mutateme.zf.trigger', this._bindHandler.onResizeMeBound);\n        }\n        this.isOn = true;\n      }\n\n      /**\n       * Checks the current breakpoint to the minimum required size.\n       * @private\n       */\n\n    }, {\n      key: '_checkMQ',\n      value: function _checkMQ() {\n        var tooSmall = !Foundation.MediaQuery.is(this.options.equalizeOn);\n        if (tooSmall) {\n          if (this.isOn) {\n            this._pauseEvents();\n            this.$watched.css('height', 'auto');\n          }\n        } else {\n          if (!this.isOn) {\n            this._events();\n          }\n        }\n        return tooSmall;\n      }\n\n      /**\n       * A noop version for the plugin\n       * @private\n       */\n\n    }, {\n      key: '_killswitch',\n      value: function _killswitch() {\n        return;\n      }\n\n      /**\n       * Calls necessary functions to update Equalizer upon DOM change\n       * @private\n       */\n\n    }, {\n      key: '_reflow',\n      value: function _reflow() {\n        if (!this.options.equalizeOnStack) {\n          if (this._isStacked()) {\n            this.$watched.css('height', 'auto');\n            return false;\n          }\n        }\n        if (this.options.equalizeByRow) {\n          this.getHeightsByRow(this.applyHeightByRow.bind(this));\n        } else {\n          this.getHeights(this.applyHeight.bind(this));\n        }\n      }\n\n      /**\n       * Manually determines if the first 2 elements are *NOT* stacked.\n       * @private\n       */\n\n    }, {\n      key: '_isStacked',\n      value: function _isStacked() {\n        if (!this.$watched[0] || !this.$watched[1]) {\n          return true;\n        }\n        return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\n      }\n\n      /**\n       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\n       * @param {Function} cb - A non-optional callback to return the heights array to.\n       * @returns {Array} heights - An array of heights of children within Equalizer container\n       */\n\n    }, {\n      key: 'getHeights',\n      value: function getHeights(cb) {\n        var heights = [];\n        for (var i = 0, len = this.$watched.length; i < len; i++) {\n          this.$watched[i].style.height = 'auto';\n          heights.push(this.$watched[i].offsetHeight);\n        }\n        cb(heights);\n      }\n\n      /**\n       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\n       * @param {Function} cb - A non-optional callback to return the heights array to.\n       * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\n       */\n\n    }, {\n      key: 'getHeightsByRow',\n      value: function getHeightsByRow(cb) {\n        var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,\n            groups = [],\n            group = 0;\n        //group by Row\n        groups[group] = [];\n        for (var i = 0, len = this.$watched.length; i < len; i++) {\n          this.$watched[i].style.height = 'auto';\n          //maybe could use this.$watched[i].offsetTop\n          var elOffsetTop = $(this.$watched[i]).offset().top;\n          if (elOffsetTop != lastElTopOffset) {\n            group++;\n            groups[group] = [];\n            lastElTopOffset = elOffsetTop;\n          }\n          groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);\n        }\n\n        for (var j = 0, ln = groups.length; j < ln; j++) {\n          var heights = $(groups[j]).map(function () {\n            return this[1];\n          }).get();\n          var max = Math.max.apply(null, heights);\n          groups[j].push(max);\n        }\n        cb(groups);\n      }\n\n      /**\n       * Changes the CSS height property of each child in an Equalizer parent to match the tallest\n       * @param {array} heights - An array of heights of children within Equalizer container\n       * @fires Equalizer#preequalized\n       * @fires Equalizer#postequalized\n       */\n\n    }, {\n      key: 'applyHeight',\n      value: function applyHeight(heights) {\n        var max = Math.max.apply(null, heights);\n        /**\n         * Fires before the heights are applied\n         * @event Equalizer#preequalized\n         */\n        this.$element.trigger('preequalized.zf.equalizer');\n\n        this.$watched.css('height', max);\n\n        /**\n         * Fires when the heights have been applied\n         * @event Equalizer#postequalized\n         */\n        this.$element.trigger('postequalized.zf.equalizer');\n      }\n\n      /**\n       * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row\n       * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\n       * @fires Equalizer#preequalized\n       * @fires Equalizer#preequalizedrow\n       * @fires Equalizer#postequalizedrow\n       * @fires Equalizer#postequalized\n       */\n\n    }, {\n      key: 'applyHeightByRow',\n      value: function applyHeightByRow(groups) {\n        /**\n         * Fires before the heights are applied\n         */\n        this.$element.trigger('preequalized.zf.equalizer');\n        for (var i = 0, len = groups.length; i < len; i++) {\n          var groupsILength = groups[i].length,\n              max = groups[i][groupsILength - 1];\n          if (groupsILength <= 2) {\n            $(groups[i][0][0]).css({ 'height': 'auto' });\n            continue;\n          }\n          /**\n            * Fires before the heights per row are applied\n            * @event Equalizer#preequalizedrow\n            */\n          this.$element.trigger('preequalizedrow.zf.equalizer');\n          for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {\n            $(groups[i][j][0]).css({ 'height': max });\n          }\n          /**\n            * Fires when the heights per row have been applied\n            * @event Equalizer#postequalizedrow\n            */\n          this.$element.trigger('postequalizedrow.zf.equalizer');\n        }\n        /**\n         * Fires when the heights have been applied\n         */\n        this.$element.trigger('postequalized.zf.equalizer');\n      }\n\n      /**\n       * Destroys an instance of Equalizer.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._pauseEvents();\n        this.$watched.css('height', 'auto');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Equalizer;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  Equalizer.defaults = {\n    /**\n     * Enable height equalization when stacked on smaller screens.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    equalizeOnStack: false,\n    /**\n     * Enable height equalization row by row.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    equalizeByRow: false,\n    /**\n     * String representing the minimum breakpoint size the plugin should equalize heights on.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    equalizeOn: ''\n  };\n\n  // Window exports\n  Foundation.plugin(Equalizer, 'Equalizer');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5lcXVhbGl6ZXIuanM/YTJiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBFcXVhbGl6ZXIgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZXF1YWxpemVyXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXIgaWYgZXF1YWxpemVyIGNvbnRhaW5zIGltYWdlc1xuICAgKi9cblxuICB2YXIgRXF1YWxpemVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRXF1YWxpemVyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVxdWFsaXplcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXF1YWxpemVyKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRXF1YWxpemVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRXF1YWxpemVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEVxdWFsaXplciwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdmFyIGVxSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtZXF1YWxpemVyJykgfHwgJyc7XG4gICAgICAgIHZhciAkd2F0Y2hlZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoPVwiJyArIGVxSWQgKyAnXCJdJyk7XG5cbiAgICAgICAgdGhpcy4kd2F0Y2hlZCA9ICR3YXRjaGVkLmxlbmd0aCA/ICR3YXRjaGVkIDogdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignZGF0YS1yZXNpemUnLCBlcUlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2VxJykpO1xuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJywgZXFJZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdlcScpKTtcblxuICAgICAgICB0aGlzLmhhc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LCAnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XG4gICAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9iaW5kSGFuZGxlciA9IHtcbiAgICAgICAgICBvblJlc2l6ZU1lQm91bmQ6IHRoaXMuX29uUmVzaXplTWUuYmluZCh0aGlzKSxcbiAgICAgICAgICBvblBvc3RFcXVhbGl6ZWRCb3VuZDogdGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgaW1ncyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7XG4gICAgICAgIHZhciB0b29TbWFsbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKSB7XG4gICAgICAgICAgdG9vU21hbGwgPSB0aGlzLl9jaGVja01RKCk7XG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGVja01RLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b29TbWFsbCAhPT0gdW5kZWZpbmVkICYmIHRvb1NtYWxsID09PSBmYWxzZSB8fCB0b29TbWFsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGltZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMgaWYgdGhlIGJyZWFrcG9pbnQgaXMgdG9vIHNtYWxsLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3BhdXNlRXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF1c2VFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZih7XG4gICAgICAgICAgJy56Zi5lcXVhbGl6ZXInOiB0aGlzLl9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZCxcbiAgICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCxcbiAgICAgICAgICAnbXV0YXRlbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25SZXNpemVNZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVzaXplTWUoZSkge1xuICAgICAgICB0aGlzLl9yZWZsb3coKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyLCB3aXRoIGJvdW5kIHRoaXMgb24gX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfb25Qb3N0RXF1YWxpemVkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qb3N0RXF1YWxpemVkKGUpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSB0aGlzLiRlbGVtZW50WzBdKSB7XG4gICAgICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEVxdWFsaXplci5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc05lc3RlZCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJywgdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ211dGF0ZW1lLnpmLnRyaWdnZXInLCB0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNPbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgdG8gdGhlIG1pbmltdW0gcmVxdWlyZWQgc2l6ZS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19jaGVja01RJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNUSgpIHtcbiAgICAgICAgdmFyIHRvb1NtYWxsID0gIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5pcyh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbik7XG4gICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzT24pIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdXNlRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzT24pIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vU21hbGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQSBub29wIHZlcnNpb24gZm9yIHRoZSBwbHVnaW5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19raWxsc3dpdGNoJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfa2lsbHN3aXRjaCgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEVxdWFsaXplciB1cG9uIERPTSBjaGFuZ2VcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZWZsb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjaykge1xuICAgICAgICAgIGlmICh0aGlzLl9pc1N0YWNrZWQoKSkge1xuICAgICAgICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdykge1xuICAgICAgICAgIHRoaXMuZ2V0SGVpZ2h0c0J5Um93KHRoaXMuYXBwbHlIZWlnaHRCeVJvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE1hbnVhbGx5IGRldGVybWluZXMgaWYgdGhlIGZpcnN0IDIgZWxlbWVudHMgYXJlICpOT1QqIHN0YWNrZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaXNTdGFja2VkJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNTdGFja2VkKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHdhdGNoZWRbMF0gfHwgIXRoaXMuJHdhdGNoZWRbMV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kd2F0Y2hlZFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRoaXMuJHdhdGNoZWRbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZ2V0SGVpZ2h0cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0cyhjYikge1xuICAgICAgICB2YXIgaGVpZ2h0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHRoaXMuJHdhdGNoZWRbaV0uc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgIGhlaWdodHMucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoaGVpZ2h0cyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRmluZHMgdGhlIG91dGVyIGhlaWdodHMgb2YgY2hpbGRyZW4gY29udGFpbmVkIHdpdGhpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IGFuZCByZXR1cm5zIHRoZW0gaW4gYW4gYXJyYXlcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBub24tb3B0aW9uYWwgY2FsbGJhY2sgdG8gcmV0dXJuIHRoZSBoZWlnaHRzIGFycmF5IHRvLlxuICAgICAgICogQHJldHVybnMge0FycmF5fSBncm91cHMgLSBBbiBhcnJheSBvZiBoZWlnaHRzIG9mIGNoaWxkcmVuIHdpdGhpbiBFcXVhbGl6ZXIgY29udGFpbmVyIGdyb3VwZWQgYnkgcm93IHdpdGggZWxlbWVudCxoZWlnaHQgYW5kIG1heCBhcyBsYXN0IGNoaWxkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dldEhlaWdodHNCeVJvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0c0J5Um93KGNiKSB7XG4gICAgICAgIHZhciBsYXN0RWxUb3BPZmZzZXQgPSB0aGlzLiR3YXRjaGVkLmxlbmd0aCA/IHRoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3AgOiAwLFxuICAgICAgICAgICAgZ3JvdXBzID0gW10sXG4gICAgICAgICAgICBncm91cCA9IDA7XG4gICAgICAgIC8vZ3JvdXAgYnkgUm93XG4gICAgICAgIGdyb3Vwc1tncm91cF0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAvL21heWJlIGNvdWxkIHVzZSB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldFRvcFxuICAgICAgICAgIHZhciBlbE9mZnNldFRvcCA9ICQodGhpcy4kd2F0Y2hlZFtpXSkub2Zmc2V0KCkudG9wO1xuICAgICAgICAgIGlmIChlbE9mZnNldFRvcCAhPSBsYXN0RWxUb3BPZmZzZXQpIHtcbiAgICAgICAgICAgIGdyb3VwKys7XG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgICBsYXN0RWxUb3BPZmZzZXQgPSBlbE9mZnNldFRvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKFt0aGlzLiR3YXRjaGVkW2ldLCB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcbiAgICAgICAgICB2YXIgaGVpZ2h0cyA9ICQoZ3JvdXBzW2pdKS5tYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMV07XG4gICAgICAgICAgfSkuZ2V0KCk7XG4gICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuICAgICAgICAgIGdyb3Vwc1tqXS5wdXNoKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgY2IoZ3JvdXBzKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdFxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYXBwbHlIZWlnaHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5SGVpZ2h0KGhlaWdodHMpIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGhlaWdodHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3ByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcblxuICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgbWF4KTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdCBieSByb3dcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZHJvd1xuICAgICAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0ZXF1YWxpemVkcm93XG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnYXBwbHlIZWlnaHRCeVJvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlIZWlnaHRCeVJvdyhncm91cHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBhcmUgYXBwbGllZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgZ3JvdXBzSUxlbmd0aCA9IGdyb3Vwc1tpXS5sZW5ndGgsXG4gICAgICAgICAgICAgIG1heCA9IGdyb3Vwc1tpXVtncm91cHNJTGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGdyb3Vwc0lMZW5ndGggPD0gMikge1xuICAgICAgICAgICAgJChncm91cHNbaV1bMF1bMF0pLmNzcyh7ICdoZWlnaHQnOiAnYXV0bycgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXG4gICAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkcm93XG4gICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW5KID0gZ3JvdXBzSUxlbmd0aCAtIDE7IGogPCBsZW5KOyBqKyspIHtcbiAgICAgICAgICAgICQoZ3JvdXBzW2ldW2pdWzBdKS5jc3MoeyAnaGVpZ2h0JzogbWF4IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBwZXIgcm93IGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZHJvd1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcbiAgICAgICAgdGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsICdhdXRvJyk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFcXVhbGl6ZXI7XG4gIH0oKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gICAqL1xuXG5cbiAgRXF1YWxpemVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHdoZW4gc3RhY2tlZCBvbiBzbWFsbGVyIHNjcmVlbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZXF1YWxpemVPblN0YWNrOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiByb3cgYnkgcm93LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGVxdWFsaXplQnlSb3c6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1pbmltdW0gYnJlYWtwb2ludCBzaXplIHRoZSBwbHVnaW4gc2hvdWxkIGVxdWFsaXplIGhlaWdodHMgb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJydcbiAgICAgKi9cbiAgICBlcXVhbGl6ZU9uOiAnJ1xuICB9O1xuXG4gIC8vIFdpbmRvdyBleHBvcnRzXG4gIEZvdW5kYXRpb24ucGx1Z2luKEVxdWFsaXplciwgJ0VxdWFsaXplcicpO1xufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLmVxdWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Interchange module.\n   * @module foundation.interchange\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.timerAndImageLoader\n   */\n\n  var Interchange = function () {\n    /**\n     * Creates a new instance of Interchange.\n     * @class\n     * @fires Interchange#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Interchange(element, options) {\n      _classCallCheck(this, Interchange);\n\n      this.$element = element;\n      this.options = $.extend({}, Interchange.defaults, options);\n      this.rules = [];\n      this.currentPath = '';\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'Interchange');\n    }\n\n    /**\n     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.\n     * @function\n     * @private\n     */\n\n\n    _createClass(Interchange, [{\n      key: '_init',\n      value: function _init() {\n        this._addBreakpoints();\n        this._generateRules();\n        this._reflow();\n      }\n\n      /**\n       * Initializes events for Interchange.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this2 = this;\n\n        $(window).on('resize.zf.interchange', Foundation.util.throttle(function () {\n          _this2._reflow();\n        }, 50));\n      }\n\n      /**\n       * Calls necessary functions to update Interchange upon DOM change\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_reflow',\n      value: function _reflow() {\n        var match;\n\n        // Iterate through each rule, but only save the last match\n        for (var i in this.rules) {\n          if (this.rules.hasOwnProperty(i)) {\n            var rule = this.rules[i];\n            if (window.matchMedia(rule.query).matches) {\n              match = rule;\n            }\n          }\n        }\n\n        if (match) {\n          this.replace(match.path);\n        }\n      }\n\n      /**\n       * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_addBreakpoints',\n      value: function _addBreakpoints() {\n        for (var i in Foundation.MediaQuery.queries) {\n          if (Foundation.MediaQuery.queries.hasOwnProperty(i)) {\n            var query = Foundation.MediaQuery.queries[i];\n            Interchange.SPECIAL_QUERIES[query.name] = query.value;\n          }\n        }\n      }\n\n      /**\n       * Checks the Interchange element for the provided media query + content pairings\n       * @function\n       * @private\n       * @param {Object} element - jQuery object that is an Interchange instance\n       * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys\n       */\n\n    }, {\n      key: '_generateRules',\n      value: function _generateRules(element) {\n        var rulesList = [];\n        var rules;\n\n        if (this.options.rules) {\n          rules = this.options.rules;\n        } else {\n          rules = this.$element.data('interchange');\n        }\n\n        rules = typeof rules === 'string' ? rules.match(/\\[.*?\\]/g) : rules;\n\n        for (var i in rules) {\n          if (rules.hasOwnProperty(i)) {\n            var rule = rules[i].slice(1, -1).split(', ');\n            var path = rule.slice(0, -1).join('');\n            var query = rule[rule.length - 1];\n\n            if (Interchange.SPECIAL_QUERIES[query]) {\n              query = Interchange.SPECIAL_QUERIES[query];\n            }\n\n            rulesList.push({\n              path: path,\n              query: query\n            });\n          }\n        }\n\n        this.rules = rulesList;\n      }\n\n      /**\n       * Update the `src` property of an image, or change the HTML of a container, to the specified path.\n       * @function\n       * @param {String} path - Path to the image or HTML partial.\n       * @fires Interchange#replaced\n       */\n\n    }, {\n      key: 'replace',\n      value: function replace(path) {\n        if (this.currentPath === path) return;\n\n        var _this = this,\n            trigger = 'replaced.zf.interchange';\n\n        // Replacing images\n        if (this.$element[0].nodeName === 'IMG') {\n          this.$element.attr('src', path).on('load', function () {\n            _this.currentPath = path;\n          }).trigger(trigger);\n        }\n        // Replacing background images\n        else if (path.match(/\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {\n            this.$element.css({ 'background-image': 'url(' + path + ')' }).trigger(trigger);\n          }\n          // Replacing HTML\n          else {\n              $.get(path, function (response) {\n                _this.$element.html(response).trigger(trigger);\n                $(response).foundation();\n                _this.currentPath = path;\n              });\n            }\n\n        /**\n         * Fires when content in an Interchange element is done being loaded.\n         * @event Interchange#replaced\n         */\n        // this.$element.trigger('replaced.zf.interchange');\n      }\n\n      /**\n       * Destroys an instance of interchange.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        //TODO this.\n      }\n    }]);\n\n    return Interchange;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  Interchange.defaults = {\n    /**\n     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.\n     * @option\n     * @type {?array}\n     * @default null\n     */\n    rules: null\n  };\n\n  Interchange.SPECIAL_QUERIES = {\n    'landscape': 'screen and (orientation: landscape)',\n    'portrait': 'screen and (orientation: portrait)',\n    'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'\n  };\n\n  // Window exports\n  Foundation.plugin(Interchange, 'Interchange');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5pbnRlcmNoYW5nZS5qcz9jNThhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIEludGVyY2hhbmdlIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLmludGVyY2hhbmdlXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXJcbiAgICovXG5cbiAgdmFyIEludGVyY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSW50ZXJjaGFuZ2UuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIEludGVyY2hhbmdlI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbnRlcmNoYW5nZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJjaGFuZ2UpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBJbnRlcmNoYW5nZS5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gJyc7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdJbnRlcmNoYW5nZScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBJbnRlcmNoYW5nZSBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgaW50ZXJjaGFuZ2UgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoSW50ZXJjaGFuZ2UsIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHRoaXMuX2FkZEJyZWFrcG9pbnRzKCk7XG4gICAgICAgIHRoaXMuX2dlbmVyYXRlUnVsZXMoKTtcbiAgICAgICAgdGhpcy5fcmVmbG93KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBJbnRlcmNoYW5nZS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuemYuaW50ZXJjaGFuZ2UnLCBGb3VuZGF0aW9uLnV0aWwudGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fcmVmbG93KCk7XG4gICAgICAgIH0sIDUwKSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgSW50ZXJjaGFuZ2UgdXBvbiBET00gY2hhbmdlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZWZsb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlLCBidXQgb25seSBzYXZlIHRoZSBsYXN0IG1hdGNoXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ydWxlcykge1xuICAgICAgICAgIGlmICh0aGlzLnJ1bGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XG4gICAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocnVsZS5xdWVyeSkubWF0Y2hlcykge1xuICAgICAgICAgICAgICBtYXRjaCA9IHJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgdGhpcy5yZXBsYWNlKG1hdGNoLnBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRkQnJlYWtwb2ludHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCcmVha3BvaW50cygpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcykge1xuICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXNbaV07XG4gICAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHNjZW5hcmlvcyAtIEFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlICdtcScgYW5kICdwYXRoJyBrZXlzIHdpdGggY29ycmVzcG9uZGluZyBrZXlzXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZW5lcmF0ZVJ1bGVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVSdWxlcyhlbGVtZW50KSB7XG4gICAgICAgIHZhciBydWxlc0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIHJ1bGVzO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucnVsZXMpIHtcbiAgICAgICAgICBydWxlcyA9IHRoaXMub3B0aW9ucy5ydWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgnaW50ZXJjaGFuZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bGVzID0gdHlwZW9mIHJ1bGVzID09PSAnc3RyaW5nJyA/IHJ1bGVzLm1hdGNoKC9cXFsuKj9cXF0vZykgOiBydWxlcztcblxuICAgICAgICBmb3IgKHZhciBpIGluIHJ1bGVzKSB7XG4gICAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldLnNsaWNlKDEsIC0xKS5zcGxpdCgnLCAnKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcnVsZS5zbGljZSgwLCAtMSkuam9pbignJyk7XG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBydWxlW3J1bGUubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGlmIChJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKSB7XG4gICAgICAgICAgICAgIHF1ZXJ5ID0gSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTW3F1ZXJ5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVsZXNMaXN0LnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucnVsZXMgPSBydWxlc0xpc3Q7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gUGF0aCB0byB0aGUgaW1hZ2Ugb3IgSFRNTCBwYXJ0aWFsLlxuICAgICAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlcGxhY2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICB0cmlnZ2VyID0gJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJztcblxuICAgICAgICAvLyBSZXBsYWNpbmcgaW1hZ2VzXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lID09PSAnSU1HJykge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignc3JjJywgcGF0aCkub24oJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgICAgfSkudHJpZ2dlcih0cmlnZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNpbmcgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgICAgZWxzZSBpZiAocGF0aC5tYXRjaCgvXFwuKGdpZnxqcGd8anBlZ3xwbmd8c3ZnfHRpZmYpKFs/I10uKik/L2kpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgcGF0aCArICcpJyB9KS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXBsYWNpbmcgSFRNTFxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAkLmdldChwYXRoLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5odG1sKHJlc3BvbnNlKS50cmlnZ2VyKHRyaWdnZXIpO1xuICAgICAgICAgICAgICAgICQocmVzcG9uc2UpLmZvdW5kYXRpb24oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIGNvbnRlbnQgaW4gYW4gSW50ZXJjaGFuZ2UgZWxlbWVudCBpcyBkb25lIGJlaW5nIGxvYWRlZC5cbiAgICAgICAgICogQGV2ZW50IEludGVyY2hhbmdlI3JlcGxhY2VkXG4gICAgICAgICAqL1xuICAgICAgICAvLyB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgaW50ZXJjaGFuZ2UuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgLy9UT0RPIHRoaXMuXG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEludGVyY2hhbmdlO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICAgKi9cblxuXG4gIEludGVyY2hhbmdlLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHs/YXJyYXl9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuICAgIHJ1bGVzOiBudWxsXG4gIH07XG5cbiAgSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTID0ge1xuICAgICdsYW5kc2NhcGUnOiAnc2NyZWVuIGFuZCAob3JpZW50YXRpb246IGxhbmRzY2FwZSknLFxuICAgICdwb3J0cmFpdCc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcbiAgICAncmV0aW5hJzogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcbiAgfTtcblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihJbnRlcmNoYW5nZSwgJ0ludGVyY2hhbmdlJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 9 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Magellan module.\n   * @module foundation.magellan\n   */\n\n  var Magellan = function () {\n    /**\n     * Creates a new instance of Magellan.\n     * @class\n     * @fires Magellan#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Magellan(element, options) {\n      _classCallCheck(this, Magellan);\n\n      this.$element = element;\n      this.options = $.extend({}, Magellan.defaults, this.$element.data(), options);\n\n      this._init();\n      this.calcPoints();\n\n      Foundation.registerPlugin(this, 'Magellan');\n    }\n\n    /**\n     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.\n     * @private\n     */\n\n\n    _createClass(Magellan, [{\n      key: '_init',\n      value: function _init() {\n        var id = this.$element[0].id || Foundation.GetYoDigits(6, 'magellan');\n        var _this = this;\n        this.$targets = $('[data-magellan-target]');\n        this.$links = this.$element.find('a');\n        this.$element.attr({\n          'data-resize': id,\n          'data-scroll': id,\n          'id': id\n        });\n        this.$active = $();\n        this.scrollPos = parseInt(window.pageYOffset, 10);\n\n        this._events();\n      }\n\n      /**\n       * Calculates an array of pixel values that are the demarcation lines between locations on the page.\n       * Can be invoked if new elements are added or the size of a location changes.\n       * @function\n       */\n\n    }, {\n      key: 'calcPoints',\n      value: function calcPoints() {\n        var _this = this,\n            body = document.body,\n            html = document.documentElement;\n\n        this.points = [];\n        this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));\n        this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));\n\n        this.$targets.each(function () {\n          var $tar = $(this),\n              pt = Math.round($tar.offset().top - _this.options.threshold);\n          $tar.targetPoint = pt;\n          _this.points.push(pt);\n        });\n      }\n\n      /**\n       * Initializes events for Magellan.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this,\n            $body = $('html, body'),\n            opts = {\n          duration: _this.options.animationDuration,\n          easing: _this.options.animationEasing\n        };\n        $(window).one('load', function () {\n          if (_this.options.deepLinking) {\n            if (location.hash) {\n              _this.scrollToLoc(location.hash);\n            }\n          }\n          _this.calcPoints();\n          _this._updateActive();\n        });\n\n        this.$element.on({\n          'resizeme.zf.trigger': this.reflow.bind(this),\n          'scrollme.zf.trigger': this._updateActive.bind(this)\n        }).on('click.zf.magellan', 'a[href^=\"#\"]', function (e) {\n          e.preventDefault();\n          var arrival = this.getAttribute('href');\n          _this.scrollToLoc(arrival);\n        });\n        $(window).on('popstate', function (e) {\n          if (_this.options.deepLinking) {\n            _this.scrollToLoc(window.location.hash);\n          }\n        });\n      }\n\n      /**\n       * Function to scroll to a given location on the page.\n       * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'\n       * @function\n       */\n\n    }, {\n      key: 'scrollToLoc',\n      value: function scrollToLoc(loc) {\n        // Do nothing if target does not exist to prevent errors\n        if (!$(loc).length) {\n          return false;\n        }\n        this._inTransition = true;\n        var _this = this,\n            scrollPos = Math.round($(loc).offset().top - this.options.threshold / 2 - this.options.barOffset);\n\n        $('html, body').stop(true).animate({ scrollTop: scrollPos }, this.options.animationDuration, this.options.animationEasing, function () {\n          _this._inTransition = false;_this._updateActive();\n        });\n      }\n\n      /**\n       * Calls necessary functions to update Magellan upon DOM change\n       * @function\n       */\n\n    }, {\n      key: 'reflow',\n      value: function reflow() {\n        this.calcPoints();\n        this._updateActive();\n      }\n\n      /**\n       * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.\n       * @private\n       * @function\n       * @fires Magellan#update\n       */\n\n    }, {\n      key: '_updateActive',\n      value: function _updateActive() /*evt, elem, scrollPos*/{\n        if (this._inTransition) {\n          return;\n        }\n        var winPos = /*scrollPos ||*/parseInt(window.pageYOffset, 10),\n            curIdx;\n\n        if (winPos + this.winHeight === this.docHeight) {\n          curIdx = this.points.length - 1;\n        } else if (winPos < this.points[0]) {\n          curIdx = undefined;\n        } else {\n          var isDown = this.scrollPos < winPos,\n              _this = this,\n              curVisible = this.points.filter(function (p, i) {\n            return isDown ? p - _this.options.barOffset <= winPos : p - _this.options.barOffset - _this.options.threshold <= winPos;\n          });\n          curIdx = curVisible.length ? curVisible.length - 1 : 0;\n        }\n\n        this.$active.removeClass(this.options.activeClass);\n        this.$active = this.$links.filter('[href=\"#' + this.$targets.eq(curIdx).data('magellan-target') + '\"]').addClass(this.options.activeClass);\n\n        if (this.options.deepLinking) {\n          var hash = \"\";\n          if (curIdx != undefined) {\n            hash = this.$active[0].getAttribute('href');\n          }\n          if (hash !== window.location.hash) {\n            if (window.history.pushState) {\n              window.history.pushState(null, null, hash);\n            } else {\n              window.location.hash = hash;\n            }\n          }\n        }\n\n        this.scrollPos = winPos;\n        /**\n         * Fires when magellan is finished updating to the new active element.\n         * @event Magellan#update\n         */\n        this.$element.trigger('update.zf.magellan', [this.$active]);\n      }\n\n      /**\n       * Destroys an instance of Magellan and resets the url of the window.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.off('.zf.trigger .zf.magellan').find('.' + this.options.activeClass).removeClass(this.options.activeClass);\n\n        if (this.options.deepLinking) {\n          var hash = this.$active[0].getAttribute('href');\n          window.location.hash.replace(hash, '');\n        }\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Magellan;\n  }();\n\n  /**\n   * Default settings for plugin\n   */\n\n\n  Magellan.defaults = {\n    /**\n     * Amount of time, in ms, the animated scrolling should take between locations.\n     * @option\n     * @type {number}\n     * @default 500\n     */\n    animationDuration: 500,\n    /**\n     * Animation style to use when scrolling between locations. Can be `'swing'` or `'linear'`.\n     * @option\n     * @type {string}\n     * @default 'linear'\n     * @see {@link https://api.jquery.com/animate|Jquery animate}\n     */\n    animationEasing: 'linear',\n    /**\n     * Number of pixels to use as a marker for location changes.\n     * @option\n     * @type {number}\n     * @default 50\n     */\n    threshold: 50,\n    /**\n     * Class applied to the active locations link on the magellan container.\n     * @option\n     * @type {string}\n     * @default 'active'\n     */\n    activeClass: 'active',\n    /**\n     * Allows the script to manipulate the url of the current page, and if supported, alter the history.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    deepLinking: false,\n    /**\n     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    barOffset: 0\n  };\n\n  // Window exports\n  Foundation.plugin(Magellan, 'Magellan');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5tYWdlbGxhbi5qcz9mNDEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIE1hZ2VsbGFuIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLm1hZ2VsbGFuXG4gICAqL1xuXG4gIHZhciBNYWdlbGxhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIE1hZ2VsbGFuLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFnZWxsYW4oZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hZ2VsbGFuKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTWFnZWxsYW4uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ01hZ2VsbGFuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hZ2VsbGFuIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoTWFnZWxsYW4sIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnbWFnZWxsYW4nKTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy4kdGFyZ2V0cyA9ICQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTtcbiAgICAgICAgdGhpcy4kbGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2EnKTtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgICAnZGF0YS1zY3JvbGwnOiBpZCxcbiAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy4kYWN0aXZlID0gJCgpO1xuICAgICAgICB0aGlzLnNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApO1xuXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZXMgYW4gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzIHRoYXQgYXJlIHRoZSBkZW1hcmNhdGlvbiBsaW5lcyBiZXR3ZWVuIGxvY2F0aW9ucyBvbiB0aGUgcGFnZS5cbiAgICAgICAqIENhbiBiZSBpbnZva2VkIGlmIG5ldyBlbGVtZW50cyBhcmUgYWRkZWQgb3IgdGhlIHNpemUgb2YgYSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NhbGNQb2ludHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQb2ludHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQpKTtcbiAgICAgICAgdGhpcy5kb2NIZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5Lm9mZnNldEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLm9mZnNldEhlaWdodCkpO1xuXG4gICAgICAgIHRoaXMuJHRhcmdldHMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyICR0YXIgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICBwdCA9IE1hdGgucm91bmQoJHRhci5vZmZzZXQoKS50b3AgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCk7XG4gICAgICAgICAgJHRhci50YXJnZXRQb2ludCA9IHB0O1xuICAgICAgICAgIF90aGlzLnBvaW50cy5wdXNoKHB0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBNYWdlbGxhbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICAkYm9keSA9ICQoJ2h0bWwsIGJvZHknKSxcbiAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgZHVyYXRpb246IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9O1xuICAgICAgICAkKHdpbmRvdykub25lKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKSB7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuY2FsY1BvaW50cygpO1xuICAgICAgICAgIF90aGlzLl91cGRhdGVBY3RpdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLnJlZmxvdy5iaW5kKHRoaXMpLFxuICAgICAgICAgICdzY3JvbGxtZS56Zi50cmlnZ2VyJzogdGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQodGhpcylcbiAgICAgICAgfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywgJ2FbaHJlZl49XCIjXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdmFyIGFycml2YWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGFycml2YWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcbiAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKHdpbmRvdy5sb2NhdGlvbi5oYXNoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIGEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnc2Nyb2xsVG9Mb2MnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbFRvTG9jKGxvYykge1xuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRhcmdldCBkb2VzIG5vdCBleGlzdCB0byBwcmV2ZW50IGVycm9yc1xuICAgICAgICBpZiAoISQobG9jKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5UcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IE1hdGgucm91bmQoJChsb2MpLm9mZnNldCgpLnRvcCAtIHRoaXMub3B0aW9ucy50aHJlc2hvbGQgLyAyIC0gdGhpcy5vcHRpb25zLmJhck9mZnNldCk7XG5cbiAgICAgICAgJCgnaHRtbCwgYm9keScpLnN0b3AodHJ1ZSkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsUG9zIH0sIHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9pblRyYW5zaXRpb24gPSBmYWxzZTtfdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIE1hZ2VsbGFuIHVwb24gRE9NIGNoYW5nZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JlZmxvdycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVmbG93KCkge1xuICAgICAgICB0aGlzLmNhbGNQb2ludHMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZUFjdGl2ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZUFjdGl2ZSgpIC8qZXZ0LCBlbGVtLCBzY3JvbGxQb3MqL3tcbiAgICAgICAgaWYgKHRoaXMuX2luVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2luUG9zID0gLypzY3JvbGxQb3MgfHwqL3BhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCwgMTApLFxuICAgICAgICAgICAgY3VySWR4O1xuXG4gICAgICAgIGlmICh3aW5Qb3MgKyB0aGlzLndpbkhlaWdodCA9PT0gdGhpcy5kb2NIZWlnaHQpIHtcbiAgICAgICAgICBjdXJJZHggPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHdpblBvcyA8IHRoaXMucG9pbnRzWzBdKSB7XG4gICAgICAgICAgY3VySWR4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpc0Rvd24gPSB0aGlzLnNjcm9sbFBvcyA8IHdpblBvcyxcbiAgICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgICBjdXJWaXNpYmxlID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNEb3duID8gcCAtIF90aGlzLm9wdGlvbnMuYmFyT2Zmc2V0IDw9IHdpblBvcyA6IHAgLSBfdGhpcy5vcHRpb25zLmJhck9mZnNldCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkIDw9IHdpblBvcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjdXJJZHggPSBjdXJWaXNpYmxlLmxlbmd0aCA/IGN1clZpc2libGUubGVuZ3RoIC0gMSA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgdGhpcy4kYWN0aXZlID0gdGhpcy4kbGlua3MuZmlsdGVyKCdbaHJlZj1cIiMnICsgdGhpcy4kdGFyZ2V0cy5lcShjdXJJZHgpLmRhdGEoJ21hZ2VsbGFuLXRhcmdldCcpICsgJ1wiXScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZykge1xuICAgICAgICAgIHZhciBoYXNoID0gXCJcIjtcbiAgICAgICAgICBpZiAoY3VySWR4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc2ggIT09IHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XG4gICAgICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBoYXNoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjcm9sbFBvcyA9IHdpblBvcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gbWFnZWxsYW4gaXMgZmluaXNoZWQgdXBkYXRpbmcgdG8gdGhlIG5ldyBhY3RpdmUgZWxlbWVudC5cbiAgICAgICAgICogQGV2ZW50IE1hZ2VsbGFuI3VwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLCBbdGhpcy4kYWN0aXZlXSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgTWFnZWxsYW4gYW5kIHJlc2V0cyB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhbicpLmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcbiAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKGhhc2gsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTWFnZWxsYW47XG4gIH0oKTtcblxuICAvKipcbiAgICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gICAqL1xuXG5cbiAgTWFnZWxsYW4uZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCB0aGUgYW5pbWF0ZWQgc2Nyb2xsaW5nIHNob3VsZCB0YWtlIGJldHdlZW4gbG9jYXRpb25zLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDUwMFxuICAgICAqL1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIHN0eWxlIHRvIHVzZSB3aGVuIHNjcm9sbGluZyBiZXR3ZWVuIGxvY2F0aW9ucy4gQ2FuIGJlIGAnc3dpbmcnYCBvciBgJ2xpbmVhcidgLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdsaW5lYXInXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9hbmltYXRlfEpxdWVyeSBhbmltYXRlfVxuICAgICAqL1xuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNTBcbiAgICAgKi9cbiAgICB0aHJlc2hvbGQ6IDUwLFxuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdhY3RpdmUnXG4gICAgICovXG4gICAgYWN0aXZlQ2xhc3M6ICdhY3RpdmUnLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgc2NyaXB0IHRvIG1hbmlwdWxhdGUgdGhlIHVybCBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgaWYgc3VwcG9ydGVkLCBhbHRlciB0aGUgaGlzdG9yeS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkZWVwTGlua2luZzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGJhck9mZnNldDogMFxuICB9O1xuXG4gIC8vIFdpbmRvdyBleHBvcnRzXG4gIEZvdW5kYXRpb24ucGx1Z2luKE1hZ2VsbGFuLCAnTWFnZWxsYW4nKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5tYWdlbGxhbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * OffCanvas module.\n   * @module foundation.offcanvas\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.triggers\n   * @requires foundation.util.motion\n   */\n\n  var OffCanvas = function () {\n    /**\n     * Creates a new instance of an off-canvas wrapper.\n     * @class\n     * @fires OffCanvas#init\n     * @param {Object} element - jQuery object to initialize.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function OffCanvas(element, options) {\n      _classCallCheck(this, OffCanvas);\n\n      this.$element = element;\n      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\n      this.$lastTrigger = $();\n      this.$triggers = $();\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'OffCanvas');\n      Foundation.Keyboard.register('OffCanvas', {\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\n     * @function\n     * @private\n     */\n\n\n    _createClass(OffCanvas, [{\n      key: '_init',\n      value: function _init() {\n        var id = this.$element.attr('id');\n\n        this.$element.attr('aria-hidden', 'true');\n\n        this.$element.addClass('is-transition-' + this.options.transition);\n\n        // Find triggers that affect this element and add aria-expanded to them\n        this.$triggers = $(document).find('[data-open=\"' + id + '\"], [data-close=\"' + id + '\"], [data-toggle=\"' + id + '\"]').attr('aria-expanded', 'false').attr('aria-controls', id);\n\n        // Add an overlay over the content if necessary\n        if (this.options.contentOverlay === true) {\n          var overlay = document.createElement('div');\n          var overlayPosition = $(this.$element).css(\"position\") === 'fixed' ? 'is-overlay-fixed' : 'is-overlay-absolute';\n          overlay.setAttribute('class', 'js-off-canvas-overlay ' + overlayPosition);\n          this.$overlay = $(overlay);\n          if (overlayPosition === 'is-overlay-fixed') {\n            $('body').append(this.$overlay);\n          } else {\n            this.$element.siblings('[data-off-canvas-content]').append(this.$overlay);\n          }\n        }\n\n        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\n\n        if (this.options.isRevealed === true) {\n          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\n          this._setMQChecker();\n        }\n        if (!this.options.transitionTime === true) {\n          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas]')[0]).transitionDuration) * 1000;\n        }\n      }\n\n      /**\n       * Adds event handlers to the off-canvas wrapper and the exit overlay.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        this.$element.off('.zf.trigger .zf.offcanvas').on({\n          'open.zf.trigger': this.open.bind(this),\n          'close.zf.trigger': this.close.bind(this),\n          'toggle.zf.trigger': this.toggle.bind(this),\n          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\n        });\n\n        if (this.options.closeOnClick === true) {\n          var $target = this.options.contentOverlay ? this.$overlay : $('[data-off-canvas-content]');\n          $target.on({ 'click.zf.offcanvas': this.close.bind(this) });\n        }\n      }\n\n      /**\n       * Applies event listener for elements that will reveal at certain breakpoints.\n       * @private\n       */\n\n    }, {\n      key: '_setMQChecker',\n      value: function _setMQChecker() {\n        var _this = this;\n\n        $(window).on('changed.zf.mediaquery', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          } else {\n            _this.reveal(false);\n          }\n        }).one('load.zf.offcanvas', function () {\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\n            _this.reveal(true);\n          }\n        });\n      }\n\n      /**\n       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\n       * @param {Boolean} isRevealed - true if element should be revealed.\n       * @function\n       */\n\n    }, {\n      key: 'reveal',\n      value: function reveal(isRevealed) {\n        var $closer = this.$element.find('[data-close]');\n        if (isRevealed) {\n          this.close();\n          this.isRevealed = true;\n          this.$element.attr('aria-hidden', 'false');\n          this.$element.off('open.zf.trigger toggle.zf.trigger');\n          if ($closer.length) {\n            $closer.hide();\n          }\n        } else {\n          this.isRevealed = false;\n          this.$element.attr('aria-hidden', 'true');\n          this.$element.on({\n            'open.zf.trigger': this.open.bind(this),\n            'toggle.zf.trigger': this.toggle.bind(this)\n          });\n          if ($closer.length) {\n            $closer.show();\n          }\n        }\n      }\n\n      /**\n       * Stops scrolling of the body when offcanvas is open on mobile Safari and other troublesome browsers.\n       * @private\n       */\n\n    }, {\n      key: '_stopScrolling',\n      value: function _stopScrolling(event) {\n        return false;\n      }\n\n      // Taken and adapted from http://stackoverflow.com/questions/16889447/prevent-full-page-scrolling-ios\n      // Only really works for y, not sure how to extend to x or if we need to.\n\n    }, {\n      key: '_recordScrollable',\n      value: function _recordScrollable(event) {\n        var elem = this; // called from event handler context with this as elem\n\n        // If the element is scrollable (content overflows), then...\n        if (elem.scrollHeight !== elem.clientHeight) {\n          // If we're at the top, scroll down one pixel to allow scrolling up\n          if (elem.scrollTop === 0) {\n            elem.scrollTop = 1;\n          }\n          // If we're at the bottom, scroll up one pixel to allow scrolling down\n          if (elem.scrollTop === elem.scrollHeight - elem.clientHeight) {\n            elem.scrollTop = elem.scrollHeight - elem.clientHeight - 1;\n          }\n        }\n        elem.allowUp = elem.scrollTop > 0;\n        elem.allowDown = elem.scrollTop < elem.scrollHeight - elem.clientHeight;\n        elem.lastY = event.originalEvent.pageY;\n      }\n    }, {\n      key: '_stopScrollPropagation',\n      value: function _stopScrollPropagation(event) {\n        var elem = this; // called from event handler context with this as elem\n        var up = event.pageY < elem.lastY;\n        var down = !up;\n        elem.lastY = event.pageY;\n\n        if (up && elem.allowUp || down && elem.allowDown) {\n          event.stopPropagation();\n        } else {\n          event.preventDefault();\n        }\n      }\n\n      /**\n       * Opens the off-canvas menu.\n       * @function\n       * @param {Object} event - Event object passed from listener.\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\n       * @fires OffCanvas#opened\n       */\n\n    }, {\n      key: 'open',\n      value: function open(event, trigger) {\n        if (this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n        var _this = this;\n\n        if (trigger) {\n          this.$lastTrigger = trigger;\n        }\n\n        if (this.options.forceTo === 'top') {\n          window.scrollTo(0, 0);\n        } else if (this.options.forceTo === 'bottom') {\n          window.scrollTo(0, document.body.scrollHeight);\n        }\n\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#opened\n         */\n        _this.$element.addClass('is-open');\n\n        this.$triggers.attr('aria-expanded', 'true');\n        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');\n\n        // If `contentScroll` is set to false, add class and disable scrolling on touch devices.\n        if (this.options.contentScroll === false) {\n          $('body').addClass('is-off-canvas-open').on('touchmove', this._stopScrolling);\n          this.$element.on('touchstart', this._recordScrollable);\n          this.$element.on('touchmove', this._stopScrollPropagation);\n        }\n\n        if (this.options.contentOverlay === true) {\n          this.$overlay.addClass('is-visible');\n        }\n\n        if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n          this.$overlay.addClass('is-closable');\n        }\n\n        if (this.options.autoFocus === true) {\n          this.$element.one(Foundation.transitionend(this.$element), function () {\n            _this.$element.find('a, button').eq(0).focus();\n          });\n        }\n\n        if (this.options.trapFocus === true) {\n          this.$element.siblings('[data-off-canvas-content]').attr('tabindex', '-1');\n          Foundation.Keyboard.trapFocus(this.$element);\n        }\n      }\n\n      /**\n       * Closes the off-canvas menu.\n       * @function\n       * @param {Function} cb - optional cb to fire after closure.\n       * @fires OffCanvas#closed\n       */\n\n    }, {\n      key: 'close',\n      value: function close(cb) {\n        if (!this.$element.hasClass('is-open') || this.isRevealed) {\n          return;\n        }\n\n        var _this = this;\n\n        _this.$element.removeClass('is-open');\n\n        this.$element.attr('aria-hidden', 'true')\n        /**\n         * Fires when the off-canvas menu opens.\n         * @event OffCanvas#closed\n         */\n        .trigger('closed.zf.offcanvas');\n\n        // If `contentScroll` is set to false, remove class and re-enable scrolling on touch devices.\n        if (this.options.contentScroll === false) {\n          $('body').removeClass('is-off-canvas-open').off('touchmove', this._stopScrolling);\n          this.$element.off('touchstart', this._recordScrollable);\n          this.$element.off('touchmove', this._stopScrollPropagation);\n        }\n\n        if (this.options.contentOverlay === true) {\n          this.$overlay.removeClass('is-visible');\n        }\n\n        if (this.options.closeOnClick === true && this.options.contentOverlay === true) {\n          this.$overlay.removeClass('is-closable');\n        }\n\n        this.$triggers.attr('aria-expanded', 'false');\n\n        if (this.options.trapFocus === true) {\n          this.$element.siblings('[data-off-canvas-content]').removeAttr('tabindex');\n          Foundation.Keyboard.releaseFocus(this.$element);\n        }\n      }\n\n      /**\n       * Toggles the off-canvas menu open or closed.\n       * @function\n       * @param {Object} event - Event object passed from listener.\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle(event, trigger) {\n        if (this.$element.hasClass('is-open')) {\n          this.close(event, trigger);\n        } else {\n          this.open(event, trigger);\n        }\n      }\n\n      /**\n       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_handleKeyboard',\n      value: function _handleKeyboard(e) {\n        var _this2 = this;\n\n        Foundation.Keyboard.handleKey(e, 'OffCanvas', {\n          close: function () {\n            _this2.close();\n            _this2.$lastTrigger.focus();\n            return true;\n          },\n          handled: function () {\n            e.stopPropagation();\n            e.preventDefault();\n          }\n        });\n      }\n\n      /**\n       * Destroys the offcanvas plugin.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.close();\n        this.$element.off('.zf.trigger .zf.offcanvas');\n        this.$overlay.off('.zf.offcanvas');\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return OffCanvas;\n  }();\n\n  OffCanvas.defaults = {\n    /**\n     * Allow the user to click outside of the menu to close it.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClick: true,\n\n    /**\n     * Adds an overlay on top of `[data-off-canvas-content]`.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    contentOverlay: true,\n\n    /**\n     * Enable/disable scrolling of the main content when an off canvas panel is open.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    contentScroll: true,\n\n    /**\n     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    transitionTime: 0,\n\n    /**\n     * Type of transition for the offcanvas menu. Options are 'push', 'detached' or 'slide'.\n     * @option\n     * @type {string}\n     * @default push\n     */\n    transition: 'push',\n\n    /**\n     * Force the page to scroll to top or bottom on open.\n     * @option\n     * @type {?string}\n     * @default null\n     */\n    forceTo: null,\n\n    /**\n     * Allow the offcanvas to remain open for certain breakpoints.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    isRevealed: false,\n\n    /**\n     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\n     * @option\n     * @type {?string}\n     * @default null\n     */\n    revealOn: null,\n\n    /**\n     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    autoFocus: true,\n\n    /**\n     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\n     * @option\n     * @type {string}\n     * @default reveal-for-\n     * @todo improve the regex testing for this.\n     */\n    revealClass: 'reveal-for-',\n\n    /**\n     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    trapFocus: false\n  };\n\n  // Window exports\n  Foundation.plugin(OffCanvas, 'OffCanvas');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ub2ZmY2FudmFzLmpzPzlkNmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogT2ZmQ2FudmFzIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLm9mZmNhbnZhc1xuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gICAqL1xuXG4gIHZhciBPZmZDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvZmYtY2FudmFzIHdyYXBwZXIuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIE9mZkNhbnZhcyNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGluaXRpYWxpemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9mZkNhbnZhcyhlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2ZmQ2FudmFzKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT2ZmQ2FudmFzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLiRsYXN0VHJpZ2dlciA9ICQoKTtcbiAgICAgIHRoaXMuJHRyaWdnZXJzID0gJCgpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnT2ZmQ2FudmFzJyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPZmZDYW52YXMnLCB7XG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhPZmZDYW52YXMsIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy10cmFuc2l0aW9uLScgKyB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbik7XG5cbiAgICAgICAgLy8gRmluZCB0cmlnZ2VycyB0aGF0IGFmZmVjdCB0aGlzIGVsZW1lbnQgYW5kIGFkZCBhcmlhLWV4cGFuZGVkIHRvIHRoZW1cbiAgICAgICAgdGhpcy4kdHJpZ2dlcnMgPSAkKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVwiJyArIGlkICsgJ1wiXSwgW2RhdGEtY2xvc2U9XCInICsgaWQgKyAnXCJdLCBbZGF0YS10b2dnbGU9XCInICsgaWQgKyAnXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7XG5cbiAgICAgICAgLy8gQWRkIGFuIG92ZXJsYXkgb3ZlciB0aGUgY29udGVudCBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50T3ZlcmxheSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBvdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgdmFyIG92ZXJsYXlQb3NpdGlvbiA9ICQodGhpcy4kZWxlbWVudCkuY3NzKFwicG9zaXRpb25cIikgPT09ICdmaXhlZCcgPyAnaXMtb3ZlcmxheS1maXhlZCcgOiAnaXMtb3ZlcmxheS1hYnNvbHV0ZSc7XG4gICAgICAgICAgb3ZlcmxheS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2pzLW9mZi1jYW52YXMtb3ZlcmxheSAnICsgb3ZlcmxheVBvc2l0aW9uKTtcbiAgICAgICAgICB0aGlzLiRvdmVybGF5ID0gJChvdmVybGF5KTtcbiAgICAgICAgICBpZiAob3ZlcmxheVBvc2l0aW9uID09PSAnaXMtb3ZlcmxheS1maXhlZCcpIHtcbiAgICAgICAgICAgICQoJ2JvZHknKS5hcHBlbmQodGhpcy4kb3ZlcmxheSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuc2libGluZ3MoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5hcHBlbmQodGhpcy4kb3ZlcmxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgPSB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCB8fCBuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcywgJ2cnKS50ZXN0KHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucmV2ZWFsT24gPSB0aGlzLm9wdGlvbnMucmV2ZWFsT24gfHwgdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdCgnLScpWzJdO1xuICAgICAgICAgIHRoaXMuX3NldE1RQ2hlY2tlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lID0gcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkKCdbZGF0YS1vZmYtY2FudmFzXScpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9mZi1jYW52YXMgd3JhcHBlciBhbmQgdGhlIGV4aXQgb3ZlcmxheS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKS5vbih7XG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXG4gICAgICAgICAgJ2tleWRvd24uemYub2ZmY2FudmFzJzogdGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciAkdGFyZ2V0ID0gdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID8gdGhpcy4kb3ZlcmxheSA6ICQoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKTtcbiAgICAgICAgICAkdGFyZ2V0Lm9uKHsgJ2NsaWNrLnpmLm9mZmNhbnZhcyc6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFwcGxpZXMgZXZlbnQgbGlzdGVuZXIgZm9yIGVsZW1lbnRzIHRoYXQgd2lsbCByZXZlYWwgYXQgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRNUUNoZWNrZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNUUNoZWNrZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KF90aGlzLm9wdGlvbnMucmV2ZWFsT24pKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXZlYWwodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnJldmVhbChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbmUoJ2xvYWQuemYub2ZmY2FudmFzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xuICAgICAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmV2ZWFsZWQgLSB0cnVlIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHJldmVhbGVkLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3JldmVhbCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZWFsKGlzUmV2ZWFsZWQpIHtcbiAgICAgICAgdmFyICRjbG9zZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWNsb3NlXScpO1xuICAgICAgICBpZiAoaXNSZXZlYWxlZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignb3Blbi56Zi50cmlnZ2VyIHRvZ2dsZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgaWYgKCRjbG9zZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAkY2xvc2VyLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXG4gICAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCRjbG9zZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAkY2xvc2VyLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTdG9wcyBzY3JvbGxpbmcgb2YgdGhlIGJvZHkgd2hlbiBvZmZjYW52YXMgaXMgb3BlbiBvbiBtb2JpbGUgU2FmYXJpIGFuZCBvdGhlciB0cm91Ymxlc29tZSBicm93c2Vycy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zdG9wU2Nyb2xsaW5nJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RvcFNjcm9sbGluZyhldmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRha2VuIGFuZCBhZGFwdGVkIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjg4OTQ0Ny9wcmV2ZW50LWZ1bGwtcGFnZS1zY3JvbGxpbmctaW9zXG4gICAgICAvLyBPbmx5IHJlYWxseSB3b3JrcyBmb3IgeSwgbm90IHN1cmUgaG93IHRvIGV4dGVuZCB0byB4IG9yIGlmIHdlIG5lZWQgdG8uXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVjb3JkU2Nyb2xsYWJsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlY29yZFNjcm9sbGFibGUoZXZlbnQpIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0aGlzOyAvLyBjYWxsZWQgZnJvbSBldmVudCBoYW5kbGVyIGNvbnRleHQgd2l0aCB0aGlzIGFzIGVsZW1cblxuICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBzY3JvbGxhYmxlIChjb250ZW50IG92ZXJmbG93cyksIHRoZW4uLi5cbiAgICAgICAgaWYgKGVsZW0uc2Nyb2xsSGVpZ2h0ICE9PSBlbGVtLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSB0b3AsIHNjcm9sbCBkb3duIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgdXBcbiAgICAgICAgICBpZiAoZWxlbS5zY3JvbGxUb3AgPT09IDApIHtcbiAgICAgICAgICAgIGVsZW0uc2Nyb2xsVG9wID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGJvdHRvbSwgc2Nyb2xsIHVwIG9uZSBwaXhlbCB0byBhbGxvdyBzY3JvbGxpbmcgZG93blxuICAgICAgICAgIGlmIChlbGVtLnNjcm9sbFRvcCA9PT0gZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodCkge1xuICAgICAgICAgICAgZWxlbS5zY3JvbGxUb3AgPSBlbGVtLnNjcm9sbEhlaWdodCAtIGVsZW0uY2xpZW50SGVpZ2h0IC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbS5hbGxvd1VwID0gZWxlbS5zY3JvbGxUb3AgPiAwO1xuICAgICAgICBlbGVtLmFsbG93RG93biA9IGVsZW0uc2Nyb2xsVG9wIDwgZWxlbS5zY3JvbGxIZWlnaHQgLSBlbGVtLmNsaWVudEhlaWdodDtcbiAgICAgICAgZWxlbS5sYXN0WSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQucGFnZVk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX3N0b3BTY3JvbGxQcm9wYWdhdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BTY3JvbGxQcm9wYWdhdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXM7IC8vIGNhbGxlZCBmcm9tIGV2ZW50IGhhbmRsZXIgY29udGV4dCB3aXRoIHRoaXMgYXMgZWxlbVxuICAgICAgICB2YXIgdXAgPSBldmVudC5wYWdlWSA8IGVsZW0ubGFzdFk7XG4gICAgICAgIHZhciBkb3duID0gIXVwO1xuICAgICAgICBlbGVtLmxhc3RZID0gZXZlbnQucGFnZVk7XG5cbiAgICAgICAgaWYgKHVwICYmIGVsZW0uYWxsb3dVcCB8fCBkb3duICYmIGVsZW0uYWxsb3dEb3duKSB7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIE9wZW5zIHRoZSBvZmYtY2FudmFzIG1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICAgICAgICogQGZpcmVzIE9mZkNhbnZhcyNvcGVuZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnb3BlbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbihldmVudCwgdHJpZ2dlcikge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpIHx8IHRoaXMuaXNSZXZlYWxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICAgICAgdGhpcy4kbGFzdFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVRvID09PSAndG9wJykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VUbyA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNvcGVuZWRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1vcGVuJyk7XG5cbiAgICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKS50cmlnZ2VyKCdvcGVuZWQuemYub2ZmY2FudmFzJyk7XG5cbiAgICAgICAgLy8gSWYgYGNvbnRlbnRTY3JvbGxgIGlzIHNldCB0byBmYWxzZSwgYWRkIGNsYXNzIGFuZCBkaXNhYmxlIHNjcm9sbGluZyBvbiB0b3VjaCBkZXZpY2VzLlxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRTY3JvbGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4nKS5vbigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbigndG91Y2hzdGFydCcsIHRoaXMuX3JlY29yZFNjcm9sbGFibGUpO1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RvdWNobW92ZScsIHRoaXMuX3N0b3BTY3JvbGxQcm9wYWdhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnaXMtdmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnRPdmVybGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnaXMtY2xvc2FibGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5maW5kKCdhLCBidXR0b24nKS5lcSgwKS5mb2N1cygpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnNpYmxpbmdzKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnRyYXBGb2N1cyh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNiIHRvIGZpcmUgYWZ0ZXIgY2xvc3VyZS5cbiAgICAgICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Nsb3NlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShjYikge1xuICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSB8fCB0aGlzLmlzUmV2ZWFsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNjbG9zZWRcbiAgICAgICAgICovXG4gICAgICAgIC50cmlnZ2VyKCdjbG9zZWQuemYub2ZmY2FudmFzJyk7XG5cbiAgICAgICAgLy8gSWYgYGNvbnRlbnRTY3JvbGxgIGlzIHNldCB0byBmYWxzZSwgcmVtb3ZlIGNsYXNzIGFuZCByZS1lbmFibGUgc2Nyb2xsaW5nIG9uIHRvdWNoIGRldmljZXMuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudFNjcm9sbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbicpLm9mZigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbGluZyk7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3RvdWNoc3RhcnQnLCB0aGlzLl9yZWNvcmRTY3JvbGxhYmxlKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG91Y2htb3ZlJywgdGhpcy5fc3RvcFNjcm9sbFByb3BhZ2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuY29udGVudE92ZXJsYXkgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LnJlbW92ZUNsYXNzKCdpcy1jbG9zYWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kdHJpZ2dlcnMuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHJhcEZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5zaWJsaW5ncygnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWxlYXNlRm9jdXModGhpcy4kZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBvZmYtY2FudmFzIG1lbnUgb3BlbiBvciBjbG9zZWQuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSB0cmlnZ2VyIC0gZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgb2ZmLWNhbnZhcyB0byBvcGVuLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCwgdHJpZ2dlcikge1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZShldmVudCwgdHJpZ2dlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vcGVuKGV2ZW50LCB0cmlnZ2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhhbmRsZXMga2V5Ym9hcmQgaW5wdXQgd2hlbiBkZXRlY3RlZC4gV2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLCB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlcywgYW5kIGZvY3VzIGlzIHJlc3RvcmVkIHRvIHRoZSBlbGVtZW50IHRoYXQgb3BlbmVkIHRoZSBtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlS2V5Ym9hcmQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVLZXlib2FyZChlKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdPZmZDYW52YXMnLCB7XG4gICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5jbG9zZSgpO1xuICAgICAgICAgICAgX3RoaXMyLiRsYXN0VHJpZ2dlci5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIG9mZmNhbnZhcyBwbHVnaW4uXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhcycpO1xuICAgICAgICB0aGlzLiRvdmVybGF5Lm9mZignLnpmLm9mZmNhbnZhcycpO1xuXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gT2ZmQ2FudmFzO1xuICB9KCk7XG5cbiAgT2ZmQ2FudmFzLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEFsbG93IHRoZSB1c2VyIHRvIGNsaWNrIG91dHNpZGUgb2YgdGhlIG1lbnUgdG8gY2xvc2UgaXQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBjbG9zZU9uQ2xpY2s6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIG92ZXJsYXkgb24gdG9wIG9mIGBbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdYC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGNvbnRlbnRPdmVybGF5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlL2Rpc2FibGUgc2Nyb2xsaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQgd2hlbiBhbiBvZmYgY2FudmFzIHBhbmVsIGlzIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBjb250ZW50U2Nyb2xsOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgaW4gbXMgdGhlIG9wZW4gYW5kIGNsb3NlIHRyYW5zaXRpb24gcmVxdWlyZXMuIElmIG5vbmUgc2VsZWN0ZWQsIHB1bGxzIGZyb20gYm9keSBzdHlsZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRpbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIHRyYW5zaXRpb24gZm9yIHRoZSBvZmZjYW52YXMgbWVudS4gT3B0aW9ucyBhcmUgJ3B1c2gnLCAnZGV0YWNoZWQnIG9yICdzbGlkZScuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgcHVzaFxuICAgICAqL1xuICAgIHRyYW5zaXRpb246ICdwdXNoJyxcblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHRoZSBwYWdlIHRvIHNjcm9sbCB0byB0b3Agb3IgYm90dG9tIG9uIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBmb3JjZVRvOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQWxsb3cgdGhlIG9mZmNhbnZhcyB0byByZW1haW4gb3BlbiBmb3IgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBpc1JldmVhbGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEJyZWFrcG9pbnQgYXQgd2hpY2ggdG8gcmV2ZWFsLiBKUyB3aWxsIHVzZSBhIFJlZ0V4cCB0byB0YXJnZXQgc3RhbmRhcmQgY2xhc3NlcywgaWYgY2hhbmdpbmcgY2xhc3NuYW1lcywgcGFzcyB5b3VyIGNsYXNzIHdpdGggdGhlIGByZXZlYWxDbGFzc2Agb3B0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgcmV2ZWFsT246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSBmb2N1cyB0byB0aGUgb2ZmY2FudmFzIG9uIG9wZW4uIElmIHRydWUsIHdpbGwgZm9jdXMgdGhlIG9wZW5pbmcgdHJpZ2dlciBvbiBjbG9zZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGF1dG9Gb2N1czogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIENsYXNzIHVzZWQgdG8gZm9yY2UgYW4gb2ZmY2FudmFzIHRvIHJlbWFpbiBvcGVuLiBGb3VuZGF0aW9uIGRlZmF1bHRzIGZvciB0aGlzIGFyZSBgcmV2ZWFsLWZvci1sYXJnZWAgJiBgcmV2ZWFsLWZvci1tZWRpdW1gLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IHJldmVhbC1mb3ItXG4gICAgICogQHRvZG8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cbiAgICAgKi9cbiAgICByZXZlYWxDbGFzczogJ3JldmVhbC1mb3ItJyxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIG9wdGlvbmFsIGZvY3VzIHRyYXBwaW5nIHdoZW4gb3BlbmluZyBhbiBvZmZjYW52YXMuIFNldHMgdGFiaW5kZXggb2YgW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XSB0byAtMSBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0cmFwRm9jdXM6IGZhbHNlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oT2ZmQ2FudmFzLCAnT2ZmQ2FudmFzJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ub2ZmY2FudmFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 11 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Orbit module.\n   * @module foundation.orbit\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.motion\n   * @requires foundation.util.timerAndImageLoader\n   * @requires foundation.util.touch\n   */\n\n  var Orbit = function () {\n    /**\n    * Creates a new instance of an orbit carousel.\n    * @class\n    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.\n    * @param {Object} options - Overrides to the default plugin settings.\n    */\n    function Orbit(element, options) {\n      _classCallCheck(this, Orbit);\n\n      this.$element = element;\n      this.options = $.extend({}, Orbit.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Orbit');\n      Foundation.Keyboard.register('Orbit', {\n        'ltr': {\n          'ARROW_RIGHT': 'next',\n          'ARROW_LEFT': 'previous'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'next',\n          'ARROW_RIGHT': 'previous'\n        }\n      });\n    }\n\n    /**\n    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.\n    * @function\n    * @private\n    */\n\n\n    _createClass(Orbit, [{\n      key: '_init',\n      value: function _init() {\n        // @TODO: consider discussion on PR #9278 about DOM pollution by changeSlide\n        this._reset();\n\n        this.$wrapper = this.$element.find('.' + this.options.containerClass);\n        this.$slides = this.$element.find('.' + this.options.slideClass);\n\n        var $images = this.$element.find('img'),\n            initActive = this.$slides.filter('.is-active'),\n            id = this.$element[0].id || Foundation.GetYoDigits(6, 'orbit');\n\n        this.$element.attr({\n          'data-resize': id,\n          'id': id\n        });\n\n        if (!initActive.length) {\n          this.$slides.eq(0).addClass('is-active');\n        }\n\n        if (!this.options.useMUI) {\n          this.$slides.addClass('no-motionui');\n        }\n\n        if ($images.length) {\n          Foundation.onImagesLoaded($images, this._prepareForOrbit.bind(this));\n        } else {\n          this._prepareForOrbit(); //hehe\n        }\n\n        if (this.options.bullets) {\n          this._loadBullets();\n        }\n\n        this._events();\n\n        if (this.options.autoPlay && this.$slides.length > 1) {\n          this.geoSync();\n        }\n\n        if (this.options.accessible) {\n          // allow wrapper to be focusable to enable arrow navigation\n          this.$wrapper.attr('tabindex', 0);\n        }\n      }\n\n      /**\n      * Creates a jQuery collection of bullets, if they are being used.\n      * @function\n      * @private\n      */\n\n    }, {\n      key: '_loadBullets',\n      value: function _loadBullets() {\n        this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');\n      }\n\n      /**\n      * Sets a `timer` object on the orbit, and starts the counter for the next slide.\n      * @function\n      */\n\n    }, {\n      key: 'geoSync',\n      value: function geoSync() {\n        var _this = this;\n        this.timer = new Foundation.Timer(this.$element, {\n          duration: this.options.timerDelay,\n          infinite: false\n        }, function () {\n          _this.changeSlide(true);\n        });\n        this.timer.start();\n      }\n\n      /**\n      * Sets wrapper and slide heights for the orbit.\n      * @function\n      * @private\n      */\n\n    }, {\n      key: '_prepareForOrbit',\n      value: function _prepareForOrbit() {\n        var _this = this;\n        this._setWrapperHeight();\n      }\n\n      /**\n      * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.\n      * @function\n      * @private\n      * @param {Function} cb - a callback function to fire when complete.\n      */\n\n    }, {\n      key: '_setWrapperHeight',\n      value: function _setWrapperHeight(cb) {\n        //rewrite this to `for` loop\n        var max = 0,\n            temp,\n            counter = 0,\n            _this = this;\n\n        this.$slides.each(function () {\n          temp = this.getBoundingClientRect().height;\n          $(this).attr('data-slide', counter);\n\n          if (_this.$slides.filter('.is-active')[0] !== _this.$slides.eq(counter)[0]) {\n            //if not the active slide, set css position and display property\n            $(this).css({ 'position': 'relative', 'display': 'none' });\n          }\n          max = temp > max ? temp : max;\n          counter++;\n        });\n\n        if (counter === this.$slides.length) {\n          this.$wrapper.css({ 'height': max }); //only change the wrapper height property once.\n          if (cb) {\n            cb(max);\n          } //fire callback with max height dimension.\n        }\n      }\n\n      /**\n      * Sets the max-height of each slide.\n      * @function\n      * @private\n      */\n\n    }, {\n      key: '_setSlideHeight',\n      value: function _setSlideHeight(height) {\n        this.$slides.each(function () {\n          $(this).css('max-height', height);\n        });\n      }\n\n      /**\n      * Adds event listeners to basically everything within the element.\n      * @function\n      * @private\n      */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        //***************************************\n        //**Now using custom event - thanks to:**\n        //**      Yohai Ararat of Toronto      **\n        //***************************************\n        //\n        this.$element.off('.resizeme.zf.trigger').on({\n          'resizeme.zf.trigger': this._prepareForOrbit.bind(this)\n        });\n        if (this.$slides.length > 1) {\n\n          if (this.options.swipe) {\n            this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {\n              e.preventDefault();\n              _this.changeSlide(true);\n            }).on('swiperight.zf.orbit', function (e) {\n              e.preventDefault();\n              _this.changeSlide(false);\n            });\n          }\n          //***************************************\n\n          if (this.options.autoPlay) {\n            this.$slides.on('click.zf.orbit', function () {\n              _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);\n              _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();\n            });\n\n            if (this.options.pauseOnHover) {\n              this.$element.on('mouseenter.zf.orbit', function () {\n                _this.timer.pause();\n              }).on('mouseleave.zf.orbit', function () {\n                if (!_this.$element.data('clickedOn')) {\n                  _this.timer.start();\n                }\n              });\n            }\n          }\n\n          if (this.options.navButtons) {\n            var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);\n            $controls.attr('tabindex', 0)\n            //also need to handle enter/return and spacebar key presses\n            .on('click.zf.orbit touchend.zf.orbit', function (e) {\n              e.preventDefault();\n              _this.changeSlide($(this).hasClass(_this.options.nextClass));\n            });\n          }\n\n          if (this.options.bullets) {\n            this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {\n              if (/is-active/g.test(this.className)) {\n                return false;\n              } //if this is active, kick out of function.\n              var idx = $(this).data('slide'),\n                  ltr = idx > _this.$slides.filter('.is-active').data('slide'),\n                  $slide = _this.$slides.eq(idx);\n\n              _this.changeSlide(ltr, $slide, idx);\n            });\n          }\n\n          if (this.options.accessible) {\n            this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {\n              // handle keyboard event with keyboard util\n              Foundation.Keyboard.handleKey(e, 'Orbit', {\n                next: function () {\n                  _this.changeSlide(true);\n                },\n                previous: function () {\n                  _this.changeSlide(false);\n                },\n                handled: function () {\n                  // if bullet is focused, make sure focus moves\n                  if ($(e.target).is(_this.$bullets)) {\n                    _this.$bullets.filter('.is-active').focus();\n                  }\n                }\n              });\n            });\n          }\n        }\n      }\n\n      /**\n       * Resets Orbit so it can be reinitialized\n       */\n\n    }, {\n      key: '_reset',\n      value: function _reset() {\n        // Don't do anything if there are no slides (first run)\n        if (typeof this.$slides == 'undefined') {\n          return;\n        }\n\n        if (this.$slides.length > 1) {\n          // Remove old events\n          this.$element.off('.zf.orbit').find('*').off('.zf.orbit');\n\n          // Restart timer if autoPlay is enabled\n          if (this.options.autoPlay) {\n            this.timer.restart();\n          }\n\n          // Reset all sliddes\n          this.$slides.each(function (el) {\n            $(el).removeClass('is-active is-active is-in').removeAttr('aria-live').hide();\n          });\n\n          // Show the first slide\n          this.$slides.first().addClass('is-active').show();\n\n          // Triggers when the slide has finished animating\n          this.$element.trigger('slidechange.zf.orbit', [this.$slides.first()]);\n\n          // Select first bullet if bullets are present\n          if (this.options.bullets) {\n            this._updateBullets(0);\n          }\n        }\n      }\n\n      /**\n      * Changes the current slide to a new one.\n      * @function\n      * @param {Boolean} isLTR - flag if the slide should move left to right.\n      * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.\n      * @param {Number} idx - the index of the new slide in its collection, if one chosen.\n      * @fires Orbit#slidechange\n      */\n\n    }, {\n      key: 'changeSlide',\n      value: function changeSlide(isLTR, chosenSlide, idx) {\n        if (!this.$slides) {\n          return;\n        } // Don't freak out if we're in the middle of cleanup\n        var $curSlide = this.$slides.filter('.is-active').eq(0);\n\n        if (/mui/g.test($curSlide[0].className)) {\n          return false;\n        } //if the slide is currently animating, kick out of the function\n\n        var $firstSlide = this.$slides.first(),\n            $lastSlide = this.$slides.last(),\n            dirIn = isLTR ? 'Right' : 'Left',\n            dirOut = isLTR ? 'Left' : 'Right',\n            _this = this,\n            $newSlide;\n\n        if (!chosenSlide) {\n          //most of the time, this will be auto played or clicked from the navButtons.\n          $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!\n          this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass) : //pick next slide if moving left to right\n          this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass); //pick prev slide if moving right to left\n        } else {\n          $newSlide = chosenSlide;\n        }\n\n        if ($newSlide.length) {\n          /**\n          * Triggers before the next slide starts animating in and only if a next slide has been found.\n          * @event Orbit#beforeslidechange\n          */\n          this.$element.trigger('beforeslidechange.zf.orbit', [$curSlide, $newSlide]);\n\n          if (this.options.bullets) {\n            idx = idx || this.$slides.index($newSlide); //grab index to update bullets\n            this._updateBullets(idx);\n          }\n\n          if (this.options.useMUI && !this.$element.is(':hidden')) {\n            Foundation.Motion.animateIn($newSlide.addClass('is-active').css({ 'position': 'absolute', 'top': 0 }), this.options['animInFrom' + dirIn], function () {\n              $newSlide.css({ 'position': 'relative', 'display': 'block' }).attr('aria-live', 'polite');\n            });\n\n            Foundation.Motion.animateOut($curSlide.removeClass('is-active'), this.options['animOutTo' + dirOut], function () {\n              $curSlide.removeAttr('aria-live');\n              if (_this.options.autoPlay && !_this.timer.isPaused) {\n                _this.timer.restart();\n              }\n              //do stuff?\n            });\n          } else {\n            $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();\n            $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();\n            if (this.options.autoPlay && !this.timer.isPaused) {\n              this.timer.restart();\n            }\n          }\n          /**\n          * Triggers when the slide has finished animating in.\n          * @event Orbit#slidechange\n          */\n          this.$element.trigger('slidechange.zf.orbit', [$newSlide]);\n        }\n      }\n\n      /**\n      * Updates the active state of the bullets, if displayed.\n      * @function\n      * @private\n      * @param {Number} idx - the index of the current slide.\n      */\n\n    }, {\n      key: '_updateBullets',\n      value: function _updateBullets(idx) {\n        var $oldBullet = this.$element.find('.' + this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),\n            span = $oldBullet.find('span:last').detach(),\n            $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);\n      }\n\n      /**\n      * Destroys the carousel and hides the element.\n      * @function\n      */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Orbit;\n  }();\n\n  Orbit.defaults = {\n    /**\n    * Tells the JS to look for and loadBullets.\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    bullets: true,\n    /**\n    * Tells the JS to apply event listeners to nav buttons\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    navButtons: true,\n    /**\n    * motion-ui animation class to apply\n    * @option\n     * @type {string}\n    * @default 'slide-in-right'\n    */\n    animInFromRight: 'slide-in-right',\n    /**\n    * motion-ui animation class to apply\n    * @option\n     * @type {string}\n    * @default 'slide-out-right'\n    */\n    animOutToRight: 'slide-out-right',\n    /**\n    * motion-ui animation class to apply\n    * @option\n     * @type {string}\n    * @default 'slide-in-left'\n    *\n    */\n    animInFromLeft: 'slide-in-left',\n    /**\n    * motion-ui animation class to apply\n    * @option\n     * @type {string}\n    * @default 'slide-out-left'\n    */\n    animOutToLeft: 'slide-out-left',\n    /**\n    * Allows Orbit to automatically animate on page load.\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    autoPlay: true,\n    /**\n    * Amount of time, in ms, between slide transitions\n    * @option\n     * @type {number}\n    * @default 5000\n    */\n    timerDelay: 5000,\n    /**\n    * Allows Orbit to infinitely loop through the slides\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    infiniteWrap: true,\n    /**\n    * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    swipe: true,\n    /**\n    * Allows the timing function to pause animation on hover.\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    pauseOnHover: true,\n    /**\n    * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    accessible: true,\n    /**\n    * Class applied to the container of Orbit\n    * @option\n     * @type {string}\n    * @default 'orbit-container'\n    */\n    containerClass: 'orbit-container',\n    /**\n    * Class applied to individual slides.\n    * @option\n     * @type {string}\n    * @default 'orbit-slide'\n    */\n    slideClass: 'orbit-slide',\n    /**\n    * Class applied to the bullet container. You're welcome.\n    * @option\n     * @type {string}\n    * @default 'orbit-bullets'\n    */\n    boxOfBullets: 'orbit-bullets',\n    /**\n    * Class applied to the `next` navigation button.\n    * @option\n     * @type {string}\n    * @default 'orbit-next'\n    */\n    nextClass: 'orbit-next',\n    /**\n    * Class applied to the `previous` navigation button.\n    * @option\n     * @type {string}\n    * @default 'orbit-previous'\n    */\n    prevClass: 'orbit-previous',\n    /**\n    * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.\n    * @option\n     * @type {boolean}\n    * @default true\n    */\n    useMUI: true\n  };\n\n  // Window exports\n  Foundation.plugin(Orbit, 'Orbit');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ub3JiaXQuanM/OTRhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBPcmJpdCBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5vcmJpdFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gICAqL1xuXG4gIHZhciBPcmJpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb3JiaXQgY2Fyb3VzZWwuXG4gICAgKiBAY2xhc3NcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gT3JiaXQgQ2Fyb3VzZWwuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBPcmJpdChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3JiaXQpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPcmJpdC5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ09yYml0Jyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPcmJpdCcsIHtcbiAgICAgICAgJ2x0cic6IHtcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnbmV4dCcsXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXG4gICAgICAgIH0sXG4gICAgICAgICdydGwnOiB7XG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnbmV4dCcsXG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ3ByZXZpb3VzJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhPcmJpdCwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgLy8gQFRPRE86IGNvbnNpZGVyIGRpc2N1c3Npb24gb24gUFIgIzkyNzggYWJvdXQgRE9NIHBvbGx1dGlvbiBieSBjaGFuZ2VTbGlkZVxuICAgICAgICB0aGlzLl9yZXNldCgpO1xuXG4gICAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcbiAgICAgICAgdGhpcy4kc2xpZGVzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTtcblxuICAgICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyksXG4gICAgICAgICAgICBpbml0QWN0aXZlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLFxuICAgICAgICAgICAgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ29yYml0Jyk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcbiAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWluaXRBY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU1VSSkge1xuICAgICAgICAgIHRoaXMuJHNsaWRlcy5hZGRDbGFzcygnbm8tbW90aW9udWknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgIEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoJGltYWdlcywgdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXBhcmVGb3JPcmJpdCgpOyAvL2hlaGVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xuICAgICAgICAgIHRoaXMuX2xvYWRCdWxsZXRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmIHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5nZW9TeW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcbiAgICAgICAgICAvLyBhbGxvdyB3cmFwcGVyIHRvIGJlIGZvY3VzYWJsZSB0byBlbmFibGUgYXJyb3cgbmF2aWdhdGlvblxuICAgICAgICAgIHRoaXMuJHdyYXBwZXIuYXR0cigndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19sb2FkQnVsbGV0cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRCdWxsZXRzKCkge1xuICAgICAgICB0aGlzLiRidWxsZXRzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoJ2J1dHRvbicpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogU2V0cyBhIGB0aW1lcmAgb2JqZWN0IG9uIHRoZSBvcmJpdCwgYW5kIHN0YXJ0cyB0aGUgY291bnRlciBmb3IgdGhlIG5leHQgc2xpZGUuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2dlb1N5bmMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlb1N5bmMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGltZXIgPSBuZXcgRm91bmRhdGlvbi5UaW1lcih0aGlzLiRlbGVtZW50LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxuICAgICAgICAgIGluZmluaXRlOiBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBTZXRzIHdyYXBwZXIgYW5kIHNsaWRlIGhlaWdodHMgZm9yIHRoZSBvcmJpdC5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3ByZXBhcmVGb3JPcmJpdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVGb3JPcmJpdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc2V0V3JhcHBlckhlaWdodCgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRXcmFwcGVySGVpZ2h0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0V3JhcHBlckhlaWdodChjYikge1xuICAgICAgICAvL3Jld3JpdGUgdGhpcyB0byBgZm9yYCBsb29wXG4gICAgICAgIHZhciBtYXggPSAwLFxuICAgICAgICAgICAgdGVtcCxcbiAgICAgICAgICAgIGNvdW50ZXIgPSAwLFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0ZW1wID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgJCh0aGlzKS5hdHRyKCdkYXRhLXNsaWRlJywgY291bnRlcik7XG5cbiAgICAgICAgICBpZiAoX3RoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKVswXSAhPT0gX3RoaXMuJHNsaWRlcy5lcShjb3VudGVyKVswXSkge1xuICAgICAgICAgICAgLy9pZiBub3QgdGhlIGFjdGl2ZSBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgICAgICAgJCh0aGlzKS5jc3MoeyAncG9zaXRpb24nOiAncmVsYXRpdmUnLCAnZGlzcGxheSc6ICdub25lJyB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XG4gICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY291bnRlciA9PT0gdGhpcy4kc2xpZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuJHdyYXBwZXIuY3NzKHsgJ2hlaWdodCc6IG1heCB9KTsgLy9vbmx5IGNoYW5nZSB0aGUgd3JhcHBlciBoZWlnaHQgcHJvcGVydHkgb25jZS5cbiAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIGNiKG1heCk7XG4gICAgICAgICAgfSAvL2ZpcmUgY2FsbGJhY2sgd2l0aCBtYXggaGVpZ2h0IGRpbWVuc2lvbi5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogU2V0cyB0aGUgbWF4LWhlaWdodCBvZiBlYWNoIHNsaWRlLlxuICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0U2xpZGVIZWlnaHQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTbGlkZUhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQodGhpcykuY3NzKCdtYXgtaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBiYXNpY2FsbHkgZXZlcnl0aGluZyB3aXRoaW4gdGhlIGVsZW1lbnQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8qKk5vdyB1c2luZyBjdXN0b20gZXZlbnQgLSB0aGFua3MgdG86KipcbiAgICAgICAgLy8qKiAgICAgIFlvaGFpIEFyYXJhdCBvZiBUb3JvbnRvICAgICAgKipcbiAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy5yZXNpemVtZS56Zi50cmlnZ2VyJykub24oe1xuICAgICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zd2lwZSkge1xuICAgICAgICAgICAgdGhpcy4kc2xpZGVzLm9mZignc3dpcGVsZWZ0LnpmLm9yYml0IHN3aXBlcmlnaHQuemYub3JiaXQnKS5vbignc3dpcGVsZWZ0LnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTtcbiAgICAgICAgICAgIH0pLm9uKCdzd2lwZXJpZ2h0LnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTbGlkZShmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuJHNsaWRlcy5vbignY2xpY2suemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicsIF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgICAgICAgX3RoaXMudGltZXJbX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyAncGF1c2UnIDogJ3N0YXJ0J10oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWVudGVyLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnBhdXNlKCk7XG4gICAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpIHtcbiAgICAgICAgICAgIHZhciAkY29udHJvbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLm5leHRDbGFzcyArICcsIC4nICsgdGhpcy5vcHRpb25zLnByZXZDbGFzcyk7XG4gICAgICAgICAgICAkY29udHJvbHMuYXR0cigndGFiaW5kZXgnLCAwKVxuICAgICAgICAgICAgLy9hbHNvIG5lZWQgdG8gaGFuZGxlIGVudGVyL3JldHVybiBhbmQgc3BhY2ViYXIga2V5IHByZXNzZXNcbiAgICAgICAgICAgIC5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKCQodGhpcykuaGFzQ2xhc3MoX3RoaXMub3B0aW9ucy5uZXh0Q2xhc3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xuICAgICAgICAgICAgdGhpcy4kYnVsbGV0cy5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gLy9pZiB0aGlzIGlzIGFjdGl2ZSwga2ljayBvdXQgb2YgZnVuY3Rpb24uXG4gICAgICAgICAgICAgIHZhciBpZHggPSAkKHRoaXMpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXG4gICAgICAgICAgICAgICAgICAkc2xpZGUgPSBfdGhpcy4kc2xpZGVzLmVxKGlkeCk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUobHRyLCAkc2xpZGUsIGlkeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFjY2Vzc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuJHdyYXBwZXIuYWRkKHRoaXMuJGJ1bGxldHMpLm9uKCdrZXlkb3duLnpmLm9yYml0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnT3JiaXQnLCB7XG4gICAgICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYgYnVsbGV0IGlzIGZvY3VzZWQsIG1ha2Ugc3VyZSBmb2N1cyBtb3Zlc1xuICAgICAgICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy4kYnVsbGV0cy5maWx0ZXIoJy5pcy1hY3RpdmUnKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBSZXNldHMgT3JiaXQgc28gaXQgY2FuIGJlIHJlaW5pdGlhbGl6ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Jlc2V0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXQoKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoZXJlIGFyZSBubyBzbGlkZXMgKGZpcnN0IHJ1bilcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLiRzbGlkZXMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy4kc2xpZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgb2xkIGV2ZW50c1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYub3JiaXQnKS5maW5kKCcqJykub2ZmKCcuemYub3JiaXQnKTtcblxuICAgICAgICAgIC8vIFJlc3RhcnQgdGltZXIgaWYgYXV0b1BsYXkgaXMgZW5hYmxlZFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIucmVzdGFydCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlc2V0IGFsbCBzbGlkZGVzXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAkKGVsKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWFjdGl2ZSBpcy1pbicpLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpLmhpZGUoKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIFNob3cgdGhlIGZpcnN0IHNsaWRlXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmZpcnN0KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLnNob3coKTtcblxuICAgICAgICAgIC8vIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmdcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3NsaWRlY2hhbmdlLnpmLm9yYml0JywgW3RoaXMuJHNsaWRlcy5maXJzdCgpXSk7XG5cbiAgICAgICAgICAvLyBTZWxlY3QgZmlyc3QgYnVsbGV0IGlmIGJ1bGxldHMgYXJlIHByZXNlbnRcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1bGxldHMoMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHNsaWRlIHRvIGEgbmV3IG9uZS5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNMVFIgLSBmbGFnIGlmIHRoZSBzbGlkZSBzaG91bGQgbW92ZSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gY2hvc2VuU2xpZGUgLSB0aGUgalF1ZXJ5IGVsZW1lbnQgb2YgdGhlIHNsaWRlIHRvIHNob3cgbmV4dCwgaWYgb25lIGlzIHNlbGVjdGVkLlxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBuZXcgc2xpZGUgaW4gaXRzIGNvbGxlY3Rpb24sIGlmIG9uZSBjaG9zZW4uXG4gICAgICAqIEBmaXJlcyBPcmJpdCNzbGlkZWNoYW5nZVxuICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2NoYW5nZVNsaWRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VTbGlkZShpc0xUUiwgY2hvc2VuU2xpZGUsIGlkeCkge1xuICAgICAgICBpZiAoIXRoaXMuJHNsaWRlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBEb24ndCBmcmVhayBvdXQgaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBjbGVhbnVwXG4gICAgICAgIHZhciAkY3VyU2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZXEoMCk7XG5cbiAgICAgICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vaWYgdGhlIHNsaWRlIGlzIGN1cnJlbnRseSBhbmltYXRpbmcsIGtpY2sgb3V0IG9mIHRoZSBmdW5jdGlvblxuXG4gICAgICAgIHZhciAkZmlyc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5maXJzdCgpLFxuICAgICAgICAgICAgJGxhc3RTbGlkZSA9IHRoaXMuJHNsaWRlcy5sYXN0KCksXG4gICAgICAgICAgICBkaXJJbiA9IGlzTFRSID8gJ1JpZ2h0JyA6ICdMZWZ0JyxcbiAgICAgICAgICAgIGRpck91dCA9IGlzTFRSID8gJ0xlZnQnIDogJ1JpZ2h0JyxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgICRuZXdTbGlkZTtcblxuICAgICAgICBpZiAoIWNob3NlblNsaWRlKSB7XG4gICAgICAgICAgLy9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxuICAgICAgICAgICRuZXdTbGlkZSA9IGlzTFRSID8gLy9pZiB3cmFwcGluZyBlbmFibGVkLCBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgYSBgbmV4dGAgb3IgYHByZXZgIHNpYmxpbmcsIGlmIG5vdCwgc2VsZWN0IHRoZSBmaXJzdCBvciBsYXN0IHNsaWRlIHRvIGZpbGwgaW4uIGlmIHdyYXBwaW5nIG5vdCBlbmFibGVkLCBhdHRlbXB0IHRvIHNlbGVjdCBgbmV4dGAgb3IgYHByZXZgLCBpZiB0aGVyZSdzIG5vdGhpbmcgdGhlcmUsIHRoZSBmdW5jdGlvbiB3aWxsIGtpY2sgb3V0IG9uIG5leHQgc3RlcC4gQ1JBWlkgTkVTVEVEIFRFUk5BUklFUyEhISEhXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5uZXh0KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGggPyAkY3VyU2xpZGUubmV4dCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykgOiAkZmlyc3RTbGlkZSA6ICRjdXJTbGlkZS5uZXh0KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSA6IC8vcGljayBuZXh0IHNsaWRlIGlmIG1vdmluZyBsZWZ0IHRvIHJpZ2h0XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldignLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykgOiAkbGFzdFNsaWRlIDogJGN1clNsaWRlLnByZXYoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOyAvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRuZXdTbGlkZSA9IGNob3NlblNsaWRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRuZXdTbGlkZS5sZW5ndGgpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAqIFRyaWdnZXJzIGJlZm9yZSB0aGUgbmV4dCBzbGlkZSBzdGFydHMgYW5pbWF0aW5nIGluIGFuZCBvbmx5IGlmIGEgbmV4dCBzbGlkZSBoYXMgYmVlbiBmb3VuZC5cbiAgICAgICAgICAqIEBldmVudCBPcmJpdCNiZWZvcmVzbGlkZWNoYW5nZVxuICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdiZWZvcmVzbGlkZWNoYW5nZS56Zi5vcmJpdCcsIFskY3VyU2xpZGUsICRuZXdTbGlkZV0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XG4gICAgICAgICAgICBpZHggPSBpZHggfHwgdGhpcy4kc2xpZGVzLmluZGV4KCRuZXdTbGlkZSk7IC8vZ3JhYiBpbmRleCB0byB1cGRhdGUgYnVsbGV0c1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQnVsbGV0cyhpZHgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudXNlTVVJICYmICF0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpIHtcbiAgICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbigkbmV3U2xpZGUuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmNzcyh7ICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsICd0b3AnOiAwIH0pLCB0aGlzLm9wdGlvbnNbJ2FuaW1JbkZyb20nICsgZGlySW5dLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICRuZXdTbGlkZS5jc3MoeyAncG9zaXRpb24nOiAncmVsYXRpdmUnLCAnZGlzcGxheSc6ICdibG9jaycgfSkuYXR0cignYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQoJGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKSwgdGhpcy5vcHRpb25zWydhbmltT3V0VG8nICsgZGlyT3V0XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICFfdGhpcy50aW1lci5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2RvIHN0dWZmP1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWluJykucmVtb3ZlQXR0cignYXJpYS1saXZlJykuaGlkZSgpO1xuICAgICAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJykuc2hvdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiAhdGhpcy50aW1lci5pc1BhdXNlZCkge1xuICAgICAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgKiBUcmlnZ2VycyB3aGVuIHRoZSBzbGlkZSBoYXMgZmluaXNoZWQgYW5pbWF0aW5nIGluLlxuICAgICAgICAgICogQGV2ZW50IE9yYml0I3NsaWRlY2hhbmdlXG4gICAgICAgICAgKi9cbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3NsaWRlY2hhbmdlLnpmLm9yYml0JywgWyRuZXdTbGlkZV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBVcGRhdGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJ1bGxldHMsIGlmIGRpc3BsYXllZC5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2xpZGUuXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZUJ1bGxldHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCdWxsZXRzKGlkeCkge1xuICAgICAgICB2YXIgJG9sZEJ1bGxldCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKCcuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmJsdXIoKSxcbiAgICAgICAgICAgIHNwYW4gPSAkb2xkQnVsbGV0LmZpbmQoJ3NwYW46bGFzdCcpLmRldGFjaCgpLFxuICAgICAgICAgICAgJG5ld0J1bGxldCA9IHRoaXMuJGJ1bGxldHMuZXEoaWR4KS5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXBwZW5kKHNwYW4pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogRGVzdHJveXMgdGhlIGNhcm91c2VsIGFuZCBoaWRlcyB0aGUgZWxlbWVudC5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJy56Zi5vcmJpdCcpLmZpbmQoJyonKS5vZmYoJy56Zi5vcmJpdCcpLmVuZCgpLmhpZGUoKTtcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBPcmJpdDtcbiAgfSgpO1xuXG4gIE9yYml0LmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICogVGVsbHMgdGhlIEpTIHRvIGxvb2sgZm9yIGFuZCBsb2FkQnVsbGV0cy5cbiAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIGJ1bGxldHM6IHRydWUsXG4gICAgLyoqXG4gICAgKiBUZWxscyB0aGUgSlMgdG8gYXBwbHkgZXZlbnQgbGlzdGVuZXJzIHRvIG5hdiBidXR0b25zXG4gICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgKi9cbiAgICBuYXZCdXR0b25zOiB0cnVlLFxuICAgIC8qKlxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKiBAZGVmYXVsdCAnc2xpZGUtaW4tcmlnaHQnXG4gICAgKi9cbiAgICBhbmltSW5Gcm9tUmlnaHQ6ICdzbGlkZS1pbi1yaWdodCcsXG4gICAgLyoqXG4gICAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqIEBkZWZhdWx0ICdzbGlkZS1vdXQtcmlnaHQnXG4gICAgKi9cbiAgICBhbmltT3V0VG9SaWdodDogJ3NsaWRlLW91dC1yaWdodCcsXG4gICAgLyoqXG4gICAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqIEBkZWZhdWx0ICdzbGlkZS1pbi1sZWZ0J1xuICAgICpcbiAgICAqL1xuICAgIGFuaW1JbkZyb21MZWZ0OiAnc2xpZGUtaW4tbGVmdCcsXG4gICAgLyoqXG4gICAgKiBtb3Rpb24tdWkgYW5pbWF0aW9uIGNsYXNzIHRvIGFwcGx5XG4gICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqIEBkZWZhdWx0ICdzbGlkZS1vdXQtbGVmdCdcbiAgICAqL1xuICAgIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXG4gICAgLyoqXG4gICAgKiBBbGxvd3MgT3JiaXQgdG8gYXV0b21hdGljYWxseSBhbmltYXRlIG9uIHBhZ2UgbG9hZC5cbiAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIGF1dG9QbGF5OiB0cnVlLFxuICAgIC8qKlxuICAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCBiZXR3ZWVuIHNsaWRlIHRyYW5zaXRpb25zXG4gICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBkZWZhdWx0IDUwMDBcbiAgICAqL1xuICAgIHRpbWVyRGVsYXk6IDUwMDAsXG4gICAgLyoqXG4gICAgKiBBbGxvd3MgT3JiaXQgdG8gaW5maW5pdGVseSBsb29wIHRocm91Z2ggdGhlIHNsaWRlc1xuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgaW5maW5pdGVXcmFwOiB0cnVlLFxuICAgIC8qKlxuICAgICogQWxsb3dzIHRoZSBPcmJpdCBzbGlkZXMgdG8gYmluZCB0byBzd2lwZSBldmVudHMgZm9yIG1vYmlsZSwgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCB1dGlsIGxpYnJhcnlcbiAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAqL1xuICAgIHN3aXBlOiB0cnVlLFxuICAgIC8qKlxuICAgICogQWxsb3dzIHRoZSB0aW1pbmcgZnVuY3Rpb24gdG8gcGF1c2UgYW5pbWF0aW9uIG9uIGhvdmVyLlxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuICAgIC8qKlxuICAgICogQWxsb3dzIE9yYml0IHRvIGJpbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHRoZSBzbGlkZXIsIHRvIGFuaW1hdGUgZnJhbWVzIHdpdGggYXJyb3cga2V5c1xuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgYWNjZXNzaWJsZTogdHJ1ZSxcbiAgICAvKipcbiAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lciBvZiBPcmJpdFxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKiBAZGVmYXVsdCAnb3JiaXQtY29udGFpbmVyJ1xuICAgICovXG4gICAgY29udGFpbmVyQ2xhc3M6ICdvcmJpdC1jb250YWluZXInLFxuICAgIC8qKlxuICAgICogQ2xhc3MgYXBwbGllZCB0byBpbmRpdmlkdWFsIHNsaWRlcy5cbiAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICogQGRlZmF1bHQgJ29yYml0LXNsaWRlJ1xuICAgICovXG4gICAgc2xpZGVDbGFzczogJ29yYml0LXNsaWRlJyxcbiAgICAvKipcbiAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGJ1bGxldCBjb250YWluZXIuIFlvdSdyZSB3ZWxjb21lLlxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKiBAZGVmYXVsdCAnb3JiaXQtYnVsbGV0cydcbiAgICAqL1xuICAgIGJveE9mQnVsbGV0czogJ29yYml0LWJ1bGxldHMnLFxuICAgIC8qKlxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYG5leHRgIG5hdmlnYXRpb24gYnV0dG9uLlxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKiBAZGVmYXVsdCAnb3JiaXQtbmV4dCdcbiAgICAqL1xuICAgIG5leHRDbGFzczogJ29yYml0LW5leHQnLFxuICAgIC8qKlxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYHByZXZpb3VzYCBuYXZpZ2F0aW9uIGJ1dHRvbi5cbiAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICogQGRlZmF1bHQgJ29yYml0LXByZXZpb3VzJ1xuICAgICovXG4gICAgcHJldkNsYXNzOiAnb3JiaXQtcHJldmlvdXMnLFxuICAgIC8qKlxuICAgICogQm9vbGVhbiB0byBmbGFnIHRoZSBqcyB0byB1c2UgbW90aW9uIHVpIGNsYXNzZXMgb3Igbm90LiBEZWZhdWx0IHRvIHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LlxuICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICovXG4gICAgdXNlTVVJOiB0cnVlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oT3JiaXQsICdPcmJpdCcpO1xufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLm9yYml0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 12 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * ResponsiveMenu module.\n   * @module foundation.responsiveMenu\n   * @requires foundation.util.triggers\n   * @requires foundation.util.mediaQuery\n   */\n\n  var ResponsiveMenu = function () {\n    /**\n     * Creates a new instance of a responsive menu.\n     * @class\n     * @fires ResponsiveMenu#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function ResponsiveMenu(element, options) {\n      _classCallCheck(this, ResponsiveMenu);\n\n      this.$element = $(element);\n      this.rules = this.$element.data('responsive-menu');\n      this.currentMq = null;\n      this.currentPlugin = null;\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'ResponsiveMenu');\n    }\n\n    /**\n     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.\n     * @function\n     * @private\n     */\n\n\n    _createClass(ResponsiveMenu, [{\n      key: '_init',\n      value: function _init() {\n        // The first time an Interchange plugin is initialized, this.rules is converted from a string of \"classes\" to an object of rules\n        if (typeof this.rules === 'string') {\n          var rulesTree = {};\n\n          // Parse rules from \"classes\" pulled from data attribute\n          var rules = this.rules.split(' ');\n\n          // Iterate through every rule found\n          for (var i = 0; i < rules.length; i++) {\n            var rule = rules[i].split('-');\n            var ruleSize = rule.length > 1 ? rule[0] : 'small';\n            var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\n\n            if (MenuPlugins[rulePlugin] !== null) {\n              rulesTree[ruleSize] = MenuPlugins[rulePlugin];\n            }\n          }\n\n          this.rules = rulesTree;\n        }\n\n        if (!$.isEmptyObject(this.rules)) {\n          this._checkMediaQueries();\n        }\n        // Add data-mutate since children may need it.\n        this.$element.attr('data-mutate', this.$element.attr('data-mutate') || Foundation.GetYoDigits(6, 'responsive-menu'));\n      }\n\n      /**\n       * Initializes events for the Menu.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        $(window).on('changed.zf.mediaquery', function () {\n          _this._checkMediaQueries();\n        });\n        // $(window).on('resize.zf.ResponsiveMenu', function() {\n        //   _this._checkMediaQueries();\n        // });\n      }\n\n      /**\n       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_checkMediaQueries',\n      value: function _checkMediaQueries() {\n        var matchedMq,\n            _this = this;\n        // Iterate through each rule and find the last matching rule\n        $.each(this.rules, function (key) {\n          if (Foundation.MediaQuery.atLeast(key)) {\n            matchedMq = key;\n          }\n        });\n\n        // No match? No dice\n        if (!matchedMq) return;\n\n        // Plugin already initialized? We good\n        if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;\n\n        // Remove existing plugin-specific CSS classes\n        $.each(MenuPlugins, function (key, value) {\n          _this.$element.removeClass(value.cssClass);\n        });\n\n        // Add the CSS class for the new plugin\n        this.$element.addClass(this.rules[matchedMq].cssClass);\n\n        // Create an instance of the new plugin\n        if (this.currentPlugin) this.currentPlugin.destroy();\n        this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\n      }\n\n      /**\n       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.currentPlugin.destroy();\n        $(window).off('.zf.ResponsiveMenu');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return ResponsiveMenu;\n  }();\n\n  ResponsiveMenu.defaults = {};\n\n  // The plugin matches the plugin classes with these plugin instances.\n  var MenuPlugins = {\n    dropdown: {\n      cssClass: 'dropdown',\n      plugin: Foundation._plugins['dropdown-menu'] || null\n    },\n    drilldown: {\n      cssClass: 'drilldown',\n      plugin: Foundation._plugins['drilldown'] || null\n    },\n    accordion: {\n      cssClass: 'accordion-menu',\n      plugin: Foundation._plugins['accordion-menu'] || null\n    }\n  };\n\n  // Window exports\n  Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnUuanM/MGZhZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlTWVudVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKi9cblxuICB2YXIgUmVzcG9uc2l2ZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZU1lbnUjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXNwb25zaXZlTWVudShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZU1lbnUpO1xuXG4gICAgICB0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcbiAgICAgIHRoaXMucnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtbWVudScpO1xuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Jlc3BvbnNpdmVNZW51Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1lbnUgYnkgcGFyc2luZyB0aGUgY2xhc3NlcyBmcm9tIHRoZSAnZGF0YS1SZXNwb25zaXZlTWVudScgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlTWVudSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgYW4gSW50ZXJjaGFuZ2UgcGx1Z2luIGlzIGluaXRpYWxpemVkLCB0aGlzLnJ1bGVzIGlzIGNvbnZlcnRlZCBmcm9tIGEgc3RyaW5nIG9mIFwiY2xhc3Nlc1wiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHJ1bGVzVHJlZSA9IHt9O1xuXG4gICAgICAgICAgLy8gUGFyc2UgcnVsZXMgZnJvbSBcImNsYXNzZXNcIiBwdWxsZWQgZnJvbSBkYXRhIGF0dHJpYnV0ZVxuICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgdmFyIHJ1bGVTaXplID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVswXSA6ICdzbWFsbCc7XG4gICAgICAgICAgICB2YXIgcnVsZVBsdWdpbiA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMV0gOiBydWxlWzBdO1xuXG4gICAgICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xuICAgICAgICAgIHRoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGRhdGEtbXV0YXRlIHNpbmNlIGNoaWxkcmVuIG1heSBuZWVkIGl0LlxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtbXV0YXRlJywgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLW11dGF0ZScpIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3Jlc3BvbnNpdmUtbWVudScpKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gJCh3aW5kb3cpLm9uKCdyZXNpemUuemYuUmVzcG9uc2l2ZU1lbnUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NoZWNrTWVkaWFRdWVyaWVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XG4gICAgICAgIHZhciBtYXRjaGVkTXEsXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIGZpbmQgdGhlIGxhc3QgbWF0Y2hpbmcgcnVsZVxuICAgICAgICAkLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChrZXkpKSB7XG4gICAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBObyBtYXRjaD8gTm8gZGljZVxuICAgICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47XG5cbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xuICAgICAgICAkLmVhY2goTWVudVBsdWdpbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQbHVnaW4gPSBuZXcgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbih0aGlzLiRlbGVtZW50LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgICAkKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZU1lbnUnKTtcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZXNwb25zaXZlTWVudTtcbiAgfSgpO1xuXG4gIFJlc3BvbnNpdmVNZW51LmRlZmF1bHRzID0ge307XG5cbiAgLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXG4gIHZhciBNZW51UGx1Z2lucyA9IHtcbiAgICBkcm9wZG93bjoge1xuICAgICAgY3NzQ2xhc3M6ICdkcm9wZG93bicsXG4gICAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbJ2Ryb3Bkb3duLW1lbnUnXSB8fCBudWxsXG4gICAgfSxcbiAgICBkcmlsbGRvd246IHtcbiAgICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcbiAgICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snZHJpbGxkb3duJ10gfHwgbnVsbFxuICAgIH0sXG4gICAgYWNjb3JkaW9uOiB7XG4gICAgICBjc3NDbGFzczogJ2FjY29yZGlvbi1tZW51JyxcbiAgICAgIHBsdWdpbjogRm91bmRhdGlvbi5fcGx1Z2luc1snYWNjb3JkaW9uLW1lbnUnXSB8fCBudWxsXG4gICAgfVxuICB9O1xuXG4gIC8vIFdpbmRvdyBleHBvcnRzXG4gIEZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVNZW51LCAnUmVzcG9uc2l2ZU1lbnUnKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5yZXNwb25zaXZlTWVudS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * ResponsiveToggle module.\n   * @module foundation.responsiveToggle\n   * @requires foundation.util.mediaQuery\n   */\n\n  var ResponsiveToggle = function () {\n    /**\n     * Creates a new instance of Tab Bar.\n     * @class\n     * @fires ResponsiveToggle#init\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function ResponsiveToggle(element, options) {\n      _classCallCheck(this, ResponsiveToggle);\n\n      this.$element = $(element);\n      this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'ResponsiveToggle');\n    }\n\n    /**\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\n     * @function\n     * @private\n     */\n\n\n    _createClass(ResponsiveToggle, [{\n      key: '_init',\n      value: function _init() {\n        var targetID = this.$element.data('responsive-toggle');\n        if (!targetID) {\n          console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');\n        }\n\n        this.$targetMenu = $('#' + targetID);\n        this.$toggler = this.$element.find('[data-toggle]').filter(function () {\n          var target = $(this).data('toggle');\n          return target === targetID || target === \"\";\n        });\n        this.options = $.extend({}, this.options, this.$targetMenu.data());\n\n        // If they were set, parse the animation classes\n        if (this.options.animate) {\n          var input = this.options.animate.split(' ');\n\n          this.animationIn = input[0];\n          this.animationOut = input[1] || null;\n        }\n\n        this._update();\n      }\n\n      /**\n       * Adds necessary event handlers for the tab bar to work.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        this._updateMqHandler = this._update.bind(this);\n\n        $(window).on('changed.zf.mediaquery', this._updateMqHandler);\n\n        this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));\n      }\n\n      /**\n       * Checks the current media query to determine if the tab bar should be visible or hidden.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_update',\n      value: function _update() {\n        // Mobile\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\n          this.$element.show();\n          this.$targetMenu.hide();\n        }\n\n        // Desktop\n        else {\n            this.$element.hide();\n            this.$targetMenu.show();\n          }\n      }\n\n      /**\n       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\n       * @function\n       * @fires ResponsiveToggle#toggled\n       */\n\n    }, {\n      key: 'toggleMenu',\n      value: function toggleMenu() {\n        var _this2 = this;\n\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\n          /**\n           * Fires when the element attached to the tab bar toggles.\n           * @event ResponsiveToggle#toggled\n           */\n          if (this.options.animate) {\n            if (this.$targetMenu.is(':hidden')) {\n              Foundation.Motion.animateIn(this.$targetMenu, this.animationIn, function () {\n                _this2.$element.trigger('toggled.zf.responsiveToggle');\n                _this2.$targetMenu.find('[data-mutate]').triggerHandler('mutateme.zf.trigger');\n              });\n            } else {\n              Foundation.Motion.animateOut(this.$targetMenu, this.animationOut, function () {\n                _this2.$element.trigger('toggled.zf.responsiveToggle');\n              });\n            }\n          } else {\n            this.$targetMenu.toggle(0);\n            this.$targetMenu.find('[data-mutate]').trigger('mutateme.zf.trigger');\n            this.$element.trigger('toggled.zf.responsiveToggle');\n          }\n        }\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.off('.zf.responsiveToggle');\n        this.$toggler.off('.zf.responsiveToggle');\n\n        $(window).off('changed.zf.mediaquery', this._updateMqHandler);\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return ResponsiveToggle;\n  }();\n\n  ResponsiveToggle.defaults = {\n    /**\n     * The breakpoint after which the menu is always shown, and the tab bar is hidden.\n     * @option\n     * @type {string}\n     * @default 'medium'\n     */\n    hideFor: 'medium',\n\n    /**\n     * To decide if the toggle should be animated or not.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    animate: false\n  };\n\n  // Window exports\n  Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZS5qcz83OTllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIFJlc3BvbnNpdmVUb2dnbGUgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAgICovXG5cbiAgdmFyIFJlc3BvbnNpdmVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIHRhYiBiYXIgZnVuY3Rpb25hbGl0eSB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzcG9uc2l2ZVRvZ2dsZShlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzcG9uc2l2ZVRvZ2dsZSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgdGhpcy5fZXZlbnRzKCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Jlc3BvbnNpdmVUb2dnbGUnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFiIGJhciBieSBmaW5kaW5nIHRoZSB0YXJnZXQgZWxlbWVudCwgdG9nZ2xpbmcgZWxlbWVudCwgYW5kIHJ1bm5pbmcgdXBkYXRlKCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFJlc3BvbnNpdmVUb2dnbGUsIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHZhciB0YXJnZXRJRCA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtcbiAgICAgICAgaWYgKCF0YXJnZXRJRCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJHRhcmdldE1lbnUgPSAkKCcjJyArIHRhcmdldElEKTtcbiAgICAgICAgdGhpcy4kdG9nZ2xlciA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdG9nZ2xlXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQodGhpcykuZGF0YSgndG9nZ2xlJyk7XG4gICAgICAgICAgcmV0dXJuIHRhcmdldCA9PT0gdGFyZ2V0SUQgfHwgdGFyZ2V0ID09PSBcIlwiO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcy4kdGFyZ2V0TWVudS5kYXRhKCkpO1xuXG4gICAgICAgIC8vIElmIHRoZXkgd2VyZSBzZXQsIHBhcnNlIHRoZSBhbmltYXRpb24gY2xhc3Nlc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgdGhpcy5hbmltYXRpb25JbiA9IGlucHV0WzBdO1xuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uT3V0ID0gaW5wdXRbMV0gfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgdGFiIGJhciB0byB3b3JrLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1xSGFuZGxlciA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgICAgICQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcblxuICAgICAgICB0aGlzLiR0b2dnbGVyLm9uKCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBtZWRpYSBxdWVyeSB0byBkZXRlcm1pbmUgaWYgdGhlIHRhYiBiYXIgc2hvdWxkIGJlIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdXBkYXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlKCkge1xuICAgICAgICAvLyBNb2JpbGVcbiAgICAgICAgaWYgKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2t0b3BcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGVNZW51JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICBpZiAoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIgdG9nZ2xlcy5cbiAgICAgICAgICAgKiBAZXZlbnQgUmVzcG9uc2l2ZVRvZ2dsZSN0b2dnbGVkXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbmltYXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kdGFyZ2V0TWVudS5pcygnOmhpZGRlbicpKSB7XG4gICAgICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiR0YXJnZXRNZW51LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICAgICAgICAgIF90aGlzMi4kdGFyZ2V0TWVudS5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJHRhcmdldE1lbnUsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCk7XG4gICAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LmZpbmQoJ1tkYXRhLW11dGF0ZV0nKS50cmlnZ2VyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xuICAgICAgICB0aGlzLiR0b2dnbGVyLm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcblxuICAgICAgICAkKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl91cGRhdGVNcUhhbmRsZXIpO1xuXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVzcG9uc2l2ZVRvZ2dsZTtcbiAgfSgpO1xuXG4gIFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdtZWRpdW0nXG4gICAgICovXG4gICAgaGlkZUZvcjogJ21lZGl1bScsXG5cbiAgICAvKipcbiAgICAgKiBUbyBkZWNpZGUgaWYgdGhlIHRvZ2dsZSBzaG91bGQgYmUgYW5pbWF0ZWQgb3Igbm90LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGFuaW1hdGU6IGZhbHNlXG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oUmVzcG9uc2l2ZVRvZ2dsZSwgJ1Jlc3BvbnNpdmVUb2dnbGUnKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Reveal module.\n   * @module foundation.reveal\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.box\n   * @requires foundation.util.triggers\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.motion if using animations\n   */\n\n  var Reveal = function () {\n    /**\n     * Creates a new instance of Reveal.\n     * @class\n     * @param {jQuery} element - jQuery object to use for the modal.\n     * @param {Object} options - optional parameters.\n     */\n    function Reveal(element, options) {\n      _classCallCheck(this, Reveal);\n\n      this.$element = element;\n      this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);\n      this._init();\n\n      Foundation.registerPlugin(this, 'Reveal');\n      Foundation.Keyboard.register('Reveal', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ESCAPE': 'close'\n      });\n    }\n\n    /**\n     * Initializes the modal by adding the overlay and close buttons, (if selected).\n     * @private\n     */\n\n\n    _createClass(Reveal, [{\n      key: '_init',\n      value: function _init() {\n        this.id = this.$element.attr('id');\n        this.isActive = false;\n        this.cached = { mq: Foundation.MediaQuery.current };\n        this.isMobile = mobileSniff();\n\n        this.$anchor = $('[data-open=\"' + this.id + '\"]').length ? $('[data-open=\"' + this.id + '\"]') : $('[data-toggle=\"' + this.id + '\"]');\n        this.$anchor.attr({\n          'aria-controls': this.id,\n          'aria-haspopup': true,\n          'tabindex': 0\n        });\n\n        if (this.options.fullScreen || this.$element.hasClass('full')) {\n          this.options.fullScreen = true;\n          this.options.overlay = false;\n        }\n        if (this.options.overlay && !this.$overlay) {\n          this.$overlay = this._makeOverlay(this.id);\n        }\n\n        this.$element.attr({\n          'role': 'dialog',\n          'aria-hidden': true,\n          'data-yeti-box': this.id,\n          'data-resize': this.id\n        });\n\n        if (this.$overlay) {\n          this.$element.detach().appendTo(this.$overlay);\n        } else {\n          this.$element.detach().appendTo($(this.options.appendTo));\n          this.$element.addClass('without-overlay');\n        }\n        this._events();\n        if (this.options.deepLink && window.location.hash === '#' + this.id) {\n          $(window).one('load.zf.reveal', this.open.bind(this));\n        }\n      }\n\n      /**\n       * Creates an overlay div to display behind the modal.\n       * @private\n       */\n\n    }, {\n      key: '_makeOverlay',\n      value: function _makeOverlay() {\n        return $('<div></div>').addClass('reveal-overlay').appendTo(this.options.appendTo);\n      }\n\n      /**\n       * Updates position of modal\n       * TODO:  Figure out if we actually need to cache these values or if it doesn't matter\n       * @private\n       */\n\n    }, {\n      key: '_updatePosition',\n      value: function _updatePosition() {\n        var width = this.$element.outerWidth();\n        var outerWidth = $(window).width();\n        var height = this.$element.outerHeight();\n        var outerHeight = $(window).height();\n        var left, top;\n        if (this.options.hOffset === 'auto') {\n          left = parseInt((outerWidth - width) / 2, 10);\n        } else {\n          left = parseInt(this.options.hOffset, 10);\n        }\n        if (this.options.vOffset === 'auto') {\n          if (height > outerHeight) {\n            top = parseInt(Math.min(100, outerHeight / 10), 10);\n          } else {\n            top = parseInt((outerHeight - height) / 4, 10);\n          }\n        } else {\n          top = parseInt(this.options.vOffset, 10);\n        }\n        this.$element.css({ top: top + 'px' });\n        // only worry about left if we don't have an overlay or we havea  horizontal offset,\n        // otherwise we're perfectly in the middle\n        if (!this.$overlay || this.options.hOffset !== 'auto') {\n          this.$element.css({ left: left + 'px' });\n          this.$element.css({ margin: '0px' });\n        }\n      }\n\n      /**\n       * Adds event handlers for the modal.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this2 = this;\n\n        var _this = this;\n\n        this.$element.on({\n          'open.zf.trigger': this.open.bind(this),\n          'close.zf.trigger': function (event, $element) {\n            if (event.target === _this.$element[0] || $(event.target).parents('[data-closable]')[0] === $element) {\n              // only close reveal when it's explicitly called\n              return _this2.close.apply(_this2);\n            }\n          },\n          'toggle.zf.trigger': this.toggle.bind(this),\n          'resizeme.zf.trigger': function () {\n            _this._updatePosition();\n          }\n        });\n\n        if (this.$anchor.length) {\n          this.$anchor.on('keydown.zf.reveal', function (e) {\n            if (e.which === 13 || e.which === 32) {\n              e.stopPropagation();\n              e.preventDefault();\n              _this.open();\n            }\n          });\n        }\n\n        if (this.options.closeOnClick && this.options.overlay) {\n          this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {\n            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target) || !$.contains(document, e.target)) {\n              return;\n            }\n            _this.close();\n          });\n        }\n        if (this.options.deepLink) {\n          $(window).on('popstate.zf.reveal:' + this.id, this._handleState.bind(this));\n        }\n      }\n\n      /**\n       * Handles modal methods on back/forward button clicks or any other event that triggers popstate.\n       * @private\n       */\n\n    }, {\n      key: '_handleState',\n      value: function _handleState(e) {\n        if (window.location.hash === '#' + this.id && !this.isActive) {\n          this.open();\n        } else {\n          this.close();\n        }\n      }\n\n      /**\n       * Opens the modal controlled by `this.$anchor`, and closes all others by default.\n       * @function\n       * @fires Reveal#closeme\n       * @fires Reveal#open\n       */\n\n    }, {\n      key: 'open',\n      value: function open() {\n        var _this3 = this;\n\n        if (this.options.deepLink) {\n          var hash = '#' + this.id;\n\n          if (window.history.pushState) {\n            window.history.pushState(null, null, hash);\n          } else {\n            window.location.hash = hash;\n          }\n        }\n\n        this.isActive = true;\n\n        // Make elements invisible, but remove display: none so we can get size and positioning\n        this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);\n        if (this.options.overlay) {\n          this.$overlay.css({ 'visibility': 'hidden' }).show();\n        }\n\n        this._updatePosition();\n\n        this.$element.hide().css({ 'visibility': '' });\n\n        if (this.$overlay) {\n          this.$overlay.css({ 'visibility': '' }).hide();\n          if (this.$element.hasClass('fast')) {\n            this.$overlay.addClass('fast');\n          } else if (this.$element.hasClass('slow')) {\n            this.$overlay.addClass('slow');\n          }\n        }\n\n        if (!this.options.multipleOpened) {\n          /**\n           * Fires immediately before the modal opens.\n           * Closes any other modals that are currently open\n           * @event Reveal#closeme\n           */\n          this.$element.trigger('closeme.zf.reveal', this.id);\n        }\n\n        var _this = this;\n\n        function addRevealOpenClasses() {\n          if (_this.isMobile) {\n            if (!_this.originalScrollPos) {\n              _this.originalScrollPos = window.pageYOffset;\n            }\n            $('html, body').addClass('is-reveal-open');\n          } else {\n            $('body').addClass('is-reveal-open');\n          }\n        }\n        // Motion UI method of reveal\n        if (this.options.animationIn) {\n          (function () {\n            var afterAnimation = function () {\n              _this.$element.attr({\n                'aria-hidden': false,\n                'tabindex': -1\n              }).focus();\n              addRevealOpenClasses();\n              Foundation.Keyboard.trapFocus(_this.$element);\n            };\n\n            if (_this3.options.overlay) {\n              Foundation.Motion.animateIn(_this3.$overlay, 'fade-in');\n            }\n            Foundation.Motion.animateIn(_this3.$element, _this3.options.animationIn, function () {\n              if (_this3.$element) {\n                // protect against object having been removed\n                _this3.focusableElements = Foundation.Keyboard.findFocusable(_this3.$element);\n                afterAnimation();\n              }\n            });\n          })();\n        }\n        // jQuery method of reveal\n        else {\n            if (this.options.overlay) {\n              this.$overlay.show(0);\n            }\n            this.$element.show(this.options.showDelay);\n          }\n\n        // handle accessibility\n        this.$element.attr({\n          'aria-hidden': false,\n          'tabindex': -1\n        }).focus();\n        Foundation.Keyboard.trapFocus(this.$element);\n\n        /**\n         * Fires when the modal has successfully opened.\n         * @event Reveal#open\n         */\n        this.$element.trigger('open.zf.reveal');\n\n        addRevealOpenClasses();\n\n        setTimeout(function () {\n          _this3._extraHandlers();\n        }, 0);\n      }\n\n      /**\n       * Adds extra event handlers for the body and window if necessary.\n       * @private\n       */\n\n    }, {\n      key: '_extraHandlers',\n      value: function _extraHandlers() {\n        var _this = this;\n        if (!this.$element) {\n          return;\n        } // If we're in the middle of cleanup, don't freak out\n        this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);\n\n        if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {\n          $('body').on('click.zf.reveal', function (e) {\n            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target) || !$.contains(document, e.target)) {\n              return;\n            }\n            _this.close();\n          });\n        }\n\n        if (this.options.closeOnEsc) {\n          $(window).on('keydown.zf.reveal', function (e) {\n            Foundation.Keyboard.handleKey(e, 'Reveal', {\n              close: function () {\n                if (_this.options.closeOnEsc) {\n                  _this.close();\n                  _this.$anchor.focus();\n                }\n              }\n            });\n          });\n        }\n\n        // lock focus within modal while tabbing\n        this.$element.on('keydown.zf.reveal', function (e) {\n          var $target = $(this);\n          // handle keyboard event with keyboard util\n          Foundation.Keyboard.handleKey(e, 'Reveal', {\n            open: function () {\n              if (_this.$element.find(':focus').is(_this.$element.find('[data-close]'))) {\n                setTimeout(function () {\n                  // set focus back to anchor if close button has been activated\n                  _this.$anchor.focus();\n                }, 1);\n              } else if ($target.is(_this.focusableElements)) {\n                // dont't trigger if acual element has focus (i.e. inputs, links, ...)\n                _this.open();\n              }\n            },\n            close: function () {\n              if (_this.options.closeOnEsc) {\n                _this.close();\n                _this.$anchor.focus();\n              }\n            },\n            handled: function (preventDefault) {\n              if (preventDefault) {\n                e.preventDefault();\n              }\n            }\n          });\n        });\n      }\n\n      /**\n       * Closes the modal.\n       * @function\n       * @fires Reveal#closed\n       */\n\n    }, {\n      key: 'close',\n      value: function close() {\n        if (!this.isActive || !this.$element.is(':visible')) {\n          return false;\n        }\n        var _this = this;\n\n        // Motion UI method of hiding\n        if (this.options.animationOut) {\n          if (this.options.overlay) {\n            Foundation.Motion.animateOut(this.$overlay, 'fade-out', finishUp);\n          } else {\n            finishUp();\n          }\n\n          Foundation.Motion.animateOut(this.$element, this.options.animationOut);\n        }\n        // jQuery method of hiding\n        else {\n            if (this.options.overlay) {\n              this.$overlay.hide(0, finishUp);\n            } else {\n              finishUp();\n            }\n\n            this.$element.hide(this.options.hideDelay);\n          }\n\n        // Conditionals to remove extra event listeners added on open\n        if (this.options.closeOnEsc) {\n          $(window).off('keydown.zf.reveal');\n        }\n\n        if (!this.options.overlay && this.options.closeOnClick) {\n          $('body').off('click.zf.reveal');\n        }\n\n        this.$element.off('keydown.zf.reveal');\n\n        function finishUp() {\n          if (_this.isMobile) {\n            $('html, body').removeClass('is-reveal-open');\n            if (_this.originalScrollPos) {\n              $('body').scrollTop(_this.originalScrollPos);\n              _this.originalScrollPos = null;\n            }\n          } else {\n            $('body').removeClass('is-reveal-open');\n          }\n\n          Foundation.Keyboard.releaseFocus(_this.$element);\n\n          _this.$element.attr('aria-hidden', true);\n\n          /**\n          * Fires when the modal is done closing.\n          * @event Reveal#closed\n          */\n          _this.$element.trigger('closed.zf.reveal');\n        }\n\n        /**\n        * Resets the modal content\n        * This prevents a running video to keep going in the background\n        */\n        if (this.options.resetOnClose) {\n          this.$element.html(this.$element.html());\n        }\n\n        this.isActive = false;\n        if (_this.options.deepLink) {\n          if (window.history.replaceState) {\n            window.history.replaceState('', document.title, window.location.href.replace('#' + this.id, ''));\n          } else {\n            window.location.hash = '';\n          }\n        }\n      }\n\n      /**\n       * Toggles the open/closed state of a modal.\n       * @function\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle() {\n        if (this.isActive) {\n          this.close();\n        } else {\n          this.open();\n        }\n      }\n    }, {\n      key: 'destroy',\n\n\n      /**\n       * Destroys an instance of a modal.\n       * @function\n       */\n      value: function destroy() {\n        if (this.options.overlay) {\n          this.$element.appendTo($(this.options.appendTo)); // move $element outside of $overlay to prevent error unregisterPlugin()\n          this.$overlay.hide().off().remove();\n        }\n        this.$element.hide().off();\n        this.$anchor.off('.zf');\n        $(window).off('.zf.reveal:' + this.id);\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Reveal;\n  }();\n\n  Reveal.defaults = {\n    /**\n     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    animationIn: '',\n    /**\n     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    animationOut: '',\n    /**\n     * Time, in ms, to delay the opening of a modal after a click if no animation used.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    showDelay: 0,\n    /**\n     * Time, in ms, to delay the closing of a modal after a click if no animation used.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    hideDelay: 0,\n    /**\n     * Allows a click on the body/overlay to close the modal.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnClick: true,\n    /**\n     * Allows the modal to close if the user presses the `ESCAPE` key.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    closeOnEsc: true,\n    /**\n     * If true, allows multiple modals to be displayed at once.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    multipleOpened: false,\n    /**\n     * Distance, in pixels, the modal should push down from the top of the screen.\n     * @option\n     * @type {number|string}\n     * @default auto\n     */\n    vOffset: 'auto',\n    /**\n     * Distance, in pixels, the modal should push in from the side of the screen.\n     * @option\n     * @type {number|string}\n     * @default auto\n     */\n    hOffset: 'auto',\n    /**\n     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    fullScreen: false,\n    /**\n     * Percentage of screen height the modal should push up from the bottom of the view.\n     * @option\n     * @type {number}\n     * @default 10\n     */\n    btmOffsetPct: 10,\n    /**\n     * Allows the modal to generate an overlay div, which will cover the view when modal opens.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    overlay: true,\n    /**\n     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    resetOnClose: false,\n    /**\n     * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    deepLink: false,\n    /**\n    * Allows the modal to append to custom div.\n    * @option\n    * @type {string}\n    * @default \"body\"\n    */\n    appendTo: \"body\"\n\n  };\n\n  // Window exports\n  Foundation.plugin(Reveal, 'Reveal');\n\n  function iPhoneSniff() {\n    return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)\n    );\n  }\n\n  function androidSniff() {\n    return (/Android/.test(window.navigator.userAgent)\n    );\n  }\n\n  function mobileSniff() {\n    return iPhoneSniff() || androidSniff();\n  }\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ucmV2ZWFsLmpzPzNmNWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogUmV2ZWFsIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnJldmVhbFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uIGlmIHVzaW5nIGFuaW1hdGlvbnNcbiAgICovXG5cbiAgdmFyIFJldmVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJldmVhbC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGZvciB0aGUgbW9kYWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJldmVhbChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmV2ZWFsKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1JldmVhbCcpO1xuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignUmV2ZWFsJywge1xuICAgICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RhbCBieSBhZGRpbmcgdGhlIG92ZXJsYXkgYW5kIGNsb3NlIGJ1dHRvbnMsIChpZiBzZWxlY3RlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFJldmVhbCwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlZCA9IHsgbXE6IEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50IH07XG4gICAgICAgIHRoaXMuaXNNb2JpbGUgPSBtb2JpbGVTbmlmZigpO1xuXG4gICAgICAgIHRoaXMuJGFuY2hvciA9ICQoJ1tkYXRhLW9wZW49XCInICsgdGhpcy5pZCArICdcIl0nKS5sZW5ndGggPyAkKCdbZGF0YS1vcGVuPVwiJyArIHRoaXMuaWQgKyAnXCJdJykgOiAkKCdbZGF0YS10b2dnbGU9XCInICsgdGhpcy5pZCArICdcIl0nKTtcbiAgICAgICAgdGhpcy4kYW5jaG9yLmF0dHIoe1xuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogdGhpcy5pZCxcbiAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgJ3RhYmluZGV4JzogMFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gfHwgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZnVsbCcpKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5ICYmICF0aGlzLiRvdmVybGF5KSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheSA9IHRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAncm9sZSc6ICdkaWFsb2cnLFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiB0aGlzLmlkLFxuICAgICAgICAgICdkYXRhLXJlc2l6ZSc6IHRoaXMuaWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8oJCh0aGlzLm9wdGlvbnMuYXBwZW5kVG8pKTtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCd3aXRob3V0LW92ZXJsYXknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiB3aW5kb3cubG9jYXRpb24uaGFzaCA9PT0gJyMnICsgdGhpcy5pZCkge1xuICAgICAgICAgICQod2luZG93KS5vbmUoJ2xvYWQuemYucmV2ZWFsJywgdGhpcy5vcGVuLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhbiBvdmVybGF5IGRpdiB0byBkaXNwbGF5IGJlaGluZCB0aGUgbW9kYWwuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbWFrZU92ZXJsYXknLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlT3ZlcmxheSgpIHtcbiAgICAgICAgcmV0dXJuICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3JldmVhbC1vdmVybGF5JykuYXBwZW5kVG8odGhpcy5vcHRpb25zLmFwcGVuZFRvKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBVcGRhdGVzIHBvc2l0aW9uIG9mIG1vZGFsXG4gICAgICAgKiBUT0RPOiAgRmlndXJlIG91dCBpZiB3ZSBhY3R1YWxseSBuZWVkIHRvIGNhY2hlIHRoZXNlIHZhbHVlcyBvciBpZiBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3VwZGF0ZVBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgb3V0ZXJXaWR0aCA9ICQod2luZG93KS53aWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICB2YXIgb3V0ZXJIZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7XG4gICAgICAgIHZhciBsZWZ0LCB0b3A7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaE9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgbGVmdCA9IHBhcnNlSW50KChvdXRlcldpZHRoIC0gd2lkdGgpIC8gMiwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxlZnQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudk9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgaWYgKGhlaWdodCA+IG91dGVySGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSBwYXJzZUludChNYXRoLm1pbigxMDAsIG91dGVySGVpZ2h0IC8gMTApLCAxMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvcCA9IHBhcnNlSW50KChvdXRlckhlaWdodCAtIGhlaWdodCkgLyA0LCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoeyB0b3A6IHRvcCArICdweCcgfSk7XG4gICAgICAgIC8vIG9ubHkgd29ycnkgYWJvdXQgbGVmdCBpZiB3ZSBkb24ndCBoYXZlIGFuIG92ZXJsYXkgb3Igd2UgaGF2ZWEgIGhvcml6b250YWwgb2Zmc2V0LFxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UncmUgcGVyZmVjdGx5IGluIHRoZSBtaWRkbGVcbiAgICAgICAgaWYgKCF0aGlzLiRvdmVybGF5IHx8IHRoaXMub3B0aW9ucy5oT2Zmc2V0ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7IGxlZnQ6IGxlZnQgKyAncHgnIH0pO1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHsgbWFyZ2luOiAnMHB4JyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbih7XG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxuICAgICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gKGV2ZW50LCAkZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJChldmVudC50YXJnZXQpLnBhcmVudHMoJ1tkYXRhLWNsb3NhYmxlXScpWzBdID09PSAkZWxlbWVudCkge1xuICAgICAgICAgICAgICAvLyBvbmx5IGNsb3NlIHJldmVhbCB3aGVuIGl0J3MgZXhwbGljaXRseSBjYWxsZWRcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5jbG9zZS5hcHBseShfdGhpczIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbiAgICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLiRhbmNob3Iub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMyB8fCBlLndoaWNoID09PSAzMikge1xuICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpIHx8ICEkLmNvbnRhaW5zKGRvY3VtZW50LCBlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZS56Zi5yZXZlYWw6JyArIHRoaXMuaWQsIHRoaXMuX2hhbmRsZVN0YXRlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSGFuZGxlcyBtb2RhbCBtZXRob2RzIG9uIGJhY2svZm9yd2FyZCBidXR0b24gY2xpY2tzIG9yIGFueSBvdGhlciBldmVudCB0aGF0IHRyaWdnZXJzIHBvcHN0YXRlLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZVN0YXRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3RhdGUoZSkge1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2ggPT09ICcjJyArIHRoaXMuaWQgJiYgIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgbW9kYWwgY29udHJvbGxlZCBieSBgdGhpcy4kYW5jaG9yYCwgYW5kIGNsb3NlcyBhbGwgb3RoZXJzIGJ5IGRlZmF1bHQuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VtZVxuICAgICAgICogQGZpcmVzIFJldmVhbCNvcGVuXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ29wZW4nLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcbiAgICAgICAgICB2YXIgaGFzaCA9ICcjJyArIHRoaXMuaWQ7XG5cbiAgICAgICAgICBpZiAod2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAvLyBNYWtlIGVsZW1lbnRzIGludmlzaWJsZSwgYnV0IHJlbW92ZSBkaXNwbGF5OiBub25lIHNvIHdlIGNhbiBnZXQgc2l6ZSBhbmQgcG9zaXRpb25pbmdcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoeyAndmlzaWJpbGl0eSc6ICdoaWRkZW4nIH0pLnNob3coKS5zY3JvbGxUb3AoMCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgIHRoaXMuJG92ZXJsYXkuY3NzKHsgJ3Zpc2liaWxpdHknOiAnaGlkZGVuJyB9KS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7ICd2aXNpYmlsaXR5JzogJycgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHtcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmNzcyh7ICd2aXNpYmlsaXR5JzogJycgfSkuaGlkZSgpO1xuICAgICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdmYXN0JykpIHtcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ2Zhc3QnKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSkge1xuICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnc2xvdycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkKSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBtb2RhbCBvcGVucy5cbiAgICAgICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxuICAgICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VtZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5yZXZlYWwnLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkUmV2ZWFsT3BlbkNsYXNzZXMoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzTW9iaWxlKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICAgIF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLmFkZENsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgcmV2ZWFsXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4pIHtcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFmdGVyQW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKHtcbiAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAtMVxuICAgICAgICAgICAgICB9KS5mb2N1cygpO1xuICAgICAgICAgICAgICBhZGRSZXZlYWxPcGVuQ2xhc3NlcygpO1xuICAgICAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnRyYXBGb2N1cyhfdGhpcy4kZWxlbWVudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oX3RoaXMzLiRvdmVybGF5LCAnZmFkZS1pbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKF90aGlzMy4kZWxlbWVudCwgX3RoaXMzLm9wdGlvbnMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzMy4kZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIHByb3RlY3QgYWdhaW5zdCBvYmplY3QgaGF2aW5nIGJlZW4gcmVtb3ZlZFxuICAgICAgICAgICAgICAgIF90aGlzMy5mb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpczMuJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGFmdGVyQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8galF1ZXJ5IG1ldGhvZCBvZiByZXZlYWxcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5zaG93KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgYWNjZXNzaWJpbGl0eVxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xuICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxuICAgICAgICAgICd0YWJpbmRleCc6IC0xXG4gICAgICAgIH0pLmZvY3VzKCk7XG4gICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQudHJhcEZvY3VzKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICAgICAgICogQGV2ZW50IFJldmVhbCNvcGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYucmV2ZWFsJyk7XG5cbiAgICAgICAgYWRkUmV2ZWFsT3BlbkNsYXNzZXMoKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuX2V4dHJhSGFuZGxlcnMoKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBleHRyYSBldmVudCBoYW5kbGVycyBmb3IgdGhlIGJvZHkgYW5kIHdpbmRvdyBpZiBuZWNlc3NhcnkuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXh0cmFIYW5kbGVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhSGFuZGxlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy4kZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGNsZWFudXAsIGRvbid0IGZyZWFrIG91dFxuICAgICAgICB0aGlzLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiAhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAkKCdib2R5Jykub24oJ2NsaWNrLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSB8fCAhJC5jb250YWlucyhkb2N1bWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAkKHdpbmRvdykub24oJ2tleWRvd24uemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdSZXZlYWwnLCB7XG4gICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbG9jayBmb2N1cyB3aXRoaW4gbW9kYWwgd2hpbGUgdGFiYmluZ1xuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyICR0YXJnZXQgPSAkKHRoaXMpO1xuICAgICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnUmV2ZWFsJywge1xuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtY2xvc2VdJykpKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZm9jdXMgYmFjayB0byBhbmNob3IgaWYgY2xvc2UgYnV0dG9uIGhhcyBiZWVuIGFjdGl2YXRlZFxuICAgICAgICAgICAgICAgICAgX3RoaXMuJGFuY2hvci5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0YXJnZXQuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9udCd0IHRyaWdnZXIgaWYgYWN1YWwgZWxlbWVudCBoYXMgZm9jdXMgKGkuZS4gaW5wdXRzLCBsaW5rcywgLi4uKVxuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIChwcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBtb2RhbC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIFJldmVhbCNjbG9zZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnY2xvc2UnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBNb3Rpb24gVUkgbWV0aG9kIG9mIGhpZGluZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRvdmVybGF5LCAnZmFkZS1vdXQnLCBmaW5pc2hVcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbmlzaFVwKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBqUXVlcnkgbWV0aG9kIG9mIGhpZGluZ1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoMCwgZmluaXNoVXApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmluaXNoVXAoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBDb25kaXRpb25hbHMgdG8gcmVtb3ZlIGV4dHJhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCBvbiBvcGVuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xuICAgICAgICAgICQod2luZG93KS5vZmYoJ2tleWRvd24uemYucmV2ZWFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdmVybGF5ICYmIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcbiAgICAgICAgICAkKCdib2R5Jykub2ZmKCdjbGljay56Zi5yZXZlYWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaFVwKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc01vYmlsZSkge1xuICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zKSB7XG4gICAgICAgICAgICAgICQoJ2JvZHknKS5zY3JvbGxUb3AoX3RoaXMub3JpZ2luYWxTY3JvbGxQb3MpO1xuICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlbGVhc2VGb2N1cyhfdGhpcy4kZWxlbWVudCk7XG5cbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBpcyBkb25lIGNsb3NpbmcuXG4gICAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI2Nsb3NlZFxuICAgICAgICAgICovXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogUmVzZXRzIHRoZSBtb2RhbCBjb250ZW50XG4gICAgICAgICogVGhpcyBwcmV2ZW50cyBhIHJ1bm5pbmcgdmlkZW8gdG8ga2VlcCBnb2luZyBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaHRtbCh0aGlzLiRlbGVtZW50Lmh0bWwoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XG4gICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSkge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKCcnLCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLmhyZWYucmVwbGFjZSgnIycgKyB0aGlzLmlkLCAnJykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGEgbW9kYWwuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAndG9nZ2xlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG5cblxuICAgICAgLyoqXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhIG1vZGFsLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmFwcGVuZFRvKCQodGhpcy5vcHRpb25zLmFwcGVuZFRvKSk7IC8vIG1vdmUgJGVsZW1lbnQgb3V0c2lkZSBvZiAkb3ZlcmxheSB0byBwcmV2ZW50IGVycm9yIHVucmVnaXN0ZXJQbHVnaW4oKVxuICAgICAgICAgIHRoaXMuJG92ZXJsYXkuaGlkZSgpLm9mZigpLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpO1xuICAgICAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYnKTtcbiAgICAgICAgJCh3aW5kb3cpLm9mZignLnpmLnJldmVhbDonICsgdGhpcy5pZCk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZXZlYWw7XG4gIH0oKTtcblxuICBSZXZlYWwuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIGFuaW1hdGlvbkluOiAnJyxcbiAgICAvKipcbiAgICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgYW5pbWF0aW9uT3V0OiAnJyxcbiAgICAvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIG9wZW5pbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBzaG93RGVsYXk6IDAsXG4gICAgLyoqXG4gICAgICogVGltZSwgaW4gbXMsIHRvIGRlbGF5IHRoZSBjbG9zaW5nIG9mIGEgbW9kYWwgYWZ0ZXIgYSBjbGljayBpZiBubyBhbmltYXRpb24gdXNlZC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgaGlkZURlbGF5OiAwLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5L292ZXJsYXkgdG8gY2xvc2UgdGhlIG1vZGFsLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gY2xvc2UgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgYEVTQ0FQRWAga2V5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgY2xvc2VPbkVzYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBhbGxvd3MgbXVsdGlwbGUgbW9kYWxzIHRvIGJlIGRpc3BsYXllZCBhdCBvbmNlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIG11bHRpcGxlT3BlbmVkOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggZG93biBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcnxzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgYXV0b1xuICAgICAqL1xuICAgIHZPZmZzZXQ6ICdhdXRvJyxcbiAgICAvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBhdXRvXG4gICAgICovXG4gICAgaE9mZnNldDogJ2F1dG8nLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYmUgZnVsbHNjcmVlbiwgY29tcGxldGVseSBibG9ja2luZyBvdXQgdGhlIHJlc3Qgb2YgdGhlIHZpZXcuIEpTIGNoZWNrcyBmb3IgdGhpcyBhcyB3ZWxsLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGZ1bGxTY3JlZW46IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFBlcmNlbnRhZ2Ugb2Ygc2NyZWVuIGhlaWdodCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggdXAgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgYnRtT2Zmc2V0UGN0OiAxMCxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGdlbmVyYXRlIGFuIG92ZXJsYXkgZGl2LCB3aGljaCB3aWxsIGNvdmVyIHRoZSB2aWV3IHdoZW4gbW9kYWwgb3BlbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBvdmVybGF5OiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gcmVtb3ZlIGFuZCByZWluamVjdCBtYXJrdXAgb24gY2xvc2UuIFNob3VsZCBiZSB0cnVlIGlmIHVzaW5nIHZpZGVvIGVsZW1lbnRzIHcvbyB1c2luZyBwcm92aWRlcidzIGFwaSwgb3RoZXJ3aXNlLCB2aWRlb3Mgd2lsbCBjb250aW51ZSB0byBwbGF5IGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHJlc2V0T25DbG9zZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBhbHRlciB0aGUgdXJsIG9uIG9wZW4vY2xvc2UsIGFuZCBhbGxvd3MgdGhlIHVzZSBvZiB0aGUgYGJhY2tgIGJ1dHRvbiB0byBjbG9zZSBtb2RhbHMuIEFMU08sIGFsbG93cyBhIG1vZGFsIHRvIGF1dG8tbWFuaWFjYWxseSBvcGVuIG9uIHBhZ2UgbG9hZCBJRiB0aGUgaGFzaCA9PT0gdGhlIG1vZGFsJ3MgdXNlci1zZXQgaWQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZGVlcExpbms6IGZhbHNlLFxuICAgIC8qKlxuICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBhcHBlbmQgdG8gY3VzdG9tIGRpdi5cbiAgICAqIEBvcHRpb25cbiAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgKiBAZGVmYXVsdCBcImJvZHlcIlxuICAgICovXG4gICAgYXBwZW5kVG86IFwiYm9keVwiXG5cbiAgfTtcblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihSZXZlYWwsICdSZXZlYWwnKTtcblxuICBmdW5jdGlvbiBpUGhvbmVTbmlmZigpIHtcbiAgICByZXR1cm4gKC9pUChhZHxob25lfG9kKS4qT1MvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFuZHJvaWRTbmlmZigpIHtcbiAgICByZXR1cm4gKC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBtb2JpbGVTbmlmZigpIHtcbiAgICByZXR1cm4gaVBob25lU25pZmYoKSB8fCBhbmRyb2lkU25pZmYoKTtcbiAgfVxufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnJldmVhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Slider module.\n   * @module foundation.slider\n   * @requires foundation.util.motion\n   * @requires foundation.util.triggers\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.touch\n   */\n\n  var Slider = function () {\n    /**\n     * Creates a new instance of a slider control.\n     * @class\n     * @param {jQuery} element - jQuery object to make into a slider control.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Slider(element, options) {\n      _classCallCheck(this, Slider);\n\n      this.$element = element;\n      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Slider');\n      Foundation.Keyboard.register('Slider', {\n        'ltr': {\n          'ARROW_RIGHT': 'increase',\n          'ARROW_UP': 'increase',\n          'ARROW_DOWN': 'decrease',\n          'ARROW_LEFT': 'decrease',\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\n          'SHIFT_ARROW_UP': 'increase_fast',\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\n          'SHIFT_ARROW_LEFT': 'decrease_fast'\n        },\n        'rtl': {\n          'ARROW_LEFT': 'increase',\n          'ARROW_RIGHT': 'decrease',\n          'SHIFT_ARROW_LEFT': 'increase_fast',\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\n        }\n      });\n    }\n\n    /**\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\n     * @function\n     * @private\n     */\n\n\n    _createClass(Slider, [{\n      key: '_init',\n      value: function _init() {\n        this.inputs = this.$element.find('input');\n        this.handles = this.$element.find('[data-slider-handle]');\n\n        this.$handle = this.handles.eq(0);\n        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));\n        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\n\n        var isDbl = false,\n            _this = this;\n        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\n          this.options.disabled = true;\n          this.$element.addClass(this.options.disabledClass);\n        }\n        if (!this.inputs.length) {\n          this.inputs = $().add(this.$input);\n          this.options.binding = true;\n        }\n\n        this._setInitAttr(0);\n\n        if (this.handles[1]) {\n          this.options.doubleSided = true;\n          this.$handle2 = this.handles.eq(1);\n          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));\n\n          if (!this.inputs[1]) {\n            this.inputs = this.inputs.add(this.$input2);\n          }\n          isDbl = true;\n\n          // this.$handle.triggerHandler('click.zf.slider');\n          this._setInitAttr(1);\n        }\n\n        // Set handle positions\n        this.setHandles();\n\n        this._events();\n      }\n    }, {\n      key: 'setHandles',\n      value: function setHandles() {\n        var _this2 = this;\n\n        if (this.handles[1]) {\n          this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true, function () {\n            _this2._setHandlePos(_this2.$handle2, _this2.inputs.eq(1).val(), true);\n          });\n        } else {\n          this._setHandlePos(this.$handle, this.inputs.eq(0).val(), true);\n        }\n      }\n    }, {\n      key: '_reflow',\n      value: function _reflow() {\n        this.setHandles();\n      }\n      /**\n      * @function\n      * @private\n      * @param {Number} value - floating point (the value) to be transformed using to a relative position on the slider (the inverse of _value)\n      */\n\n    }, {\n      key: '_pctOfBar',\n      value: function _pctOfBar(value) {\n        var pctOfBar = percent(value - this.options.start, this.options.end - this.options.start);\n\n        switch (this.options.positionValueFunction) {\n          case \"pow\":\n            pctOfBar = this._logTransform(pctOfBar);\n            break;\n          case \"log\":\n            pctOfBar = this._powTransform(pctOfBar);\n            break;\n        }\n\n        return pctOfBar.toFixed(2);\n      }\n\n      /**\n      * @function\n      * @private\n      * @param {Number} pctOfBar - floating point, the relative position of the slider (typically between 0-1) to be transformed to a value\n      */\n\n    }, {\n      key: '_value',\n      value: function _value(pctOfBar) {\n        switch (this.options.positionValueFunction) {\n          case \"pow\":\n            pctOfBar = this._powTransform(pctOfBar);\n            break;\n          case \"log\":\n            pctOfBar = this._logTransform(pctOfBar);\n            break;\n        }\n        var value = (this.options.end - this.options.start) * pctOfBar + this.options.start;\n\n        return value;\n      }\n\n      /**\n      * @function\n      * @private\n      * @param {Number} value - floating point (typically between 0-1) to be transformed using the log function\n      */\n\n    }, {\n      key: '_logTransform',\n      value: function _logTransform(value) {\n        return baseLog(this.options.nonLinearBase, value * (this.options.nonLinearBase - 1) + 1);\n      }\n\n      /**\n      * @function\n      * @private\n      * @param {Number} value - floating point (typically between 0-1) to be transformed using the power function\n      */\n\n    }, {\n      key: '_powTransform',\n      value: function _powTransform(value) {\n        return (Math.pow(this.options.nonLinearBase, value) - 1) / (this.options.nonLinearBase - 1);\n      }\n\n      /**\n       * Sets the position of the selected handle and fill bar.\n       * @function\n       * @private\n       * @param {jQuery} $hndl - the selected handle to move.\n       * @param {Number} location - floating point between the start and end values of the slider bar.\n       * @param {Function} cb - callback function to fire on completion.\n       * @fires Slider#moved\n       * @fires Slider#changed\n       */\n\n    }, {\n      key: '_setHandlePos',\n      value: function _setHandlePos($hndl, location, noInvert, cb) {\n        // don't move if the slider has been disabled since its initialization\n        if (this.$element.hasClass(this.options.disabledClass)) {\n          return;\n        }\n        //might need to alter that slightly for bars that will have odd number selections.\n        location = parseFloat(location); //on input change events, convert string to number...grumble.\n\n        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\n        if (location < this.options.start) {\n          location = this.options.start;\n        } else if (location > this.options.end) {\n          location = this.options.end;\n        }\n\n        var isDbl = this.options.doubleSided;\n\n        if (isDbl) {\n          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\n          if (this.handles.index($hndl) === 0) {\n            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\n            location = location >= h2Val ? h2Val - this.options.step : location;\n          } else {\n            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\n            location = location <= h1Val ? h1Val + this.options.step : location;\n          }\n        }\n\n        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \"upside-down\"\n        //for click and drag events, it's weird due to the scale(-1, 1) css property\n        if (this.options.vertical && !noInvert) {\n          location = this.options.end - location;\n        }\n\n        var _this = this,\n            vert = this.options.vertical,\n            hOrW = vert ? 'height' : 'width',\n            lOrT = vert ? 'top' : 'left',\n            handleDim = $hndl[0].getBoundingClientRect()[hOrW],\n            elemDim = this.$element[0].getBoundingClientRect()[hOrW],\n\n        //percentage of bar min/max value based on click or drag point\n        pctOfBar = this._pctOfBar(location),\n\n        //number of actual pixels to shift the handle, based on the percentage obtained above\n        pxToMove = (elemDim - handleDim) * pctOfBar,\n\n        //percentage of bar to shift the handle\n        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\n        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\n        location = parseFloat(location.toFixed(this.options.decimal));\n        // declare empty object for css adjustments, only used with 2 handled-sliders\n        var css = {};\n\n        this._setValues($hndl, location);\n\n        // TODO update to calculate based on values set to respective inputs??\n        if (isDbl) {\n          var isLeftHndl = this.handles.index($hndl) === 0,\n\n          //empty variable, will be used for min-height/width for fill bar\n          dim,\n\n          //percentage w/h of the handle compared to the slider bar\n          handlePct = ~~(percent(handleDim, elemDim) * 100);\n          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\n          if (isLeftHndl) {\n            //left or top percentage value to apply to the fill bar.\n            css[lOrT] = movement + '%';\n            //calculate the new min-height/width for the fill bar.\n            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\n            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\n            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\n            if (cb && typeof cb === 'function') {\n              cb();\n            } //this is only needed for the initialization of 2 handled sliders\n          } else {\n            //just caching the value of the left/bottom handle's left/top property\n            var handlePos = parseFloat(this.$handle[0].style[lOrT]);\n            //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\n            //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\n            dim = movement - (isNaN(handlePos) ? (this.options.initialStart - this.options.start) / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\n          }\n          // assign the min-height/width to our css object\n          css['min-' + hOrW] = dim + '%';\n        }\n\n        this.$element.one('finished.zf.animate', function () {\n          /**\n           * Fires when the handle is done moving.\n           * @event Slider#moved\n           */\n          _this.$element.trigger('moved.zf.slider', [$hndl]);\n        });\n\n        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\n        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\n\n        Foundation.Move(moveTime, $hndl, function () {\n          // adjusting the left/top property of the handle, based on the percentage calculated above\n          // if movement isNaN, that is because the slider is hidden and we cannot determine handle width,\n          // fall back to next best guess.\n          if (isNaN(movement)) {\n            $hndl.css(lOrT, pctOfBar * 100 + '%');\n          } else {\n            $hndl.css(lOrT, movement + '%');\n          }\n\n          if (!_this.options.doubleSided) {\n            //if single-handled, a simple method to expand the fill bar\n            _this.$fill.css(hOrW, pctOfBar * 100 + '%');\n          } else {\n            //otherwise, use the css object we created above\n            _this.$fill.css(css);\n          }\n        });\n\n        /**\n         * Fires when the value has not been change for a given time.\n         * @event Slider#changed\n         */\n        clearTimeout(_this.timeout);\n        _this.timeout = setTimeout(function () {\n          _this.$element.trigger('changed.zf.slider', [$hndl]);\n        }, _this.options.changedDelay);\n      }\n\n      /**\n       * Sets the initial attribute for the slider element.\n       * @function\n       * @private\n       * @param {Number} idx - index of the current handle/input to use.\n       */\n\n    }, {\n      key: '_setInitAttr',\n      value: function _setInitAttr(idx) {\n        var initVal = idx === 0 ? this.options.initialStart : this.options.initialEnd;\n        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\n        this.inputs.eq(idx).attr({\n          'id': id,\n          'max': this.options.end,\n          'min': this.options.start,\n          'step': this.options.step\n        });\n        this.inputs.eq(idx).val(initVal);\n        this.handles.eq(idx).attr({\n          'role': 'slider',\n          'aria-controls': id,\n          'aria-valuemax': this.options.end,\n          'aria-valuemin': this.options.start,\n          'aria-valuenow': initVal,\n          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\n          'tabindex': 0\n        });\n      }\n\n      /**\n       * Sets the input and `aria-valuenow` values for the slider element.\n       * @function\n       * @private\n       * @param {jQuery} $handle - the currently selected handle.\n       * @param {Number} val - floating point of the new value.\n       */\n\n    }, {\n      key: '_setValues',\n      value: function _setValues($handle, val) {\n        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\n        this.inputs.eq(idx).val(val);\n        $handle.attr('aria-valuenow', val);\n      }\n\n      /**\n       * Handles events on the slider element.\n       * Calculates the new location of the current handle.\n       * If there are two handles and the bar was clicked, it determines which handle to move.\n       * @function\n       * @private\n       * @param {Object} e - the `event` object passed from the listener.\n       * @param {jQuery} $handle - the current handle to calculate for, if selected.\n       * @param {Number} val - floating point number for the new value of the slider.\n       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\n       */\n\n    }, {\n      key: '_handleEvent',\n      value: function _handleEvent(e, $handle, val) {\n        var value, hasVal;\n        if (!val) {\n          //click or drag events\n          e.preventDefault();\n          var _this = this,\n              vertical = this.options.vertical,\n              param = vertical ? 'height' : 'width',\n              direction = vertical ? 'top' : 'left',\n              eventOffset = vertical ? e.pageY : e.pageX,\n              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\n              barDim = this.$element[0].getBoundingClientRect()[param],\n              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\n\n          var elemOffset = this.$element.offset()[direction];\n\n          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\n          // best way to guess this is simulated is if clientY == pageY\n          if (e.clientY === e.pageY) {\n            eventOffset = eventOffset + windowScroll;\n          }\n          var eventFromBar = eventOffset - elemOffset;\n          var barXY;\n          if (eventFromBar < 0) {\n            barXY = 0;\n          } else if (eventFromBar > barDim) {\n            barXY = barDim;\n          } else {\n            barXY = eventFromBar;\n          }\n          var offsetPct = percent(barXY, barDim);\n\n          value = this._value(offsetPct);\n\n          // turn everything around for RTL, yay math!\n          if (Foundation.rtl() && !this.options.vertical) {\n            value = this.options.end - value;\n          }\n\n          value = _this._adjustValue(null, value);\n          //boolean flag for the setHandlePos fn, specifically for vertical sliders\n          hasVal = false;\n\n          if (!$handle) {\n            //figure out which handle it is, pass it to the next function.\n            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\n                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\n            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\n          }\n        } else {\n          //change event on input\n          value = this._adjustValue(null, val);\n          hasVal = true;\n        }\n\n        this._setHandlePos($handle, value, hasVal);\n      }\n\n      /**\n       * Adjustes value for handle in regard to step value. returns adjusted value\n       * @function\n       * @private\n       * @param {jQuery} $handle - the selected handle.\n       * @param {Number} value - value to adjust. used if $handle is falsy\n       */\n\n    }, {\n      key: '_adjustValue',\n      value: function _adjustValue($handle, value) {\n        var val,\n            step = this.options.step,\n            div = parseFloat(step / 2),\n            left,\n            prev_val,\n            next_val;\n        if (!!$handle) {\n          val = parseFloat($handle.attr('aria-valuenow'));\n        } else {\n          val = value;\n        }\n        left = val % step;\n        prev_val = val - left;\n        next_val = prev_val + step;\n        if (left === 0) {\n          return val;\n        }\n        val = val >= prev_val + div ? next_val : prev_val;\n        return val;\n      }\n\n      /**\n       * Adds event listeners to the slider elements.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        this._eventsForHandle(this.$handle);\n        if (this.handles[1]) {\n          this._eventsForHandle(this.$handle2);\n        }\n      }\n\n      /**\n       * Adds event listeners a particular handle\n       * @function\n       * @private\n       * @param {jQuery} $handle - the current handle to apply listeners to.\n       */\n\n    }, {\n      key: '_eventsForHandle',\n      value: function _eventsForHandle($handle) {\n        var _this = this,\n            curHandle,\n            timer;\n\n        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\n          var idx = _this.inputs.index($(this));\n          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\n        });\n\n        if (this.options.clickSelect) {\n          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\n            if (_this.$element.data('dragging')) {\n              return false;\n            }\n\n            if (!$(e.target).is('[data-slider-handle]')) {\n              if (_this.options.doubleSided) {\n                _this._handleEvent(e);\n              } else {\n                _this._handleEvent(e, _this.$handle);\n              }\n            }\n          });\n        }\n\n        if (this.options.draggable) {\n          this.handles.addTouch();\n\n          var $body = $('body');\n          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\n            $handle.addClass('is-dragging');\n            _this.$fill.addClass('is-dragging'); //\n            _this.$element.data('dragging', true);\n\n            curHandle = $(e.currentTarget);\n\n            $body.on('mousemove.zf.slider', function (e) {\n              e.preventDefault();\n              _this._handleEvent(e, curHandle);\n            }).on('mouseup.zf.slider', function (e) {\n              _this._handleEvent(e, curHandle);\n\n              $handle.removeClass('is-dragging');\n              _this.$fill.removeClass('is-dragging');\n              _this.$element.data('dragging', false);\n\n              $body.off('mousemove.zf.slider mouseup.zf.slider');\n            });\n          })\n          // prevent events triggered by touch\n          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\n            e.preventDefault();\n          });\n        }\n\n        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\n          var _$handle = $(this),\n              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\n              oldValue = parseFloat(_this.inputs.eq(idx).val()),\n              newValue;\n\n          // handle keyboard event with keyboard util\n          Foundation.Keyboard.handleKey(e, 'Slider', {\n            decrease: function () {\n              newValue = oldValue - _this.options.step;\n            },\n            increase: function () {\n              newValue = oldValue + _this.options.step;\n            },\n            decrease_fast: function () {\n              newValue = oldValue - _this.options.step * 10;\n            },\n            increase_fast: function () {\n              newValue = oldValue + _this.options.step * 10;\n            },\n            handled: function () {\n              // only set handle pos when event was handled specially\n              e.preventDefault();\n              _this._setHandlePos(_$handle, newValue, true);\n            }\n          });\n          /*if (newValue) { // if pressed key has special function, update value\n            e.preventDefault();\n            _this._setHandlePos(_$handle, newValue);\n          }*/\n        });\n      }\n\n      /**\n       * Destroys the slider plugin.\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.handles.off('.zf.slider');\n        this.inputs.off('.zf.slider');\n        this.$element.off('.zf.slider');\n\n        clearTimeout(this.timeout);\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Slider;\n  }();\n\n  Slider.defaults = {\n    /**\n     * Minimum value for the slider scale.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    start: 0,\n    /**\n     * Maximum value for the slider scale.\n     * @option\n     * @type {number}\n     * @default 100\n     */\n    end: 100,\n    /**\n     * Minimum value change per change event.\n     * @option\n     * @type {number}\n     * @default 1\n     */\n    step: 1,\n    /**\n     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\n     * @option\n     * @type {number}\n     * @default 0\n     */\n    initialStart: 0,\n    /**\n     * Value at which the right handle/second input should be set to on initialization.\n     * @option\n     * @type {number}\n     * @default 100\n     */\n    initialEnd: 100,\n    /**\n     * Allows the input to be located outside the container and visible. Set to by the JS\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    binding: false,\n    /**\n     * Allows the user to click/tap on the slider bar to select a value.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    clickSelect: true,\n    /**\n     * Set to true and use the `vertical` class to change alignment to vertical.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    vertical: false,\n    /**\n     * Allows the user to drag the slider handle(s) to select a value.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    draggable: true,\n    /**\n     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    disabled: false,\n    /**\n     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    doubleSided: false,\n    /**\n     * Potential future feature.\n     */\n    // steps: 100,\n    /**\n     * Number of decimal places the plugin should go to for floating point precision.\n     * @option\n     * @type {number}\n     * @default 2\n     */\n    decimal: 2,\n    /**\n     * Time delay for dragged elements.\n     */\n    // dragDelay: 0,\n    /**\n     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\n     * @option\n     * @type {number}\n     * @default 200\n     */\n    moveTime: 200, //update this if changing the transition time in the sass\n    /**\n     * Class applied to disabled sliders.\n     * @option\n     * @type {string}\n     * @default 'disabled'\n     */\n    disabledClass: 'disabled',\n    /**\n     * Will invert the default layout for a vertical<span data-tooltip title=\"who would do this???\"> </span>slider.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    invertVertical: false,\n    /**\n     * Milliseconds before the `changed.zf-slider` event is triggered after value change.\n     * @option\n     * @type {number}\n     * @default 500\n     */\n    changedDelay: 500,\n    /**\n    * Basevalue for non-linear sliders\n    * @option\n    * @type {number}\n    * @default 5\n    */\n    nonLinearBase: 5,\n    /**\n    * Basevalue for non-linear sliders, possible values are: `'linear'`, `'pow'` & `'log'`. Pow and Log use the nonLinearBase setting.\n    * @option\n    * @type {string}\n    * @default 'linear'\n    */\n    positionValueFunction: 'linear'\n  };\n\n  function percent(frac, num) {\n    return frac / num;\n  }\n  function absPosition($handle, dir, clickPos, param) {\n    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\n  }\n  function baseLog(base, value) {\n    return Math.log(value) / Math.log(base);\n  }\n\n  // Window exports\n  Foundation.plugin(Slider, 'Slider');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uc2xpZGVyLmpzP2YzZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogU2xpZGVyIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxuICAgKi9cblxuICB2YXIgU2xpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzbGlkZXIgY29udHJvbC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgc2xpZGVyIGNvbnRyb2wuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNsaWRlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU2xpZGVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnU2xpZGVyJyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdTbGlkZXInLCB7XG4gICAgICAgICdsdHInOiB7XG4gICAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlJyxcbiAgICAgICAgICAnQVJST1dfVVAnOiAnaW5jcmVhc2UnLFxuICAgICAgICAgICdBUlJPV19ET1dOJzogJ2RlY3JlYXNlJyxcbiAgICAgICAgICAnQVJST1dfTEVGVCc6ICdkZWNyZWFzZScsXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2luY3JlYXNlX2Zhc3QnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19VUCc6ICdpbmNyZWFzZV9mYXN0JyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfRE9XTic6ICdkZWNyZWFzZV9mYXN0JyxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgICB9LFxuICAgICAgICAncnRsJzoge1xuICAgICAgICAgICdBUlJPV19MRUZUJzogJ2luY3JlYXNlJyxcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnZGVjcmVhc2UnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19MRUZUJzogJ2luY3JlYXNlX2Zhc3QnLFxuICAgICAgICAgICdTSElGVF9BUlJPV19SSUdIVCc6ICdkZWNyZWFzZV9mYXN0J1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWxpemVzIHRoZSBwbHVnaW4gYnkgcmVhZGluZy9zZXR0aW5nIGF0dHJpYnV0ZXMsIGNyZWF0aW5nIGNvbGxlY3Rpb25zIGFuZCBzZXR0aW5nIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBoYW5kbGUocykuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFNsaWRlciwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKTtcblxuICAgICAgICB0aGlzLiRoYW5kbGUgPSB0aGlzLmhhbmRsZXMuZXEoMCk7XG4gICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMCkgOiAkKCcjJyArIHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLWNvbnRyb2xzJykpO1xuICAgICAgICB0aGlzLiRmaWxsID0gdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItZmlsbF0nKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLCAwKTtcblxuICAgICAgICB2YXIgaXNEYmwgPSBmYWxzZSxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCB8fCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmlucHV0cyA9ICQoKS5hZGQodGhpcy4kaW5wdXQpO1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5iaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEluaXRBdHRyKDApO1xuXG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuJGhhbmRsZTIgPSB0aGlzLmhhbmRsZXMuZXEoMSk7XG4gICAgICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID4gMSA/IHRoaXMuaW5wdXRzLmVxKDEpIDogJCgnIycgKyB0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSk7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuaW5wdXRzWzFdKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IHRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0RibCA9IHRydWU7XG5cbiAgICAgICAgICAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xuICAgICAgICAgIHRoaXMuX3NldEluaXRBdHRyKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGhhbmRsZSBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy5zZXRIYW5kbGVzKCk7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnc2V0SGFuZGxlcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGFuZGxlcygpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMuaW5wdXRzLmVxKDApLnZhbCgpLCB0cnVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczIuX3NldEhhbmRsZVBvcyhfdGhpczIuJGhhbmRsZTIsIF90aGlzMi5pbnB1dHMuZXEoMSkudmFsKCksIHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMuaW5wdXRzLmVxKDApLnZhbCgpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19yZWZsb3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XG4gICAgICAgIHRoaXMuc2V0SGFuZGxlcygpO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSBmbG9hdGluZyBwb2ludCAodGhlIHZhbHVlKSB0byBiZSB0cmFuc2Zvcm1lZCB1c2luZyB0byBhIHJlbGF0aXZlIHBvc2l0aW9uIG9uIHRoZSBzbGlkZXIgKHRoZSBpbnZlcnNlIG9mIF92YWx1ZSlcbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGN0T2ZCYXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wY3RPZkJhcih2YWx1ZSkge1xuICAgICAgICB2YXIgcGN0T2ZCYXIgPSBwZXJjZW50KHZhbHVlIC0gdGhpcy5vcHRpb25zLnN0YXJ0LCB0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5wb3NpdGlvblZhbHVlRnVuY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFwicG93XCI6XG4gICAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX2xvZ1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibG9nXCI6XG4gICAgICAgICAgICBwY3RPZkJhciA9IHRoaXMuX3Bvd1RyYW5zZm9ybShwY3RPZkJhcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwY3RPZkJhci50b0ZpeGVkKDIpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwY3RPZkJhciAtIGZsb2F0aW5nIHBvaW50LCB0aGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIHNsaWRlciAodHlwaWNhbGx5IGJldHdlZW4gMC0xKSB0byBiZSB0cmFuc2Zvcm1lZCB0byBhIHZhbHVlXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3ZhbHVlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsdWUocGN0T2ZCYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMucG9zaXRpb25WYWx1ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgY2FzZSBcInBvd1wiOlxuICAgICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9wb3dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICAgICAgcGN0T2ZCYXIgPSB0aGlzLl9sb2dUcmFuc2Zvcm0ocGN0T2ZCYXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gKHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpICogcGN0T2ZCYXIgKyB0aGlzLm9wdGlvbnMuc3RhcnQ7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIGZsb2F0aW5nIHBvaW50ICh0eXBpY2FsbHkgYmV0d2VlbiAwLTEpIHRvIGJlIHRyYW5zZm9ybWVkIHVzaW5nIHRoZSBsb2cgZnVuY3Rpb25cbiAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfbG9nVHJhbnNmb3JtJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9nVHJhbnNmb3JtKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlTG9nKHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlLCB2YWx1ZSAqICh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSAtIDEpICsgMSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICogQHByaXZhdGVcbiAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gZmxvYXRpbmcgcG9pbnQgKHR5cGljYWxseSBiZXR3ZWVuIDAtMSkgdG8gYmUgdHJhbnNmb3JtZWQgdXNpbmcgdGhlIHBvd2VyIGZ1bmN0aW9uXG4gICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3Bvd1RyYW5zZm9ybScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvd1RyYW5zZm9ybSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KHRoaXMub3B0aW9ucy5ub25MaW5lYXJCYXNlLCB2YWx1ZSkgLSAxKSAvICh0aGlzLm9wdGlvbnMubm9uTGluZWFyQmFzZSAtIDEpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gZmxvYXRpbmcgcG9pbnQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIHNsaWRlciBiYXIuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbi5cbiAgICAgICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICAgICAqIEBmaXJlcyBTbGlkZXIjY2hhbmdlZFxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0SGFuZGxlUG9zJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SGFuZGxlUG9zKCRobmRsLCBsb2NhdGlvbiwgbm9JbnZlcnQsIGNiKSB7XG4gICAgICAgIC8vIGRvbid0IG1vdmUgaWYgdGhlIHNsaWRlciBoYXMgYmVlbiBkaXNhYmxlZCBzaW5jZSBpdHMgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vbWlnaHQgbmVlZCB0byBhbHRlciB0aGF0IHNsaWdodGx5IGZvciBiYXJzIHRoYXQgd2lsbCBoYXZlIG9kZCBudW1iZXIgc2VsZWN0aW9ucy5cbiAgICAgICAgbG9jYXRpb24gPSBwYXJzZUZsb2F0KGxvY2F0aW9uKTsgLy9vbiBpbnB1dCBjaGFuZ2UgZXZlbnRzLCBjb252ZXJ0IHN0cmluZyB0byBudW1iZXIuLi5ncnVtYmxlLlxuXG4gICAgICAgIC8vIHByZXZlbnQgc2xpZGVyIGZyb20gcnVubmluZyBvdXQgb2YgYm91bmRzLCBpZiB2YWx1ZSBleGNlZWRzIHRoZSBsaW1pdHMgc2V0IHRocm91Z2ggb3B0aW9ucywgb3ZlcnJpZGUgdGhlIHZhbHVlIHRvIG1pbi9tYXhcbiAgICAgICAgaWYgKGxvY2F0aW9uIDwgdGhpcy5vcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuc3RhcnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYXRpb24gPiB0aGlzLm9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuZW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzRGJsID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO1xuXG4gICAgICAgIGlmIChpc0RibCkge1xuICAgICAgICAgIC8vdGhpcyBibG9jayBpcyB0byBwcmV2ZW50IDIgaGFuZGxlcyBmcm9tIGNyb3NzaW5nIGVhY2hvdGhlci4gQ291bGQvc2hvdWxkIGJlIGltcHJvdmVkLlxuICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMuaW5kZXgoJGhuZGwpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgaDJWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTIuYXR0cignYXJpYS12YWx1ZW5vdycpKTtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPj0gaDJWYWwgPyBoMlZhbCAtIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoMVZhbCA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IGxvY2F0aW9uIDw9IGgxVmFsID8gaDFWYWwgKyB0aGlzLm9wdGlvbnMuc3RlcCA6IGxvY2F0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcyBpcyBmb3Igc2luZ2xlLWhhbmRsZWQgdmVydGljYWwgc2xpZGVycywgaXQgYWRqdXN0cyB0aGUgdmFsdWUgdG8gYWNjb3VudCBmb3IgdGhlIHNsaWRlciBiZWluZyBcInVwc2lkZS1kb3duXCJcbiAgICAgICAgLy9mb3IgY2xpY2sgYW5kIGRyYWcgZXZlbnRzLCBpdCdzIHdlaXJkIGR1ZSB0byB0aGUgc2NhbGUoLTEsIDEpIGNzcyBwcm9wZXJ0eVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsICYmICFub0ludmVydCkge1xuICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5vcHRpb25zLmVuZCAtIGxvY2F0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIHZlcnQgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXG4gICAgICAgICAgICBoT3JXID0gdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgICAgIGxPclQgPSB2ZXJ0ID8gJ3RvcCcgOiAnbGVmdCcsXG4gICAgICAgICAgICBoYW5kbGVEaW0gPSAkaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxcbiAgICAgICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxuXG4gICAgICAgIC8vcGVyY2VudGFnZSBvZiBiYXIgbWluL21heCB2YWx1ZSBiYXNlZCBvbiBjbGljayBvciBkcmFnIHBvaW50XG4gICAgICAgIHBjdE9mQmFyID0gdGhpcy5fcGN0T2ZCYXIobG9jYXRpb24pLFxuXG4gICAgICAgIC8vbnVtYmVyIG9mIGFjdHVhbCBwaXhlbHMgdG8gc2hpZnQgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2J0YWluZWQgYWJvdmVcbiAgICAgICAgcHhUb01vdmUgPSAoZWxlbURpbSAtIGhhbmRsZURpbSkgKiBwY3RPZkJhcixcblxuICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIHRvIHNoaWZ0IHRoZSBoYW5kbGVcbiAgICAgICAgbW92ZW1lbnQgPSAocGVyY2VudChweFRvTW92ZSwgZWxlbURpbSkgKiAxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpO1xuICAgICAgICAvL2ZpeGluZyB0aGUgZGVjaW1hbCB2YWx1ZSBmb3IgdGhlIGxvY2F0aW9uIG51bWJlciwgaXMgcGFzc2VkIHRvIG90aGVyIG1ldGhvZHMgYXMgYSBmaXhlZCBmbG9hdGluZy1wb2ludCB2YWx1ZVxuICAgICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24udG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO1xuICAgICAgICAvLyBkZWNsYXJlIGVtcHR5IG9iamVjdCBmb3IgY3NzIGFkanVzdG1lbnRzLCBvbmx5IHVzZWQgd2l0aCAyIGhhbmRsZWQtc2xpZGVyc1xuICAgICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgICAgdGhpcy5fc2V0VmFsdWVzKCRobmRsLCBsb2NhdGlvbik7XG5cbiAgICAgICAgLy8gVE9ETyB1cGRhdGUgdG8gY2FsY3VsYXRlIGJhc2VkIG9uIHZhbHVlcyBzZXQgdG8gcmVzcGVjdGl2ZSBpbnB1dHM/P1xuICAgICAgICBpZiAoaXNEYmwpIHtcbiAgICAgICAgICB2YXIgaXNMZWZ0SG5kbCA9IHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCkgPT09IDAsXG5cbiAgICAgICAgICAvL2VtcHR5IHZhcmlhYmxlLCB3aWxsIGJlIHVzZWQgZm9yIG1pbi1oZWlnaHQvd2lkdGggZm9yIGZpbGwgYmFyXG4gICAgICAgICAgZGltLFxuXG4gICAgICAgICAgLy9wZXJjZW50YWdlIHcvaCBvZiB0aGUgaGFuZGxlIGNvbXBhcmVkIHRvIHRoZSBzbGlkZXIgYmFyXG4gICAgICAgICAgaGFuZGxlUGN0ID0gfn4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTtcbiAgICAgICAgICAvL2lmIGxlZnQgaGFuZGxlLCB0aGUgbWF0aCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBpZiBpdCdzIHRoZSByaWdodCBoYW5kbGUsIGFuZCB0aGUgbGVmdC90b3AgcHJvcGVydHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBmb3IgdGhlIGZpbGwgYmFyXG4gICAgICAgICAgaWYgKGlzTGVmdEhuZGwpIHtcbiAgICAgICAgICAgIC8vbGVmdCBvciB0b3AgcGVyY2VudGFnZSB2YWx1ZSB0byBhcHBseSB0byB0aGUgZmlsbCBiYXIuXG4gICAgICAgICAgICBjc3NbbE9yVF0gPSBtb3ZlbWVudCArICclJztcbiAgICAgICAgICAgIC8vY2FsY3VsYXRlIHRoZSBuZXcgbWluLWhlaWdodC93aWR0aCBmb3IgdGhlIGZpbGwgYmFyLlxuICAgICAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0O1xuICAgICAgICAgICAgLy90aGlzIGNhbGxiYWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IGVycm9ycyBhbmQgYWxsb3cgdGhlIHByb3BlciBwbGFjZW1lbnQgYW5kIGluaXRpYWxpemF0aW9uIG9mIGEgMi1oYW5kbGVkIHNsaWRlclxuICAgICAgICAgICAgLy9wbHVzLCBpdCBtZWFucyB3ZSBkb24ndCBjYXJlIGlmICdkaW0nIGlzTmFOIG9uIGluaXQsIGl0IHdvbid0IGJlIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IC8vdGhpcyBpcyBvbmx5IG5lZWRlZCBmb3IgdGhlIGluaXRpYWxpemF0aW9uIG9mIDIgaGFuZGxlZCBzbGlkZXJzXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vanVzdCBjYWNoaW5nIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdC9ib3R0b20gaGFuZGxlJ3MgbGVmdC90b3AgcHJvcGVydHlcbiAgICAgICAgICAgIHZhciBoYW5kbGVQb3MgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtsT3JUXSk7XG4gICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcbiAgICAgICAgICAgIC8vYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2YgbW92ZW1lbnQgb2YgdGhlIGhhbmRsZSBiZWluZyBtYW5pcHVsYXRlZCwgbGVzcyB0aGUgb3Bwb3NpbmcgaGFuZGxlJ3MgbGVmdC90b3AgcG9zaXRpb24sIHBsdXMgdGhlIHBlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgaXRzZWxmXG4gICAgICAgICAgICBkaW0gPSBtb3ZlbWVudCAtIChpc05hTihoYW5kbGVQb3MpID8gKHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpIC8gKCh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvIDEwMCkgOiBoYW5kbGVQb3MpICsgaGFuZGxlUGN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhc3NpZ24gdGhlIG1pbi1oZWlnaHQvd2lkdGggdG8gb3VyIGNzcyBvYmplY3RcbiAgICAgICAgICBjc3NbJ21pbi0nICsgaE9yV10gPSBkaW0gKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoYW5kbGUgaXMgZG9uZSBtb3ZpbmcuXG4gICAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxuICAgICAgICAgICAqL1xuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ21vdmVkLnpmLnNsaWRlcicsIFskaG5kbF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL2JlY2F1c2Ugd2UgZG9uJ3Qga25vdyBleGFjdGx5IGhvdyB0aGUgaGFuZGxlIHdpbGwgYmUgbW92ZWQsIGNoZWNrIHRoZSBhbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBtb3ZlLlxuICAgICAgICB2YXIgbW92ZVRpbWUgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykgPyAxMDAwIC8gNjAgOiB0aGlzLm9wdGlvbnMubW92ZVRpbWU7XG5cbiAgICAgICAgRm91bmRhdGlvbi5Nb3ZlKG1vdmVUaW1lLCAkaG5kbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGFkanVzdGluZyB0aGUgbGVmdC90b3AgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2UgY2FsY3VsYXRlZCBhYm92ZVxuICAgICAgICAgIC8vIGlmIG1vdmVtZW50IGlzTmFOLCB0aGF0IGlzIGJlY2F1c2UgdGhlIHNsaWRlciBpcyBoaWRkZW4gYW5kIHdlIGNhbm5vdCBkZXRlcm1pbmUgaGFuZGxlIHdpZHRoLFxuICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBuZXh0IGJlc3QgZ3Vlc3MuXG4gICAgICAgICAgaWYgKGlzTmFOKG1vdmVtZW50KSkge1xuICAgICAgICAgICAgJGhuZGwuY3NzKGxPclQsIHBjdE9mQmFyICogMTAwICsgJyUnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGhuZGwuY3NzKGxPclQsIG1vdmVtZW50ICsgJyUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQpIHtcbiAgICAgICAgICAgIC8vaWYgc2luZ2xlLWhhbmRsZWQsIGEgc2ltcGxlIG1ldGhvZCB0byBleHBhbmQgdGhlIGZpbGwgYmFyXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoaE9yVywgcGN0T2ZCYXIgKiAxMDAgKyAnJScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL290aGVyd2lzZSwgdXNlIHRoZSBjc3Mgb2JqZWN0IHdlIGNyZWF0ZWQgYWJvdmVcbiAgICAgICAgICAgIF90aGlzLiRmaWxsLmNzcyhjc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjaGFuZ2UgZm9yIGEgZ2l2ZW4gdGltZS5cbiAgICAgICAgICogQGV2ZW50IFNsaWRlciNjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XG4gICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2VkLnpmLnNsaWRlcicsIFskaG5kbF0pO1xuICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmNoYW5nZWREZWxheSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgaW5pdGlhbCBhdHRyaWJ1dGUgZm9yIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSBpbmRleCBvZiB0aGUgY3VycmVudCBoYW5kbGUvaW5wdXQgdG8gdXNlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0SW5pdEF0dHInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbml0QXR0cihpZHgpIHtcbiAgICAgICAgdmFyIGluaXRWYWwgPSBpZHggPT09IDAgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IDogdGhpcy5vcHRpb25zLmluaXRpYWxFbmQ7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cignaWQnKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdzbGlkZXInKTtcbiAgICAgICAgdGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICAgICAnaWQnOiBpZCxcbiAgICAgICAgICAnbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcbiAgICAgICAgICAnbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgICAgICdzdGVwJzogdGhpcy5vcHRpb25zLnN0ZXBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKGluaXRWYWwpO1xuICAgICAgICB0aGlzLmhhbmRsZXMuZXEoaWR4KS5hdHRyKHtcbiAgICAgICAgICAncm9sZSc6ICdzbGlkZXInLFxuICAgICAgICAgICdhcmlhLWNvbnRyb2xzJzogaWQsXG4gICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxuICAgICAgICAgICdhcmlhLXZhbHVlbWluJzogdGhpcy5vcHRpb25zLnN0YXJ0LFxuICAgICAgICAgICdhcmlhLXZhbHVlbm93JzogaW5pdFZhbCxcbiAgICAgICAgICAnYXJpYS1vcmllbnRhdGlvbic6IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgICAgJ3RhYmluZGV4JzogMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSBpbnB1dCBhbmQgYGFyaWEtdmFsdWVub3dgIHZhbHVlcyBmb3IgdGhlIHNsaWRlciBlbGVtZW50LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGhhbmRsZS5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0VmFsdWVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0VmFsdWVzKCRoYW5kbGUsIHZhbCkge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KCRoYW5kbGUpIDogMDtcbiAgICAgICAgdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwodmFsKTtcbiAgICAgICAgJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBIYW5kbGVzIGV2ZW50cyBvbiB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgaGFuZGxlLlxuICAgICAgICogSWYgdGhlcmUgYXJlIHR3byBoYW5kbGVzIGFuZCB0aGUgYmFyIHdhcyBjbGlja2VkLCBpdCBkZXRlcm1pbmVzIHdoaWNoIGhhbmRsZSB0byBtb3ZlLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgLSB0aGUgYGV2ZW50YCBvYmplY3QgcGFzc2VkIGZyb20gdGhlIGxpc3RlbmVyLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gY2FsY3VsYXRlIGZvciwgaWYgc2VsZWN0ZWQuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsIC0gZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGZvciB0aGUgbmV3IHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAgICAgKiBUT0RPIGNsZWFuIHRoaXMgdXAsIHRoZXJlJ3MgYSBsb3Qgb2YgcmVwZWF0ZWQgY29kZSBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBfc2V0SGFuZGxlUG9zIGZuLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlRXZlbnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFdmVudChlLCAkaGFuZGxlLCB2YWwpIHtcbiAgICAgICAgdmFyIHZhbHVlLCBoYXNWYWw7XG4gICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgLy9jbGljayBvciBkcmFnIGV2ZW50c1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcbiAgICAgICAgICAgICAgcGFyYW0gPSB2ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgICAgZXZlbnRPZmZzZXQgPSB2ZXJ0aWNhbCA/IGUucGFnZVkgOiBlLnBhZ2VYLFxuICAgICAgICAgICAgICBoYWxmT2ZIYW5kbGUgPSB0aGlzLiRoYW5kbGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dIC8gMixcbiAgICAgICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXG4gICAgICAgICAgICAgIHdpbmRvd1Njcm9sbCA9IHZlcnRpY2FsID8gJCh3aW5kb3cpLnNjcm9sbFRvcCgpIDogJCh3aW5kb3cpLnNjcm9sbExlZnQoKTtcblxuICAgICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dO1xuXG4gICAgICAgICAgLy8gdG91Y2ggZXZlbnRzIGVtdWxhdGVkIGJ5IHRoZSB0b3VjaCB1dGlsIGdpdmUgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2NyZWVuLCBhZGQgd2luZG93LnNjcm9sbCB0byBldmVudCBjb29yZGluYXRlcy4uLlxuICAgICAgICAgIC8vIGJlc3Qgd2F5IHRvIGd1ZXNzIHRoaXMgaXMgc2ltdWxhdGVkIGlzIGlmIGNsaWVudFkgPT0gcGFnZVlcbiAgICAgICAgICBpZiAoZS5jbGllbnRZID09PSBlLnBhZ2VZKSB7XG4gICAgICAgICAgICBldmVudE9mZnNldCA9IGV2ZW50T2Zmc2V0ICsgd2luZG93U2Nyb2xsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXZlbnRGcm9tQmFyID0gZXZlbnRPZmZzZXQgLSBlbGVtT2Zmc2V0O1xuICAgICAgICAgIHZhciBiYXJYWTtcbiAgICAgICAgICBpZiAoZXZlbnRGcm9tQmFyIDwgMCkge1xuICAgICAgICAgICAgYmFyWFkgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRGcm9tQmFyID4gYmFyRGltKSB7XG4gICAgICAgICAgICBiYXJYWSA9IGJhckRpbTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFyWFkgPSBldmVudEZyb21CYXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBvZmZzZXRQY3QgPSBwZXJjZW50KGJhclhZLCBiYXJEaW0pO1xuXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl92YWx1ZShvZmZzZXRQY3QpO1xuXG4gICAgICAgICAgLy8gdHVybiBldmVyeXRoaW5nIGFyb3VuZCBmb3IgUlRMLCB5YXkgbWF0aCFcbiAgICAgICAgICBpZiAoRm91bmRhdGlvbi5ydGwoKSAmJiAhdGhpcy5vcHRpb25zLnZlcnRpY2FsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMub3B0aW9ucy5lbmQgLSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IF90aGlzLl9hZGp1c3RWYWx1ZShudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgLy9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xuICAgICAgICAgIGhhc1ZhbCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCEkaGFuZGxlKSB7XG4gICAgICAgICAgICAvL2ZpZ3VyZSBvdXQgd2hpY2ggaGFuZGxlIGl0IGlzLCBwYXNzIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uLlxuICAgICAgICAgICAgdmFyIGZpcnN0SG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZSwgZGlyZWN0aW9uLCBiYXJYWSwgcGFyYW0pLFxuICAgICAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcbiAgICAgICAgICAgICRoYW5kbGUgPSBmaXJzdEhuZGxQb3MgPD0gc2VjbmRIbmRsUG9zID8gdGhpcy4kaGFuZGxlIDogdGhpcy4kaGFuZGxlMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9jaGFuZ2UgZXZlbnQgb24gaW5wdXRcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2FkanVzdFZhbHVlKG51bGwsIHZhbCk7XG4gICAgICAgICAgaGFzVmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcygkaGFuZGxlLCB2YWx1ZSwgaGFzVmFsKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGp1c3RlcyB2YWx1ZSBmb3IgaGFuZGxlIGluIHJlZ2FyZCB0byBzdGVwIHZhbHVlLiByZXR1cm5zIGFkanVzdGVkIHZhbHVlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBzZWxlY3RlZCBoYW5kbGUuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgLSB2YWx1ZSB0byBhZGp1c3QuIHVzZWQgaWYgJGhhbmRsZSBpcyBmYWxzeVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYWRqdXN0VmFsdWUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGp1c3RWYWx1ZSgkaGFuZGxlLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdmFsLFxuICAgICAgICAgICAgc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxuICAgICAgICAgICAgZGl2ID0gcGFyc2VGbG9hdChzdGVwIC8gMiksXG4gICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgcHJldl92YWwsXG4gICAgICAgICAgICBuZXh0X3ZhbDtcbiAgICAgICAgaWYgKCEhJGhhbmRsZSkge1xuICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxlZnQgPSB2YWwgJSBzdGVwO1xuICAgICAgICBwcmV2X3ZhbCA9IHZhbCAtIGxlZnQ7XG4gICAgICAgIG5leHRfdmFsID0gcHJldl92YWwgKyBzdGVwO1xuICAgICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gdmFsID49IHByZXZfdmFsICsgZGl2ID8gbmV4dF92YWwgOiBwcmV2X3ZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc2xpZGVyIGVsZW1lbnRzLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xuICAgICAgICB0aGlzLl9ldmVudHNGb3JIYW5kbGUodGhpcy4kaGFuZGxlKTtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlc1sxXSkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0ZvckhhbmRsZSh0aGlzLiRoYW5kbGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGEgcGFydGljdWxhciBoYW5kbGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGFwcGx5IGxpc3RlbmVycyB0by5cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50c0ZvckhhbmRsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50c0ZvckhhbmRsZSgkaGFuZGxlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBjdXJIYW5kbGUsXG4gICAgICAgICAgICB0aW1lcjtcblxuICAgICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGlkeCA9IF90aGlzLmlucHV0cy5pbmRleCgkKHRoaXMpKTtcbiAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuaGFuZGxlcy5lcShpZHgpLCAkKHRoaXMpLnZhbCgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja1NlbGVjdCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEkKGUudGFyZ2V0KS5pcygnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuJGhhbmRsZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7XG5cbiAgICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XG4gICAgICAgICAgJGhhbmRsZS5vZmYoJ21vdXNlZG93bi56Zi5zbGlkZXInKS5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAkaGFuZGxlLmFkZENsYXNzKCdpcy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgX3RoaXMuJGZpbGwuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7IC8vXG4gICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIHRydWUpO1xuXG4gICAgICAgICAgICBjdXJIYW5kbGUgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgICRib2R5Lm9uKCdtb3VzZW1vdmUuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgY3VySGFuZGxlKTtcbiAgICAgICAgICAgIH0pLm9uKCdtb3VzZXVwLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBjdXJIYW5kbGUpO1xuXG4gICAgICAgICAgICAgICRoYW5kbGUucmVtb3ZlQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XG4gICAgICAgICAgICAgIF90aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gcHJldmVudCBldmVudHMgdHJpZ2dlcmVkIGJ5IHRvdWNoXG4gICAgICAgICAgLm9uKCdzZWxlY3RzdGFydC56Zi5zbGlkZXIgdG91Y2htb3ZlLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFuZGxlLm9mZigna2V5ZG93bi56Zi5zbGlkZXInKS5vbigna2V5ZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBfJGhhbmRsZSA9ICQodGhpcyksXG4gICAgICAgICAgICAgIGlkeCA9IF90aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQgPyBfdGhpcy5oYW5kbGVzLmluZGV4KF8kaGFuZGxlKSA6IDAsXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXG4gICAgICAgICAgICAgIG5ld1ZhbHVlO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdTbGlkZXInLCB7XG4gICAgICAgICAgICBkZWNyZWFzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluY3JlYXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjcmVhc2VfZmFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5jcmVhc2VfZmFzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qaWYgKG5ld1ZhbHVlKSB7IC8vIGlmIHByZXNzZWQga2V5IGhhcyBzcGVjaWFsIGZ1bmN0aW9uLCB1cGRhdGUgdmFsdWVcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoXyRoYW5kbGUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICB9Ki9cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIHNsaWRlciBwbHVnaW4uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlcy5vZmYoJy56Zi5zbGlkZXInKTtcbiAgICAgICAgdGhpcy5pbnB1dHMub2ZmKCcuemYuc2xpZGVyJyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTbGlkZXI7XG4gIH0oKTtcblxuICBTbGlkZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogTWluaW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc3RhcnQ6IDAsXG4gICAgLyoqXG4gICAgICogTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxMDBcbiAgICAgKi9cbiAgICBlbmQ6IDEwMCxcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHZhbHVlIGNoYW5nZSBwZXIgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBzdGVwOiAxLFxuICAgIC8qKlxuICAgICAqIFZhbHVlIGF0IHdoaWNoIHRoZSBoYW5kbGUvaW5wdXQgKihsZWZ0IGhhbmRsZS9maXJzdCBpbnB1dCkqIHNob3VsZCBiZSBzZXQgdG8gb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGluaXRpYWxTdGFydDogMCxcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgcmlnaHQgaGFuZGxlL3NlY29uZCBpbnB1dCBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwMFxuICAgICAqL1xuICAgIGluaXRpYWxFbmQ6IDEwMCxcbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIGlucHV0IHRvIGJlIGxvY2F0ZWQgb3V0c2lkZSB0aGUgY29udGFpbmVyIGFuZCB2aXNpYmxlLiBTZXQgdG8gYnkgdGhlIEpTXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgYmluZGluZzogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGNsaWNrL3RhcCBvbiB0aGUgc2xpZGVyIGJhciB0byBzZWxlY3QgYSB2YWx1ZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIGNsaWNrU2VsZWN0OiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIGFuZCB1c2UgdGhlIGB2ZXJ0aWNhbGAgY2xhc3MgdG8gY2hhbmdlIGFsaWdubWVudCB0byB2ZXJ0aWNhbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB2ZXJ0aWNhbDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGRyYWcgdGhlIHNsaWRlciBoYW5kbGUocykgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIHNsaWRlciBhbmQgcHJldmVudHMgZXZlbnQgbGlzdGVuZXJzIGZyb20gYmVpbmcgYXBwbGllZC4gRG91YmxlIGNoZWNrZWQgYnkgSlMgd2l0aCBgZGlzYWJsZWRDbGFzc2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlIG9mIHR3byBoYW5kbGVzLiBEb3VibGUgY2hlY2tlZCBieSB0aGUgSlMuIENoYW5nZXMgc29tZSBsb2dpYyBoYW5kbGluZy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkb3VibGVTaWRlZDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogUG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlLlxuICAgICAqL1xuICAgIC8vIHN0ZXBzOiAxMDAsXG4gICAgLyoqXG4gICAgICogTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHRoZSBwbHVnaW4gc2hvdWxkIGdvIHRvIGZvciBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGRlY2ltYWw6IDIsXG4gICAgLyoqXG4gICAgICogVGltZSBkZWxheSBmb3IgZHJhZ2dlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgICAvLyBkcmFnRGVsYXk6IDAsXG4gICAgLyoqXG4gICAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDIwMFxuICAgICAqL1xuICAgIG1vdmVUaW1lOiAyMDAsIC8vdXBkYXRlIHRoaXMgaWYgY2hhbmdpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgc2Fzc1xuICAgIC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gZGlzYWJsZWQgc2xpZGVycy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnZGlzYWJsZWQnXG4gICAgICovXG4gICAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcbiAgICAvKipcbiAgICAgKiBXaWxsIGludmVydCB0aGUgZGVmYXVsdCBsYXlvdXQgZm9yIGEgdmVydGljYWw8c3BhbiBkYXRhLXRvb2x0aXAgdGl0bGU9XCJ3aG8gd291bGQgZG8gdGhpcz8/P1wiPiA8L3NwYW4+c2xpZGVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGludmVydFZlcnRpY2FsOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBNaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBgY2hhbmdlZC56Zi1zbGlkZXJgIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB2YWx1ZSBjaGFuZ2UuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNTAwXG4gICAgICovXG4gICAgY2hhbmdlZERlbGF5OiA1MDAsXG4gICAgLyoqXG4gICAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVyc1xuICAgICogQG9wdGlvblxuICAgICogQHR5cGUge251bWJlcn1cbiAgICAqIEBkZWZhdWx0IDVcbiAgICAqL1xuICAgIG5vbkxpbmVhckJhc2U6IDUsXG4gICAgLyoqXG4gICAgKiBCYXNldmFsdWUgZm9yIG5vbi1saW5lYXIgc2xpZGVycywgcG9zc2libGUgdmFsdWVzIGFyZTogYCdsaW5lYXInYCwgYCdwb3cnYCAmIGAnbG9nJ2AuIFBvdyBhbmQgTG9nIHVzZSB0aGUgbm9uTGluZWFyQmFzZSBzZXR0aW5nLlxuICAgICogQG9wdGlvblxuICAgICogQHR5cGUge3N0cmluZ31cbiAgICAqIEBkZWZhdWx0ICdsaW5lYXInXG4gICAgKi9cbiAgICBwb3NpdGlvblZhbHVlRnVuY3Rpb246ICdsaW5lYXInXG4gIH07XG5cbiAgZnVuY3Rpb24gcGVyY2VudChmcmFjLCBudW0pIHtcbiAgICByZXR1cm4gZnJhYyAvIG51bTtcbiAgfVxuICBmdW5jdGlvbiBhYnNQb3NpdGlvbigkaGFuZGxlLCBkaXIsIGNsaWNrUG9zLCBwYXJhbSkge1xuICAgIHJldHVybiBNYXRoLmFicygkaGFuZGxlLnBvc2l0aW9uKClbZGlyXSArICRoYW5kbGVbcGFyYW1dKCkgLyAyIC0gY2xpY2tQb3MpO1xuICB9XG4gIGZ1bmN0aW9uIGJhc2VMb2coYmFzZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coYmFzZSk7XG4gIH1cblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihTbGlkZXIsICdTbGlkZXInKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5zbGlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Sticky module.\n   * @module foundation.sticky\n   * @requires foundation.util.triggers\n   * @requires foundation.util.mediaQuery\n   */\n\n  var Sticky = function () {\n    /**\n     * Creates a new instance of a sticky thing.\n     * @class\n     * @param {jQuery} element - jQuery object to make sticky.\n     * @param {Object} options - options object passed when creating the element programmatically.\n     */\n    function Sticky(element, options) {\n      _classCallCheck(this, Sticky);\n\n      this.$element = element;\n      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);\n\n      this._init();\n\n      Foundation.registerPlugin(this, 'Sticky');\n    }\n\n    /**\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\n     * @function\n     * @private\n     */\n\n\n    _createClass(Sticky, [{\n      key: '_init',\n      value: function _init() {\n        var $parent = this.$element.parent('[data-sticky-container]'),\n            id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),\n            _this = this;\n\n        if (!$parent.length) {\n          this.wasWrapped = true;\n        }\n        this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);\n        this.$container.addClass(this.options.containerClass);\n\n        this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id });\n\n        this.scrollCount = this.options.checkEvery;\n        this.isStuck = false;\n        $(window).one('load.zf.sticky', function () {\n          //We calculate the container height to have correct values for anchor points offset calculation.\n          _this.containerHeight = _this.$element.css(\"display\") == \"none\" ? 0 : _this.$element[0].getBoundingClientRect().height;\n          _this.$container.css('height', _this.containerHeight);\n          _this.elemHeight = _this.containerHeight;\n          if (_this.options.anchor !== '') {\n            _this.$anchor = $('#' + _this.options.anchor);\n          } else {\n            _this._parsePoints();\n          }\n\n          _this._setSizes(function () {\n            var scroll = window.pageYOffset;\n            _this._calc(false, scroll);\n            //Unstick the element will ensure that proper classes are set.\n            if (!_this.isStuck) {\n              _this._removeSticky(scroll >= _this.topPoint ? false : true);\n            }\n          });\n          _this._events(id.split('-').reverse().join('-'));\n        });\n      }\n\n      /**\n       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_parsePoints',\n      value: function _parsePoints() {\n        var top = this.options.topAnchor == \"\" ? 1 : this.options.topAnchor,\n            btm = this.options.btmAnchor == \"\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\n            pts = [top, btm],\n            breaks = {};\n        for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\n          var pt;\n          if (typeof pts[i] === 'number') {\n            pt = pts[i];\n          } else {\n            var place = pts[i].split(':'),\n                anchor = $('#' + place[0]);\n\n            pt = anchor.offset().top;\n            if (place[1] && place[1].toLowerCase() === 'bottom') {\n              pt += anchor[0].getBoundingClientRect().height;\n            }\n          }\n          breaks[i] = pt;\n        }\n\n        this.points = breaks;\n        return;\n      }\n\n      /**\n       * Adds event handlers for the scrolling element.\n       * @private\n       * @param {String} id - psuedo-random id for unique scroll event listener.\n       */\n\n    }, {\n      key: '_events',\n      value: function _events(id) {\n        var _this = this,\n            scrollListener = this.scrollListener = 'scroll.zf.' + id;\n        if (this.isOn) {\n          return;\n        }\n        if (this.canStick) {\n          this.isOn = true;\n          $(window).off(scrollListener).on(scrollListener, function (e) {\n            if (_this.scrollCount === 0) {\n              _this.scrollCount = _this.options.checkEvery;\n              _this._setSizes(function () {\n                _this._calc(false, window.pageYOffset);\n              });\n            } else {\n              _this.scrollCount--;\n              _this._calc(false, window.pageYOffset);\n            }\n          });\n        }\n\n        this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\n          _this._setSizes(function () {\n            _this._calc(false);\n            if (_this.canStick) {\n              if (!_this.isOn) {\n                _this._events(id);\n              }\n            } else if (_this.isOn) {\n              _this._pauseListeners(scrollListener);\n            }\n          });\n        });\n      }\n\n      /**\n       * Removes event handlers for scroll and change events on anchor.\n       * @fires Sticky#pause\n       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\n       */\n\n    }, {\n      key: '_pauseListeners',\n      value: function _pauseListeners(scrollListener) {\n        this.isOn = false;\n        $(window).off(scrollListener);\n\n        /**\n         * Fires when the plugin is paused due to resize event shrinking the view.\n         * @event Sticky#pause\n         * @private\n         */\n        this.$element.trigger('pause.zf.sticky');\n      }\n\n      /**\n       * Called on every `scroll` event and on `_init`\n       * fires functions based on booleans and cached values\n       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\n       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\n       */\n\n    }, {\n      key: '_calc',\n      value: function _calc(checkSizes, scroll) {\n        if (checkSizes) {\n          this._setSizes();\n        }\n\n        if (!this.canStick) {\n          if (this.isStuck) {\n            this._removeSticky(true);\n          }\n          return false;\n        }\n\n        if (!scroll) {\n          scroll = window.pageYOffset;\n        }\n\n        if (scroll >= this.topPoint) {\n          if (scroll <= this.bottomPoint) {\n            if (!this.isStuck) {\n              this._setSticky();\n            }\n          } else {\n            if (this.isStuck) {\n              this._removeSticky(false);\n            }\n          }\n        } else {\n          if (this.isStuck) {\n            this._removeSticky(true);\n          }\n        }\n      }\n\n      /**\n       * Causes the $element to become stuck.\n       * Adds `position: fixed;`, and helper classes.\n       * @fires Sticky#stuckto\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_setSticky',\n      value: function _setSticky() {\n        var _this = this,\n            stickTo = this.options.stickTo,\n            mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\n            notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\n            css = {};\n\n        css[mrgn] = this.options[mrgn] + 'em';\n        css[stickTo] = 0;\n        css[notStuckTo] = 'auto';\n        this.isStuck = true;\n        this.$element.removeClass('is-anchored is-at-' + notStuckTo).addClass('is-stuck is-at-' + stickTo).css(css)\n        /**\n         * Fires when the $element has become `position: fixed;`\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\n         * @event Sticky#stuckto\n         */\n        .trigger('sticky.zf.stuckto:' + stickTo);\n        this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function () {\n          _this._setSizes();\n        });\n      }\n\n      /**\n       * Causes the $element to become unstuck.\n       * Removes `position: fixed;`, and helper classes.\n       * Adds other helper classes.\n       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\n       * @fires Sticky#unstuckfrom\n       * @private\n       */\n\n    }, {\n      key: '_removeSticky',\n      value: function _removeSticky(isTop) {\n        var stickTo = this.options.stickTo,\n            stickToTop = stickTo === 'top',\n            css = {},\n            anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n            mrgn = stickToTop ? 'marginTop' : 'marginBottom',\n            notStuckTo = stickToTop ? 'bottom' : 'top',\n            topOrBottom = isTop ? 'top' : 'bottom';\n\n        css[mrgn] = 0;\n\n        css['bottom'] = 'auto';\n        if (isTop) {\n          css['top'] = 0;\n        } else {\n          css['top'] = anchorPt;\n        }\n\n        this.isStuck = false;\n        this.$element.removeClass('is-stuck is-at-' + stickTo).addClass('is-anchored is-at-' + topOrBottom).css(css)\n        /**\n         * Fires when the $element has become anchored.\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\n         * @event Sticky#unstuckfrom\n         */\n        .trigger('sticky.zf.unstuckfrom:' + topOrBottom);\n      }\n\n      /**\n       * Sets the $element and $container sizes for plugin.\n       * Calls `_setBreakPoints`.\n       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\n       * @private\n       */\n\n    }, {\n      key: '_setSizes',\n      value: function _setSizes(cb) {\n        this.canStick = Foundation.MediaQuery.is(this.options.stickyOn);\n        if (!this.canStick) {\n          if (cb && typeof cb === 'function') {\n            cb();\n          }\n        }\n        var _this = this,\n            newElemWidth = this.$container[0].getBoundingClientRect().width,\n            comp = window.getComputedStyle(this.$container[0]),\n            pdngl = parseInt(comp['padding-left'], 10),\n            pdngr = parseInt(comp['padding-right'], 10);\n\n        if (this.$anchor && this.$anchor.length) {\n          this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\n        } else {\n          this._parsePoints();\n        }\n\n        this.$element.css({\n          'max-width': newElemWidth - pdngl - pdngr + 'px'\n        });\n\n        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\n        if (this.$element.css(\"display\") == \"none\") {\n          newContainerHeight = 0;\n        }\n        this.containerHeight = newContainerHeight;\n        this.$container.css({\n          height: newContainerHeight\n        });\n        this.elemHeight = newContainerHeight;\n\n        if (!this.isStuck) {\n          if (this.$element.hasClass('is-at-bottom')) {\n            var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\n            this.$element.css('top', anchorPt);\n          }\n        }\n\n        this._setBreakPoints(newContainerHeight, function () {\n          if (cb && typeof cb === 'function') {\n            cb();\n          }\n        });\n      }\n\n      /**\n       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\n       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\n       * @param {Function} cb - optional callback function to be called on completion.\n       * @private\n       */\n\n    }, {\n      key: '_setBreakPoints',\n      value: function _setBreakPoints(elemHeight, cb) {\n        if (!this.canStick) {\n          if (cb && typeof cb === 'function') {\n            cb();\n          } else {\n            return false;\n          }\n        }\n        var mTop = emCalc(this.options.marginTop),\n            mBtm = emCalc(this.options.marginBottom),\n            topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\n            bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\n\n        // topPoint = this.$anchor.offset().top || this.points[0],\n        // bottomPoint = topPoint + this.anchorHeight || this.points[1],\n        winHeight = window.innerHeight;\n\n        if (this.options.stickTo === 'top') {\n          topPoint -= mTop;\n          bottomPoint -= elemHeight + mTop;\n        } else if (this.options.stickTo === 'bottom') {\n          topPoint -= winHeight - (elemHeight + mBtm);\n          bottomPoint -= winHeight - mBtm;\n        } else {\n          //this would be the stickTo: both option... tricky\n        }\n\n        this.topPoint = topPoint;\n        this.bottomPoint = bottomPoint;\n\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      }\n\n      /**\n       * Destroys the current sticky element.\n       * Resets the element to the top position first.\n       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._removeSticky(true);\n\n        this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top').css({\n          height: '',\n          top: '',\n          bottom: '',\n          'max-width': ''\n        }).off('resizeme.zf.trigger');\n        if (this.$anchor && this.$anchor.length) {\n          this.$anchor.off('change.zf.sticky');\n        }\n        $(window).off(this.scrollListener);\n\n        if (this.wasWrapped) {\n          this.$element.unwrap();\n        } else {\n          this.$container.removeClass(this.options.containerClass).css({\n            height: ''\n          });\n        }\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Sticky;\n  }();\n\n  Sticky.defaults = {\n    /**\n     * Customizable container template. Add your own classes for styling and sizing.\n     * @option\n     * @type {string}\n     * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\n     */\n    container: '<div data-sticky-container></div>',\n    /**\n     * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\n     * @option\n     * @type {string}\n     * @default 'top'\n     */\n    stickTo: 'top',\n    /**\n     * If anchored to a single element, the id of that element.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    anchor: '',\n    /**\n     * If using more than one element as anchor points, the id of the top anchor.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    topAnchor: '',\n    /**\n     * If using more than one element as anchor points, the id of the bottom anchor.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    btmAnchor: '',\n    /**\n     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\n     * @option\n     * @type {number}\n     * @default 1\n     */\n    marginTop: 1,\n    /**\n     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\n     * @option\n     * @type {number}\n     * @default 1\n     */\n    marginBottom: 1,\n    /**\n     * Breakpoint string that is the minimum screen size an element should become sticky.\n     * @option\n     * @type {string}\n     * @default 'medium'\n     */\n    stickyOn: 'medium',\n    /**\n     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\n     * @option\n     * @type {string}\n     * @default 'sticky'\n     */\n    stickyClass: 'sticky',\n    /**\n     * Class applied to sticky container. Foundation defaults to `sticky-container`.\n     * @option\n     * @type {string}\n     * @default 'sticky-container'\n     */\n    containerClass: 'sticky-container',\n    /**\n     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\n     * @option\n     * @type {number}\n     * @default -1\n     */\n    checkEvery: -1\n  };\n\n  /**\n   * Helper function to calculate em values\n   * @param Number {em} - number of em's to calculate into pixels\n   */\n  function emCalc(em) {\n    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\n  }\n\n  // Window exports\n  Foundation.plugin(Sticky, 'Sticky');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uc3RpY2t5LmpzPzQwYjIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvKipcbiAgICogU3RpY2t5IG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnN0aWNreVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKi9cblxuICB2YXIgU3RpY2t5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBzdGlja3kgdGhpbmcuXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2Ugc3RpY2t5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBvYmplY3QgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIGVsZW1lbnQgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGlja3koZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0aWNreSk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFN0aWNreS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1N0aWNreScpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgZWxlbWVudCBieSBhZGRpbmcgY2xhc3NlcywgZ2V0dGluZy9zZXR0aW5nIGRpbWVuc2lvbnMsIGJyZWFrcG9pbnRzIGFuZCBhdHRyaWJ1dGVzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFN0aWNreSwgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl0nKSxcbiAgICAgICAgICAgIGlkID0gdGhpcy4kZWxlbWVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdzdGlja3knKSxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoISRwYXJlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy53YXNXcmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRjb250YWluZXIgPSAkcGFyZW50Lmxlbmd0aCA/ICRwYXJlbnQgOiAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpLndyYXBJbm5lcih0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcyk7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MpLmF0dHIoeyAnZGF0YS1yZXNpemUnOiBpZCB9KTtcblxuICAgICAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xuICAgICAgICAkKHdpbmRvdykub25lKCdsb2FkLnpmLnN0aWNreScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvL1dlIGNhbGN1bGF0ZSB0aGUgY29udGFpbmVyIGhlaWdodCB0byBoYXZlIGNvcnJlY3QgdmFsdWVzIGZvciBhbmNob3IgcG9pbnRzIG9mZnNldCBjYWxjdWxhdGlvbi5cbiAgICAgICAgICBfdGhpcy5jb250YWluZXJIZWlnaHQgPSBfdGhpcy4kZWxlbWVudC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiID8gMCA6IF90aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICBfdGhpcy4kY29udGFpbmVyLmNzcygnaGVpZ2h0JywgX3RoaXMuY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgICBfdGhpcy5lbGVtSGVpZ2h0ID0gX3RoaXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmFuY2hvciAhPT0gJycpIHtcbiAgICAgICAgICAgIF90aGlzLiRhbmNob3IgPSAkKCcjJyArIF90aGlzLm9wdGlvbnMuYW5jaG9yKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX3BhcnNlUG9pbnRzKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgc2Nyb2xsKTtcbiAgICAgICAgICAgIC8vVW5zdGljayB0aGUgZWxlbWVudCB3aWxsIGVuc3VyZSB0aGF0IHByb3BlciBjbGFzc2VzIGFyZSBzZXQuXG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVN0aWNreShzY3JvbGwgPj0gX3RoaXMudG9wUG9pbnQgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLl9ldmVudHMoaWQuc3BsaXQoJy0nKS5yZXZlcnNlKCkuam9pbignLScpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSWYgdXNpbmcgbXVsdGlwbGUgZWxlbWVudHMgYXMgYW5jaG9ycywgY2FsY3VsYXRlcyB0aGUgdG9wIGFuZCBib3R0b20gcGl4ZWwgdmFsdWVzIHRoZSBzdGlja3kgdGhpbmcgc2hvdWxkIHN0aWNrIGFuZCB1bnN0aWNrIG9uLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcGFyc2VQb2ludHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZVBvaW50cygpIHtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMub3B0aW9ucy50b3BBbmNob3IgPT0gXCJcIiA/IDEgOiB0aGlzLm9wdGlvbnMudG9wQW5jaG9yLFxuICAgICAgICAgICAgYnRtID0gdGhpcy5vcHRpb25zLmJ0bUFuY2hvciA9PSBcIlwiID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHRoaXMub3B0aW9ucy5idG1BbmNob3IsXG4gICAgICAgICAgICBwdHMgPSBbdG9wLCBidG1dLFxuICAgICAgICAgICAgYnJlYWtzID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwdHMubGVuZ3RoOyBpIDwgbGVuICYmIHB0c1tpXTsgaSsrKSB7XG4gICAgICAgICAgdmFyIHB0O1xuICAgICAgICAgIGlmICh0eXBlb2YgcHRzW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcHQgPSBwdHNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwbGFjZSA9IHB0c1tpXS5zcGxpdCgnOicpLFxuICAgICAgICAgICAgICAgIGFuY2hvciA9ICQoJyMnICsgcGxhY2VbMF0pO1xuXG4gICAgICAgICAgICBwdCA9IGFuY2hvci5vZmZzZXQoKS50b3A7XG4gICAgICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgcHQgKz0gYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtzW2ldID0gcHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvaW50cyA9IGJyZWFrcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBzY3JvbGxpbmcgZWxlbWVudC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBwc3VlZG8tcmFuZG9tIGlkIGZvciB1bmlxdWUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfZXZlbnRzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKGlkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgICAgICBzY3JvbGxMaXN0ZW5lciA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSAnc2Nyb2xsLnpmLicgKyBpZDtcbiAgICAgICAgaWYgKHRoaXMuaXNPbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5TdGljaykge1xuICAgICAgICAgIHRoaXMuaXNPbiA9IHRydWU7XG4gICAgICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcikub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Nyb2xsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQgPSBfdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XG4gICAgICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsQ291bnQtLTtcbiAgICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UsIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZigncmVzaXplbWUuemYudHJpZ2dlcicpLm9uKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUsIGVsKSB7XG4gICAgICAgICAgX3RoaXMuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jYW5TdGljaykge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzT24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzKGlkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5pc09uKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHNjcm9sbCBhbmQgY2hhbmdlIGV2ZW50cyBvbiBhbmNob3IuXG4gICAgICAgKiBAZmlyZXMgU3RpY2t5I3BhdXNlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Nyb2xsTGlzdGVuZXIgLSB1bmlxdWUsIG5hbWVzcGFjZWQgc2Nyb2xsIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGB3aW5kb3dgXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19wYXVzZUxpc3RlbmVycycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhdXNlTGlzdGVuZXJzKHNjcm9sbExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xuICAgICAgICAkKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGlzIHBhdXNlZCBkdWUgdG8gcmVzaXplIGV2ZW50IHNocmlua2luZyB0aGUgdmlldy5cbiAgICAgICAgICogQGV2ZW50IFN0aWNreSNwYXVzZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwYXVzZS56Zi5zdGlja3knKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcbiAgICAgICAqIGZpcmVzIGZ1bmN0aW9ucyBiYXNlZCBvbiBib29sZWFucyBhbmQgY2FjaGVkIHZhbHVlc1xuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBjaGVja1NpemVzIC0gdHJ1ZSBpZiBwbHVnaW4gc2hvdWxkIHJlY2FsY3VsYXRlIHNpemVzIGFuZCBicmVha3BvaW50cy5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfY2FsYycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGMoY2hlY2tTaXplcywgc2Nyb2xsKSB7XG4gICAgICAgIGlmIChjaGVja1NpemVzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0U2l6ZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nyb2xsID49IHRoaXMudG9wUG9pbnQpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsIDw9IHRoaXMuYm90dG9tUG9pbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN0aWNreSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYXVzZXMgdGhlICRlbGVtZW50IHRvIGJlY29tZSBzdHVjay5cbiAgICAgICAqIEFkZHMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAgICAgKiBAZmlyZXMgU3RpY2t5I3N0dWNrdG9cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldFN0aWNreScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0aWNreSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIHN0aWNrVG8gPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcbiAgICAgICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUbyA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnLFxuICAgICAgICAgICAgY3NzID0ge307XG5cbiAgICAgICAgY3NzW21yZ25dID0gdGhpcy5vcHRpb25zW21yZ25dICsgJ2VtJztcbiAgICAgICAgY3NzW3N0aWNrVG9dID0gMDtcbiAgICAgICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLmlzU3R1Y2sgPSB0cnVlO1xuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1hbmNob3JlZCBpcy1hdC0nICsgbm90U3R1Y2tUbykuYWRkQ2xhc3MoJ2lzLXN0dWNrIGlzLWF0LScgKyBzdGlja1RvKS5jc3MoY3NzKVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBgcG9zaXRpb246IGZpeGVkO2BcbiAgICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnN0dWNrdG86dG9wYFxuICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3N0dWNrdG9cbiAgICAgICAgICovXG4gICAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYuc3R1Y2t0bzonICsgc3RpY2tUbyk7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oXCJ0cmFuc2l0aW9uZW5kIHdlYmtpdFRyYW5zaXRpb25FbmQgb1RyYW5zaXRpb25FbmQgb3RyYW5zaXRpb25lbmQgTVNUcmFuc2l0aW9uRW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgdW5zdHVjay5cbiAgICAgICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAgICAgKiBBZGRzIG90aGVyIGhlbHBlciBjbGFzc2VzLlxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1RvcCAtIHRlbGxzIHRoZSBmdW5jdGlvbiBpZiB0aGUgJGVsZW1lbnQgc2hvdWxkIGFuY2hvciB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiBpdHMgJGFuY2hvciBlbGVtZW50LlxuICAgICAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3JlbW92ZVN0aWNreScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVN0aWNreShpc1RvcCkge1xuICAgICAgICB2YXIgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxuICAgICAgICAgICAgc3RpY2tUb1RvcCA9IHN0aWNrVG8gPT09ICd0b3AnLFxuICAgICAgICAgICAgY3NzID0ge30sXG4gICAgICAgICAgICBhbmNob3JQdCA9ICh0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIC0gdGhpcy5wb2ludHNbMF0gOiB0aGlzLmFuY2hvckhlaWdodCkgLSB0aGlzLmVsZW1IZWlnaHQsXG4gICAgICAgICAgICBtcmduID0gc3RpY2tUb1RvcCA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXG4gICAgICAgICAgICBub3RTdHVja1RvID0gc3RpY2tUb1RvcCA/ICdib3R0b20nIDogJ3RvcCcsXG4gICAgICAgICAgICB0b3BPckJvdHRvbSA9IGlzVG9wID8gJ3RvcCcgOiAnYm90dG9tJztcblxuICAgICAgICBjc3NbbXJnbl0gPSAwO1xuXG4gICAgICAgIGNzc1snYm90dG9tJ10gPSAnYXV0byc7XG4gICAgICAgIGlmIChpc1RvcCkge1xuICAgICAgICAgIGNzc1sndG9wJ10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNzc1sndG9wJ10gPSBhbmNob3JQdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNTdHVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1zdHVjayBpcy1hdC0nICsgc3RpY2tUbykuYWRkQ2xhc3MoJ2lzLWFuY2hvcmVkIGlzLWF0LScgKyB0b3BPckJvdHRvbSkuY3NzKGNzcylcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlICRlbGVtZW50IGhhcyBiZWNvbWUgYW5jaG9yZWQuXG4gICAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi51bnN0dWNrZnJvbTpib3R0b21gXG4gICAgICAgICAqIEBldmVudCBTdGlja3kjdW5zdHVja2Zyb21cbiAgICAgICAgICovXG4gICAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYudW5zdHVja2Zyb206JyArIHRvcE9yQm90dG9tKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIHRoZSAkZWxlbWVudCBhbmQgJGNvbnRhaW5lciBzaXplcyBmb3IgcGx1Z2luLlxuICAgICAgICogQ2FsbHMgYF9zZXRCcmVha1BvaW50c2AuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRTaXplcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemVzKGNiKSB7XG4gICAgICAgIHRoaXMuY2FuU3RpY2sgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuaXModGhpcy5vcHRpb25zLnN0aWNreU9uKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhblN0aWNrKSB7XG4gICAgICAgICAgaWYgKGNiICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgICAgIG5ld0VsZW1XaWR0aCA9IHRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxcbiAgICAgICAgICAgIGNvbXAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pLFxuICAgICAgICAgICAgcGRuZ2wgPSBwYXJzZUludChjb21wWydwYWRkaW5nLWxlZnQnXSwgMTApLFxuICAgICAgICAgICAgcGRuZ3IgPSBwYXJzZUludChjb21wWydwYWRkaW5nLXJpZ2h0J10sIDEwKTtcblxuICAgICAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmFuY2hvckhlaWdodCA9IHRoaXMuJGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fcGFyc2VQb2ludHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcbiAgICAgICAgICAnbWF4LXdpZHRoJzogbmV3RWxlbVdpZHRoIC0gcGRuZ2wgLSBwZG5nciArICdweCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIG5ld0NvbnRhaW5lckhlaWdodCA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IHx8IHRoaXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgbmV3Q29udGFpbmVySGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmNzcyh7XG4gICAgICAgICAgaGVpZ2h0OiBuZXdDb250YWluZXJIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWxlbUhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNTdHVjaykge1xuICAgICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1hdC1ib3R0b20nKSkge1xuICAgICAgICAgICAgdmFyIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkudG9wIDogdGhpcy5hbmNob3JIZWlnaHQpIC0gdGhpcy5lbGVtSGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoJ3RvcCcsIGFuY2hvclB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRCcmVha1BvaW50cyhuZXdDb250YWluZXJIZWlnaHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJyZWFrcG9pbnRzIGZvciB0aGUgZWxlbWVudCB0byBiZWNvbWUgc3RpY2t5L3Vuc3RpY2t5LlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGVsZW1IZWlnaHQgLSBweCB2YWx1ZSBmb3Igc3RpY2t5LiRlbGVtZW50IGhlaWdodCwgY2FsY3VsYXRlZCBieSBgX3NldFNpemVzYC5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGNvbXBsZXRpb24uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfc2V0QnJlYWtQb2ludHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRCcmVha1BvaW50cyhlbGVtSGVpZ2h0LCBjYikge1xuICAgICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcbiAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxuICAgICAgICAgICAgbUJ0bSA9IGVtQ2FsYyh0aGlzLm9wdGlvbnMubWFyZ2luQm90dG9tKSxcbiAgICAgICAgICAgIHRvcFBvaW50ID0gdGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1swXSA6IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AsXG4gICAgICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxuXG4gICAgICAgIC8vIHRvcFBvaW50ID0gdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCB8fCB0aGlzLnBvaW50c1swXSxcbiAgICAgICAgLy8gYm90dG9tUG9pbnQgPSB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0IHx8IHRoaXMucG9pbnRzWzFdLFxuICAgICAgICB3aW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xuICAgICAgICAgIHRvcFBvaW50IC09IG1Ub3A7XG4gICAgICAgICAgYm90dG9tUG9pbnQgLT0gZWxlbUhlaWdodCArIG1Ub3A7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdG9wUG9pbnQgLT0gd2luSGVpZ2h0IC0gKGVsZW1IZWlnaHQgKyBtQnRtKTtcbiAgICAgICAgICBib3R0b21Qb2ludCAtPSB3aW5IZWlnaHQgLSBtQnRtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vdGhpcyB3b3VsZCBiZSB0aGUgc3RpY2tUbzogYm90aCBvcHRpb24uLi4gdHJpY2t5XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvcFBvaW50ID0gdG9wUG9pbnQ7XG4gICAgICAgIHRoaXMuYm90dG9tUG9pbnQgPSBib3R0b21Qb2ludDtcblxuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHN0aWNreSBlbGVtZW50LlxuICAgICAgICogUmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3AgcG9zaXRpb24gZmlyc3QuXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzICsgJyBpcy1hbmNob3JlZCBpcy1hdC10b3AnKS5jc3Moe1xuICAgICAgICAgIGhlaWdodDogJycsXG4gICAgICAgICAgdG9wOiAnJyxcbiAgICAgICAgICBib3R0b206ICcnLFxuICAgICAgICAgICdtYXgtd2lkdGgnOiAnJ1xuICAgICAgICB9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy4kYW5jaG9yLm9mZignY2hhbmdlLnpmLnN0aWNreScpO1xuICAgICAgICB9XG4gICAgICAgICQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKHRoaXMud2FzV3JhcHBlZCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudW53cmFwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtcbiAgICAgICAgICAgIGhlaWdodDogJydcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFN0aWNreTtcbiAgfSgpO1xuXG4gIFN0aWNreS5kZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBDdXN0b21pemFibGUgY29udGFpbmVyIHRlbXBsYXRlLiBBZGQgeW91ciBvd24gY2xhc3NlcyBmb3Igc3R5bGluZyBhbmQgc2l6aW5nLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcmbHQ7ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lciZndDsmbHQ7L2RpdiZndDsnXG4gICAgICovXG4gICAgY29udGFpbmVyOiAnPGRpdiBkYXRhLXN0aWNreS1jb250YWluZXI+PC9kaXY+JyxcbiAgICAvKipcbiAgICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uIENhbiBiZSBgJ3RvcCdgIG9yIGAnYm90dG9tJ2AuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3RvcCdcbiAgICAgKi9cbiAgICBzdGlja1RvOiAndG9wJyxcbiAgICAvKipcbiAgICAgKiBJZiBhbmNob3JlZCB0byBhIHNpbmdsZSBlbGVtZW50LCB0aGUgaWQgb2YgdGhhdCBlbGVtZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgYW5jaG9yOiAnJyxcbiAgICAvKipcbiAgICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSB0b3AgYW5jaG9yLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgdG9wQW5jaG9yOiAnJyxcbiAgICAvKipcbiAgICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSBib3R0b20gYW5jaG9yLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICcnXG4gICAgICovXG4gICAgYnRtQW5jaG9yOiAnJyxcbiAgICAvKipcbiAgICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIG1hcmdpblRvcDogMSxcbiAgICAvKipcbiAgICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgYm90dG9tIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIG1hcmdpbkJvdHRvbTogMSxcbiAgICAvKipcbiAgICAgKiBCcmVha3BvaW50IHN0cmluZyB0aGF0IGlzIHRoZSBtaW5pbXVtIHNjcmVlbiBzaXplIGFuIGVsZW1lbnQgc2hvdWxkIGJlY29tZSBzdGlja3kuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ21lZGl1bSdcbiAgICAgKi9cbiAgICBzdGlja3lPbjogJ21lZGl1bScsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgZWxlbWVudCwgYW5kIHJlbW92ZWQgb24gZGVzdHJ1Y3Rpb24uIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreWAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3N0aWNreSdcbiAgICAgKi9cbiAgICBzdGlja3lDbGFzczogJ3N0aWNreScsXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgY29udGFpbmVyLiBGb3VuZGF0aW9uIGRlZmF1bHRzIHRvIGBzdGlja3ktY29udGFpbmVyYC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnc3RpY2t5LWNvbnRhaW5lcidcbiAgICAgKi9cbiAgICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiBzY3JvbGwgZXZlbnRzIGJldHdlZW4gdGhlIHBsdWdpbidzIHJlY2FsY3VsYXRpbmcgc3RpY2t5IHBvaW50cy4gU2V0dGluZyBpdCB0byBgMGAgd2lsbCBjYXVzZSBpdCB0byByZWNhbGMgZXZlcnkgc2Nyb2xsIGV2ZW50LCBzZXR0aW5nIGl0IHRvIGAtMWAgd2lsbCBwcmV2ZW50IHJlY2FsYyBvbiBzY3JvbGwuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICBjaGVja0V2ZXJ5OiAtMVxuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xuICAgKiBAcGFyYW0gTnVtYmVyIHtlbX0gLSBudW1iZXIgb2YgZW0ncyB0byBjYWxjdWxhdGUgaW50byBwaXhlbHNcbiAgICovXG4gIGZ1bmN0aW9uIGVtQ2FsYyhlbSkge1xuICAgIHJldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LCBudWxsKS5mb250U2l6ZSwgMTApICogZW07XG4gIH1cblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihTdGlja3ksICdTdGlja3knKTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5zdGlja3kuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 17 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Tabs module.\n   * @module foundation.tabs\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.timerAndImageLoader if tabs contain images\n   */\n\n  var Tabs = function () {\n    /**\n     * Creates a new instance of tabs.\n     * @class\n     * @fires Tabs#init\n     * @param {jQuery} element - jQuery object to make into tabs.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Tabs(element, options) {\n      _classCallCheck(this, Tabs);\n\n      this.$element = element;\n      this.options = $.extend({}, Tabs.defaults, this.$element.data(), options);\n\n      this._init();\n      Foundation.registerPlugin(this, 'Tabs');\n      Foundation.Keyboard.register('Tabs', {\n        'ENTER': 'open',\n        'SPACE': 'open',\n        'ARROW_RIGHT': 'next',\n        'ARROW_UP': 'previous',\n        'ARROW_DOWN': 'next',\n        'ARROW_LEFT': 'previous'\n        // 'TAB': 'next',\n        // 'SHIFT_TAB': 'previous'\n      });\n    }\n\n    /**\n     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.\n     * @private\n     */\n\n\n    _createClass(Tabs, [{\n      key: '_init',\n      value: function _init() {\n        var _this2 = this;\n\n        var _this = this;\n\n        this.$element.attr({ 'role': 'tablist' });\n        this.$tabTitles = this.$element.find('.' + this.options.linkClass);\n        this.$tabContent = $('[data-tabs-content=\"' + this.$element[0].id + '\"]');\n\n        this.$tabTitles.each(function () {\n          var $elem = $(this),\n              $link = $elem.find('a'),\n              isActive = $elem.hasClass('' + _this.options.linkActiveClass),\n              hash = $link[0].hash.slice(1),\n              linkId = $link[0].id ? $link[0].id : hash + '-label',\n              $tabContent = $('#' + hash);\n\n          $elem.attr({ 'role': 'presentation' });\n\n          $link.attr({\n            'role': 'tab',\n            'aria-controls': hash,\n            'aria-selected': isActive,\n            'id': linkId\n          });\n\n          $tabContent.attr({\n            'role': 'tabpanel',\n            'aria-hidden': !isActive,\n            'aria-labelledby': linkId\n          });\n\n          if (isActive && _this.options.autoFocus) {\n            $(window).load(function () {\n              $('html, body').animate({ scrollTop: $elem.offset().top }, _this.options.deepLinkSmudgeDelay, function () {\n                $link.focus();\n              });\n            });\n          }\n        });\n        if (this.options.matchHeight) {\n          var $images = this.$tabContent.find('img');\n\n          if ($images.length) {\n            Foundation.onImagesLoaded($images, this._setHeight.bind(this));\n          } else {\n            this._setHeight();\n          }\n        }\n\n        //current context-bound function to open tabs on page load or history popstate\n        this._checkDeepLink = function () {\n          var anchor = window.location.hash;\n          //need a hash and a relevant anchor in this tabset\n          if (anchor.length) {\n            var $link = _this2.$element.find('[href=\"' + anchor + '\"]');\n            if ($link.length) {\n              _this2.selectTab($(anchor), true);\n\n              //roll up a little to show the titles\n              if (_this2.options.deepLinkSmudge) {\n                var offset = _this2.$element.offset();\n                $('html, body').animate({ scrollTop: offset.top }, _this2.options.deepLinkSmudgeDelay);\n              }\n\n              /**\n                * Fires when the zplugin has deeplinked at pageload\n                * @event Tabs#deeplink\n                */\n              _this2.$element.trigger('deeplink.zf.tabs', [$link, $(anchor)]);\n            }\n          }\n        };\n\n        //use browser to open a tab, if it exists in this tabset\n        if (this.options.deepLink) {\n          this._checkDeepLink();\n        }\n\n        this._events();\n      }\n\n      /**\n       * Adds event handlers for items within the tabs.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        this._addKeyHandler();\n        this._addClickHandler();\n        this._setHeightMqHandler = null;\n\n        if (this.options.matchHeight) {\n          this._setHeightMqHandler = this._setHeight.bind(this);\n\n          $(window).on('changed.zf.mediaquery', this._setHeightMqHandler);\n        }\n\n        if (this.options.deepLink) {\n          $(window).on('popstate', this._checkDeepLink);\n        }\n      }\n\n      /**\n       * Adds click handlers for items within the tabs.\n       * @private\n       */\n\n    }, {\n      key: '_addClickHandler',\n      value: function _addClickHandler() {\n        var _this = this;\n\n        this.$element.off('click.zf.tabs').on('click.zf.tabs', '.' + this.options.linkClass, function (e) {\n          e.preventDefault();\n          e.stopPropagation();\n          _this._handleTabChange($(this));\n        });\n      }\n\n      /**\n       * Adds keyboard event handlers for items within the tabs.\n       * @private\n       */\n\n    }, {\n      key: '_addKeyHandler',\n      value: function _addKeyHandler() {\n        var _this = this;\n\n        this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {\n          if (e.which === 9) return;\n\n          var $element = $(this),\n              $elements = $element.parent('ul').children('li'),\n              $prevElement,\n              $nextElement;\n\n          $elements.each(function (i) {\n            if ($(this).is($element)) {\n              if (_this.options.wrapOnKeys) {\n                $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);\n                $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);\n              } else {\n                $prevElement = $elements.eq(Math.max(0, i - 1));\n                $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\n              }\n              return;\n            }\n          });\n\n          // handle keyboard event with keyboard util\n          Foundation.Keyboard.handleKey(e, 'Tabs', {\n            open: function () {\n              $element.find('[role=\"tab\"]').focus();\n              _this._handleTabChange($element);\n            },\n            previous: function () {\n              $prevElement.find('[role=\"tab\"]').focus();\n              _this._handleTabChange($prevElement);\n            },\n            next: function () {\n              $nextElement.find('[role=\"tab\"]').focus();\n              _this._handleTabChange($nextElement);\n            },\n            handled: function () {\n              e.stopPropagation();\n              e.preventDefault();\n            }\n          });\n        });\n      }\n\n      /**\n       * Opens the tab `$targetContent` defined by `$target`. Collapses active tab.\n       * @param {jQuery} $target - Tab to open.\n       * @param {boolean} historyHandled - browser has already handled a history update\n       * @fires Tabs#change\n       * @function\n       */\n\n    }, {\n      key: '_handleTabChange',\n      value: function _handleTabChange($target, historyHandled) {\n\n        /**\n         * Check for active class on target. Collapse if exists.\n         */\n        if ($target.hasClass('' + this.options.linkActiveClass)) {\n          if (this.options.activeCollapse) {\n            this._collapseTab($target);\n\n            /**\n             * Fires when the zplugin has successfully collapsed tabs.\n             * @event Tabs#collapse\n             */\n            this.$element.trigger('collapse.zf.tabs', [$target]);\n          }\n          return;\n        }\n\n        var $oldTab = this.$element.find('.' + this.options.linkClass + '.' + this.options.linkActiveClass),\n            $tabLink = $target.find('[role=\"tab\"]'),\n            hash = $tabLink[0].hash,\n            $targetContent = this.$tabContent.find(hash);\n\n        //close old tab\n        this._collapseTab($oldTab);\n\n        //open new tab\n        this._openTab($target);\n\n        //either replace or update browser history\n        if (this.options.deepLink && !historyHandled) {\n          var anchor = $target.find('a').attr('href');\n\n          if (this.options.updateHistory) {\n            history.pushState({}, '', anchor);\n          } else {\n            history.replaceState({}, '', anchor);\n          }\n        }\n\n        /**\n         * Fires when the plugin has successfully changed tabs.\n         * @event Tabs#change\n         */\n        this.$element.trigger('change.zf.tabs', [$target, $targetContent]);\n\n        //fire to children a mutation event\n        $targetContent.find(\"[data-mutate]\").trigger(\"mutateme.zf.trigger\");\n      }\n\n      /**\n       * Opens the tab `$targetContent` defined by `$target`.\n       * @param {jQuery} $target - Tab to Open.\n       * @function\n       */\n\n    }, {\n      key: '_openTab',\n      value: function _openTab($target) {\n        var $tabLink = $target.find('[role=\"tab\"]'),\n            hash = $tabLink[0].hash,\n            $targetContent = this.$tabContent.find(hash);\n\n        $target.addClass('' + this.options.linkActiveClass);\n\n        $tabLink.attr({ 'aria-selected': 'true' });\n\n        $targetContent.addClass('' + this.options.panelActiveClass).attr({ 'aria-hidden': 'false' });\n      }\n\n      /**\n       * Collapses `$targetContent` defined by `$target`.\n       * @param {jQuery} $target - Tab to Open.\n       * @function\n       */\n\n    }, {\n      key: '_collapseTab',\n      value: function _collapseTab($target) {\n        var $target_anchor = $target.removeClass('' + this.options.linkActiveClass).find('[role=\"tab\"]').attr({ 'aria-selected': 'false' });\n\n        $('#' + $target_anchor.attr('aria-controls')).removeClass('' + this.options.panelActiveClass).attr({ 'aria-hidden': 'true' });\n      }\n\n      /**\n       * Public method for selecting a content pane to display.\n       * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.\n       * @param {boolean} historyHandled - browser has already handled a history update\n       * @function\n       */\n\n    }, {\n      key: 'selectTab',\n      value: function selectTab(elem, historyHandled) {\n        var idStr;\n\n        if (typeof elem === 'object') {\n          idStr = elem[0].id;\n        } else {\n          idStr = elem;\n        }\n\n        if (idStr.indexOf('#') < 0) {\n          idStr = '#' + idStr;\n        }\n\n        var $target = this.$tabTitles.find('[href=\"' + idStr + '\"]').parent('.' + this.options.linkClass);\n\n        this._handleTabChange($target, historyHandled);\n      }\n    }, {\n      key: '_setHeight',\n\n      /**\n       * Sets the height of each panel to the height of the tallest panel.\n       * If enabled in options, gets called on media query change.\n       * If loading content via external source, can be called directly or with _reflow.\n       * If enabled with `data-match-height=\"true\"`, tabs sets to equal height\n       * @function\n       * @private\n       */\n      value: function _setHeight() {\n        var max = 0,\n            _this = this; // Lock down the `this` value for the root tabs object\n\n        this.$tabContent.find('.' + this.options.panelClass).css('height', '').each(function () {\n\n          var panel = $(this),\n              isActive = panel.hasClass('' + _this.options.panelActiveClass); // get the options from the parent instead of trying to get them from the child\n\n          if (!isActive) {\n            panel.css({ 'visibility': 'hidden', 'display': 'block' });\n          }\n\n          var temp = this.getBoundingClientRect().height;\n\n          if (!isActive) {\n            panel.css({\n              'visibility': '',\n              'display': ''\n            });\n          }\n\n          max = temp > max ? temp : max;\n        }).css('height', max + 'px');\n      }\n\n      /**\n       * Destroys an instance of an tabs.\n       * @fires Tabs#destroyed\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.find('.' + this.options.linkClass).off('.zf.tabs').hide().end().find('.' + this.options.panelClass).hide();\n\n        if (this.options.matchHeight) {\n          if (this._setHeightMqHandler != null) {\n            $(window).off('changed.zf.mediaquery', this._setHeightMqHandler);\n          }\n        }\n\n        if (this.options.deepLink) {\n          $(window).off('popstate', this._checkDeepLink);\n        }\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Tabs;\n  }();\n\n  Tabs.defaults = {\n    /**\n     * Allows the window to scroll to content of pane specified by hash anchor\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    deepLink: false,\n\n    /**\n     * Adjust the deep link scroll to make sure the top of the tab panel is visible\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    deepLinkSmudge: false,\n\n    /**\n     * Animation time (ms) for the deep link adjustment\n     * @option\n     * @type {number}\n     * @default 300\n     */\n    deepLinkSmudgeDelay: 300,\n\n    /**\n     * Update the browser history with the open tab\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    updateHistory: false,\n\n    /**\n     * Allows the window to scroll to content of active pane on load if set to true.\n     * Not recommended if more than one tab panel per page.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    autoFocus: false,\n\n    /**\n     * Allows keyboard input to 'wrap' around the tab links.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    wrapOnKeys: true,\n\n    /**\n     * Allows the tab content panes to match heights if set to true.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    matchHeight: false,\n\n    /**\n     * Allows active tabs to collapse when clicked.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    activeCollapse: false,\n\n    /**\n     * Class applied to `li`'s in tab link list.\n     * @option\n     * @type {string}\n     * @default 'tabs-title'\n     */\n    linkClass: 'tabs-title',\n\n    /**\n     * Class applied to the active `li` in tab link list.\n     * @option\n     * @type {string}\n     * @default 'is-active'\n     */\n    linkActiveClass: 'is-active',\n\n    /**\n     * Class applied to the content containers.\n     * @option\n     * @type {string}\n     * @default 'tabs-panel'\n     */\n    panelClass: 'tabs-panel',\n\n    /**\n     * Class applied to the active content container.\n     * @option\n     * @type {string}\n     * @default 'is-active'\n     */\n    panelActiveClass: 'is-active'\n  };\n\n  // Window exports\n  Foundation.plugin(Tabs, 'Tabs');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udGFicy5qcz80Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIFRhYnMgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udGFic1xuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlciBpZiB0YWJzIGNvbnRhaW4gaW1hZ2VzXG4gICAqL1xuXG4gIHZhciBUYWJzID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGFicy5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgVGFicyNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byB0YWJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUYWJzKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUYWJzKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVGFicy5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9pbml0KCk7XG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdUYWJzJyk7XG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdUYWJzJywge1xuICAgICAgICAnRU5URVInOiAnb3BlbicsXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxuICAgICAgICAnQVJST1dfVVAnOiAncHJldmlvdXMnLFxuICAgICAgICAnQVJST1dfRE9XTic6ICduZXh0JyxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXG4gICAgICAgIC8vICdUQUInOiAnbmV4dCcsXG4gICAgICAgIC8vICdTSElGVF9UQUInOiAncHJldmlvdXMnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFicyBieSBzaG93aW5nIGFuZCBmb2N1c2luZyAoaWYgYXV0b0ZvY3VzPXRydWUpIHRoZSBwcmVzZXQgYWN0aXZlIHRhYi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoVGFicywgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoeyAncm9sZSc6ICd0YWJsaXN0JyB9KTtcbiAgICAgICAgdGhpcy4kdGFiVGl0bGVzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpO1xuICAgICAgICB0aGlzLiR0YWJDb250ZW50ID0gJCgnW2RhdGEtdGFicy1jb250ZW50PVwiJyArIHRoaXMuJGVsZW1lbnRbMF0uaWQgKyAnXCJdJyk7XG5cbiAgICAgICAgdGhpcy4kdGFiVGl0bGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXG4gICAgICAgICAgICAgICRsaW5rID0gJGVsZW0uZmluZCgnYScpLFxuICAgICAgICAgICAgICBpc0FjdGl2ZSA9ICRlbGVtLmhhc0NsYXNzKCcnICsgX3RoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpLFxuICAgICAgICAgICAgICBoYXNoID0gJGxpbmtbMF0uaGFzaC5zbGljZSgxKSxcbiAgICAgICAgICAgICAgbGlua0lkID0gJGxpbmtbMF0uaWQgPyAkbGlua1swXS5pZCA6IGhhc2ggKyAnLWxhYmVsJyxcbiAgICAgICAgICAgICAgJHRhYkNvbnRlbnQgPSAkKCcjJyArIGhhc2gpO1xuXG4gICAgICAgICAgJGVsZW0uYXR0cih7ICdyb2xlJzogJ3ByZXNlbnRhdGlvbicgfSk7XG5cbiAgICAgICAgICAkbGluay5hdHRyKHtcbiAgICAgICAgICAgICdyb2xlJzogJ3RhYicsXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGhhc2gsXG4gICAgICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzQWN0aXZlLFxuICAgICAgICAgICAgJ2lkJzogbGlua0lkXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkdGFiQ29udGVudC5hdHRyKHtcbiAgICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6ICFpc0FjdGl2ZSxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWRcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChpc0FjdGl2ZSAmJiBfdGhpcy5vcHRpb25zLmF1dG9Gb2N1cykge1xuICAgICAgICAgICAgJCh3aW5kb3cpLmxvYWQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7IHNjcm9sbFRvcDogJGVsZW0ub2Zmc2V0KCkudG9wIH0sIF90aGlzLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2VEZWxheSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRsaW5rLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xuICAgICAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCdpbWcnKTtcblxuICAgICAgICAgIGlmICgkaW1hZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEhlaWdodCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY3VycmVudCBjb250ZXh0LWJvdW5kIGZ1bmN0aW9uIHRvIG9wZW4gdGFicyBvbiBwYWdlIGxvYWQgb3IgaGlzdG9yeSBwb3BzdGF0ZVxuICAgICAgICB0aGlzLl9jaGVja0RlZXBMaW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhbmNob3IgPSB3aW5kb3cubG9jYXRpb24uaGFzaDtcbiAgICAgICAgICAvL25lZWQgYSBoYXNoIGFuZCBhIHJlbGV2YW50IGFuY2hvciBpbiB0aGlzIHRhYnNldFxuICAgICAgICAgIGlmIChhbmNob3IubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgJGxpbmsgPSBfdGhpczIuJGVsZW1lbnQuZmluZCgnW2hyZWY9XCInICsgYW5jaG9yICsgJ1wiXScpO1xuICAgICAgICAgICAgaWYgKCRsaW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICBfdGhpczIuc2VsZWN0VGFiKCQoYW5jaG9yKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgLy9yb2xsIHVwIGEgbGl0dGxlIHRvIHNob3cgdGhlIHRpdGxlc1xuICAgICAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnMuZGVlcExpbmtTbXVkZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX3RoaXMyLiRlbGVtZW50Lm9mZnNldCgpO1xuICAgICAgICAgICAgICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHsgc2Nyb2xsVG9wOiBvZmZzZXQudG9wIH0sIF90aGlzMi5vcHRpb25zLmRlZXBMaW5rU211ZGdlRGVsYXkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB6cGx1Z2luIGhhcyBkZWVwbGlua2VkIGF0IHBhZ2Vsb2FkXG4gICAgICAgICAgICAgICAgKiBAZXZlbnQgVGFicyNkZWVwbGlua1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIF90aGlzMi4kZWxlbWVudC50cmlnZ2VyKCdkZWVwbGluay56Zi50YWJzJywgWyRsaW5rLCAkKGFuY2hvcildKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy91c2UgYnJvd3NlciB0byBvcGVuIGEgdGFiLCBpZiBpdCBleGlzdHMgaW4gdGhpcyB0YWJzZXRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAgIHRoaXMuX2NoZWNrRGVlcExpbmsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHRoaXMuX2FkZEtleUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xuICAgICAgICAgIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAgICQod2luZG93KS5vbigncG9wc3RhdGUnLCB0aGlzLl9jaGVja0RlZXBMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgY2xpY2sgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19hZGRDbGlja0hhbmRsZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRDbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2NsaWNrLnpmLnRhYnMnKS5vbignY2xpY2suemYudGFicycsICcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkKHRoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQWRkcyBrZXlib2FyZCBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2FkZEtleUhhbmRsZXInLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRLZXlIYW5kbGVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMuJHRhYlRpdGxlcy5vZmYoJ2tleWRvd24uemYudGFicycpLm9uKCdrZXlkb3duLnpmLnRhYnMnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmIChlLndoaWNoID09PSA5KSByZXR1cm47XG5cbiAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAkZWxlbWVudHMgPSAkZWxlbWVudC5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJyksXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50O1xuXG4gICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy53cmFwT25LZXlzKSB7XG4gICAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gaSA9PT0gMCA/ICRlbGVtZW50cy5sYXN0KCkgOiAkZWxlbWVudHMuZXEoaSAtIDEpO1xuICAgICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9IGkgPT09ICRlbGVtZW50cy5sZW5ndGggLSAxID8gJGVsZW1lbnRzLmZpcnN0KCkgOiAkZWxlbWVudHMuZXEoaSArIDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpO1xuICAgICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1pbihpICsgMSwgJGVsZW1lbnRzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBoYW5kbGUga2V5Ym9hcmQgZXZlbnQgd2l0aCBrZXlib2FyZCB1dGlsXG4gICAgICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwgJ1RhYnMnLCB7XG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICRlbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkZWxlbWVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkbmV4dEVsZW1lbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuIENvbGxhcHNlcyBhY3RpdmUgdGFiLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlzdG9yeUhhbmRsZWQgLSBicm93c2VyIGhhcyBhbHJlYWR5IGhhbmRsZWQgYSBoaXN0b3J5IHVwZGF0ZVxuICAgICAgICogQGZpcmVzIFRhYnMjY2hhbmdlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZVRhYkNoYW5nZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRhYkNoYW5nZSgkdGFyZ2V0LCBoaXN0b3J5SGFuZGxlZCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBmb3IgYWN0aXZlIGNsYXNzIG9uIHRhcmdldC4gQ29sbGFwc2UgaWYgZXhpc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJycgKyB0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWN0aXZlQ29sbGFwc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlVGFiKCR0YXJnZXQpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHpwbHVnaW4gaGFzIHN1Y2Nlc3NmdWxseSBjb2xsYXBzZWQgdGFicy5cbiAgICAgICAgICAgICAqIEBldmVudCBUYWJzI2NvbGxhcHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY29sbGFwc2UuemYudGFicycsIFskdGFyZ2V0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkb2xkVGFiID0gdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MgKyAnLicgKyB0aGlzLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzKSxcbiAgICAgICAgICAgICR0YWJMaW5rID0gJHRhcmdldC5maW5kKCdbcm9sZT1cInRhYlwiXScpLFxuICAgICAgICAgICAgaGFzaCA9ICR0YWJMaW5rWzBdLmhhc2gsXG4gICAgICAgICAgICAkdGFyZ2V0Q29udGVudCA9IHRoaXMuJHRhYkNvbnRlbnQuZmluZChoYXNoKTtcblxuICAgICAgICAvL2Nsb3NlIG9sZCB0YWJcbiAgICAgICAgdGhpcy5fY29sbGFwc2VUYWIoJG9sZFRhYik7XG5cbiAgICAgICAgLy9vcGVuIG5ldyB0YWJcbiAgICAgICAgdGhpcy5fb3BlblRhYigkdGFyZ2V0KTtcblxuICAgICAgICAvL2VpdGhlciByZXBsYWNlIG9yIHVwZGF0ZSBicm93c2VyIGhpc3RvcnlcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluayAmJiAhaGlzdG9yeUhhbmRsZWQpIHtcbiAgICAgICAgICB2YXIgYW5jaG9yID0gJHRhcmdldC5maW5kKCdhJykuYXR0cignaHJlZicpO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cGRhdGVIaXN0b3J5KSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsIGFuY2hvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCAnJywgYW5jaG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBzdWNjZXNzZnVsbHkgY2hhbmdlZCB0YWJzLlxuICAgICAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlLnpmLnRhYnMnLCBbJHRhcmdldCwgJHRhcmdldENvbnRlbnRdKTtcblxuICAgICAgICAvL2ZpcmUgdG8gY2hpbGRyZW4gYSBtdXRhdGlvbiBldmVudFxuICAgICAgICAkdGFyZ2V0Q29udGVudC5maW5kKFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VyKFwibXV0YXRlbWUuemYudHJpZ2dlclwiKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFRhYiB0byBPcGVuLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vcGVuVGFiJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblRhYigkdGFyZ2V0KSB7XG4gICAgICAgIHZhciAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKSxcbiAgICAgICAgICAgIGhhc2ggPSAkdGFiTGlua1swXS5oYXNoLFxuICAgICAgICAgICAgJHRhcmdldENvbnRlbnQgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoaGFzaCk7XG5cbiAgICAgICAgJHRhcmdldC5hZGRDbGFzcygnJyArIHRoaXMub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgICR0YWJMaW5rLmF0dHIoeyAnYXJpYS1zZWxlY3RlZCc6ICd0cnVlJyB9KTtcblxuICAgICAgICAkdGFyZ2V0Q29udGVudC5hZGRDbGFzcygnJyArIHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogJ2ZhbHNlJyB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDb2xsYXBzZXMgYCR0YXJnZXRDb250ZW50YCBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gVGFiIHRvIE9wZW4uXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NvbGxhcHNlVGFiJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29sbGFwc2VUYWIoJHRhcmdldCkge1xuICAgICAgICB2YXIgJHRhcmdldF9hbmNob3IgPSAkdGFyZ2V0LnJlbW92ZUNsYXNzKCcnICsgdGhpcy5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcykuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKS5hdHRyKHsgJ2FyaWEtc2VsZWN0ZWQnOiAnZmFsc2UnIH0pO1xuXG4gICAgICAgICQoJyMnICsgJHRhcmdldF9hbmNob3IuYXR0cignYXJpYS1jb250cm9scycpKS5yZW1vdmVDbGFzcygnJyArIHRoaXMub3B0aW9ucy5wYW5lbEFjdGl2ZUNsYXNzKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogJ3RydWUnIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFB1YmxpYyBtZXRob2QgZm9yIHNlbGVjdGluZyBhIGNvbnRlbnQgcGFuZSB0byBkaXNwbGF5LlxuICAgICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGlzdG9yeUhhbmRsZWQgLSBicm93c2VyIGhhcyBhbHJlYWR5IGhhbmRsZWQgYSBoaXN0b3J5IHVwZGF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3NlbGVjdFRhYicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0VGFiKGVsZW0sIGhpc3RvcnlIYW5kbGVkKSB7XG4gICAgICAgIHZhciBpZFN0cjtcblxuICAgICAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgaWRTdHIgPSBlbGVtWzBdLmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlkU3RyID0gZWxlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XG4gICAgICAgICAgaWRTdHIgPSAnIycgKyBpZFN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciAkdGFyZ2V0ID0gdGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmPVwiJyArIGlkU3RyICsgJ1wiXScpLnBhcmVudCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzKTtcblxuICAgICAgICB0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCwgaGlzdG9yeUhhbmRsZWQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19zZXRIZWlnaHQnLFxuXG4gICAgICAvKipcbiAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIHBhbmVsIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhbGxlc3QgcGFuZWwuXG4gICAgICAgKiBJZiBlbmFibGVkIGluIG9wdGlvbnMsIGdldHMgY2FsbGVkIG9uIG1lZGlhIHF1ZXJ5IGNoYW5nZS5cbiAgICAgICAqIElmIGxvYWRpbmcgY29udGVudCB2aWEgZXh0ZXJuYWwgc291cmNlLCBjYW4gYmUgY2FsbGVkIGRpcmVjdGx5IG9yIHdpdGggX3JlZmxvdy5cbiAgICAgICAqIElmIGVuYWJsZWQgd2l0aCBgZGF0YS1tYXRjaC1oZWlnaHQ9XCJ0cnVlXCJgLCB0YWJzIHNldHMgdG8gZXF1YWwgaGVpZ2h0XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0SGVpZ2h0KCkge1xuICAgICAgICB2YXIgbWF4ID0gMCxcbiAgICAgICAgICAgIF90aGlzID0gdGhpczsgLy8gTG9jayBkb3duIHRoZSBgdGhpc2AgdmFsdWUgZm9yIHRoZSByb290IHRhYnMgb2JqZWN0XG5cbiAgICAgICAgdGhpcy4kdGFiQ29udGVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5jc3MoJ2hlaWdodCcsICcnKS5lYWNoKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgIHZhciBwYW5lbCA9ICQodGhpcyksXG4gICAgICAgICAgICAgIGlzQWN0aXZlID0gcGFuZWwuaGFzQ2xhc3MoJycgKyBfdGhpcy5vcHRpb25zLnBhbmVsQWN0aXZlQ2xhc3MpOyAvLyBnZXQgdGhlIG9wdGlvbnMgZnJvbSB0aGUgcGFyZW50IGluc3RlYWQgb2YgdHJ5aW5nIHRvIGdldCB0aGVtIGZyb20gdGhlIGNoaWxkXG5cbiAgICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgICAgICBwYW5lbC5jc3MoeyAndmlzaWJpbGl0eSc6ICdoaWRkZW4nLCAnZGlzcGxheSc6ICdibG9jaycgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcblxuICAgICAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIHBhbmVsLmNzcyh7XG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXG4gICAgICAgICAgICAgICdkaXNwbGF5JzogJydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1heCA9IHRlbXAgPiBtYXggPyB0ZW1wIDogbWF4O1xuICAgICAgICB9KS5jc3MoJ2hlaWdodCcsIG1heCArICdweCcpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIHRhYnMuXG4gICAgICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpLm9mZignLnpmLnRhYnMnKS5oaWRlKCkuZW5kKCkuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuaGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpIHtcbiAgICAgICAgICBpZiAodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWVwTGluaykge1xuICAgICAgICAgICQod2luZG93KS5vZmYoJ3BvcHN0YXRlJywgdGhpcy5fY2hlY2tEZWVwTGluayk7XG4gICAgICAgIH1cblxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRhYnM7XG4gIH0oKTtcblxuICBUYWJzLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgd2luZG93IHRvIHNjcm9sbCB0byBjb250ZW50IG9mIHBhbmUgc3BlY2lmaWVkIGJ5IGhhc2ggYW5jaG9yXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZGVlcExpbms6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBkZWVwIGxpbmsgc2Nyb2xsIHRvIG1ha2Ugc3VyZSB0aGUgdG9wIG9mIHRoZSB0YWIgcGFuZWwgaXMgdmlzaWJsZVxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRlZXBMaW5rU211ZGdlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiB0aW1lIChtcykgZm9yIHRoZSBkZWVwIGxpbmsgYWRqdXN0bWVudFxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDMwMFxuICAgICAqL1xuICAgIGRlZXBMaW5rU211ZGdlRGVsYXk6IDMwMCxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYnJvd3NlciBoaXN0b3J5IHdpdGggdGhlIG9wZW4gdGFiXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHdpbmRvdyB0byBzY3JvbGwgdG8gY29udGVudCBvZiBhY3RpdmUgcGFuZSBvbiBsb2FkIGlmIHNldCB0byB0cnVlLlxuICAgICAqIE5vdCByZWNvbW1lbmRlZCBpZiBtb3JlIHRoYW4gb25lIHRhYiBwYW5lbCBwZXIgcGFnZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhdXRvRm9jdXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGtleWJvYXJkIGlucHV0IHRvICd3cmFwJyBhcm91bmQgdGhlIHRhYiBsaW5rcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHdyYXBPbktleXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHRhYiBjb250ZW50IHBhbmVzIHRvIG1hdGNoIGhlaWdodHMgaWYgc2V0IHRvIHRydWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIGFjdGl2ZSB0YWJzIHRvIGNvbGxhcHNlIHdoZW4gY2xpY2tlZC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhY3RpdmVDb2xsYXBzZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIGBsaWAncyBpbiB0YWIgbGluayBsaXN0LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICd0YWJzLXRpdGxlJ1xuICAgICAqL1xuICAgIGxpbmtDbGFzczogJ3RhYnMtdGl0bGUnLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGBsaWAgaW4gdGFiIGxpbmsgbGlzdC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnaXMtYWN0aXZlJ1xuICAgICAqL1xuICAgIGxpbmtBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250ZW50IGNvbnRhaW5lcnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3RhYnMtcGFuZWwnXG4gICAgICovXG4gICAgcGFuZWxDbGFzczogJ3RhYnMtcGFuZWwnLFxuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYWN0aXZlIGNvbnRlbnQgY29udGFpbmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdpcy1hY3RpdmUnXG4gICAgICovXG4gICAgcGFuZWxBY3RpdmVDbGFzczogJ2lzLWFjdGl2ZSdcbiAgfTtcblxuICAvLyBXaW5kb3cgZXhwb3J0c1xuICBGb3VuZGF0aW9uLnBsdWdpbihUYWJzLCAnVGFicycpO1xufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnRhYnMuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 18 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Toggler module.\n   * @module foundation.toggler\n   * @requires foundation.util.motion\n   * @requires foundation.util.triggers\n   */\n\n  var Toggler = function () {\n    /**\n     * Creates a new instance of Toggler.\n     * @class\n     * @fires Toggler#init\n     * @param {Object} element - jQuery object to add the trigger to.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function Toggler(element, options) {\n      _classCallCheck(this, Toggler);\n\n      this.$element = element;\n      this.options = $.extend({}, Toggler.defaults, element.data(), options);\n      this.className = '';\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'Toggler');\n    }\n\n    /**\n     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.\n     * @function\n     * @private\n     */\n\n\n    _createClass(Toggler, [{\n      key: '_init',\n      value: function _init() {\n        var input;\n        // Parse animation classes if they were set\n        if (this.options.animate) {\n          input = this.options.animate.split(' ');\n\n          this.animationIn = input[0];\n          this.animationOut = input[1] || null;\n        }\n        // Otherwise, parse toggle class\n        else {\n            input = this.$element.data('toggler');\n            // Allow for a . at the beginning of the string\n            this.className = input[0] === '.' ? input.slice(1) : input;\n          }\n\n        // Add ARIA attributes to triggers\n        var id = this.$element[0].id;\n        $('[data-open=\"' + id + '\"], [data-close=\"' + id + '\"], [data-toggle=\"' + id + '\"]').attr('aria-controls', id);\n        // If the target is hidden, add aria-hidden\n        this.$element.attr('aria-expanded', this.$element.is(':hidden') ? false : true);\n      }\n\n      /**\n       * Initializes events for the toggle trigger.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));\n      }\n\n      /**\n       * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was \"on\" or \"off\".\n       * @function\n       * @fires Toggler#on\n       * @fires Toggler#off\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle() {\n        this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();\n      }\n    }, {\n      key: '_toggleClass',\n      value: function _toggleClass() {\n        this.$element.toggleClass(this.className);\n\n        var isOn = this.$element.hasClass(this.className);\n        if (isOn) {\n          /**\n           * Fires if the target element has the class after a toggle.\n           * @event Toggler#on\n           */\n          this.$element.trigger('on.zf.toggler');\n        } else {\n          /**\n           * Fires if the target element does not have the class after a toggle.\n           * @event Toggler#off\n           */\n          this.$element.trigger('off.zf.toggler');\n        }\n\n        this._updateARIA(isOn);\n        this.$element.find('[data-mutate]').trigger('mutateme.zf.trigger');\n      }\n    }, {\n      key: '_toggleAnimate',\n      value: function _toggleAnimate() {\n        var _this = this;\n\n        if (this.$element.is(':hidden')) {\n          Foundation.Motion.animateIn(this.$element, this.animationIn, function () {\n            _this._updateARIA(true);\n            this.trigger('on.zf.toggler');\n            this.find('[data-mutate]').trigger('mutateme.zf.trigger');\n          });\n        } else {\n          Foundation.Motion.animateOut(this.$element, this.animationOut, function () {\n            _this._updateARIA(false);\n            this.trigger('off.zf.toggler');\n            this.find('[data-mutate]').trigger('mutateme.zf.trigger');\n          });\n        }\n      }\n    }, {\n      key: '_updateARIA',\n      value: function _updateARIA(isOn) {\n        this.$element.attr('aria-expanded', isOn ? true : false);\n      }\n\n      /**\n       * Destroys the instance of Toggler on the element.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.off('.zf.toggler');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Toggler;\n  }();\n\n  Toggler.defaults = {\n    /**\n     * Tells the plugin if the element should animated when toggled.\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    animate: false\n  };\n\n  // Window exports\n  Foundation.plugin(Toggler, 'Toggler');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udG9nZ2xlci5qcz9mYzdkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXIgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqL1xuXG4gIHZhciBUb2dnbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVG9nZ2xlci5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9nZ2xlcihlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9nZ2xlcik7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvZ2dsZXIuZGVmYXVsdHMsIGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJyc7XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdUb2dnbGVyJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFRvZ2dsZXIgcGx1Z2luIGJ5IHBhcnNpbmcgdGhlIHRvZ2dsZSBjbGFzcyBmcm9tIGRhdGEtdG9nZ2xlciwgb3IgYW5pbWF0aW9uIGNsYXNzZXMgZnJvbSBkYXRhLWFuaW1hdGUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKFRvZ2dsZXIsIFt7XG4gICAgICBrZXk6ICdfaW5pdCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAgIHZhciBpbnB1dDtcbiAgICAgICAgLy8gUGFyc2UgYW5pbWF0aW9uIGNsYXNzZXMgaWYgdGhleSB3ZXJlIHNldFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XG5cbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbkluID0gaW5wdXRbMF07XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgcGFyc2UgdG9nZ2xlIGNsYXNzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5wdXQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RvZ2dsZXInKTtcbiAgICAgICAgICAgIC8vIEFsbG93IGZvciBhIC4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGlucHV0WzBdID09PSAnLicgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0O1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzXG4gICAgICAgIHZhciBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQ7XG4gICAgICAgICQoJ1tkYXRhLW9wZW49XCInICsgaWQgKyAnXCJdLCBbZGF0YS1jbG9zZT1cIicgKyBpZCArICdcIl0sIFtkYXRhLXRvZ2dsZT1cIicgKyBpZCArICdcIl0nKS5hdHRyKCdhcmlhLWNvbnRyb2xzJywgaWQpO1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGhpZGRlbiwgYWRkIGFyaWEtaGlkZGVuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgdG9nZ2xlIHRyaWdnZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCd0b2dnbGUuemYudHJpZ2dlcicpLm9uKCd0b2dnbGUuemYudHJpZ2dlcicsIHRoaXMudG9nZ2xlLmJpbmQodGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIHRhcmdldCBjbGFzcyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuIEFuIGV2ZW50IGlzIGZpcmVkIGZyb20gdGhlIG9yaWdpbmFsIHRyaWdnZXIgZGVwZW5kaW5nIG9uIGlmIHRoZSByZXN1bHRhbnQgc3RhdGUgd2FzIFwib25cIiBvciBcIm9mZlwiLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgVG9nZ2xlciNvblxuICAgICAgICogQGZpcmVzIFRvZ2dsZXIjb2ZmXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3RvZ2dsZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgICB0aGlzW3RoaXMub3B0aW9ucy5hbmltYXRlID8gJ190b2dnbGVBbmltYXRlJyA6ICdfdG9nZ2xlQ2xhc3MnXSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ190b2dnbGVDbGFzcycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUNsYXNzKCkge1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTtcblxuICAgICAgICB2YXIgaXNPbiA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xuICAgICAgICBpZiAoaXNPbikge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBoYXMgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXG4gICAgICAgICAgICovXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvbi56Zi50b2dnbGVyJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUFSSUEoaXNPbik7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfdG9nZ2xlQW5pbWF0ZScsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZUFuaW1hdGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaXMoJzpoaWRkZW4nKSkge1xuICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LCB0aGlzLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb24uemYudG9nZ2xlcicpO1xuICAgICAgICAgICAgdGhpcy5maW5kKCdbZGF0YS1tdXRhdGVdJykudHJpZ2dlcignbXV0YXRlbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5hbmltYXRpb25PdXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVBUklBKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcbiAgICAgICAgICAgIHRoaXMuZmluZCgnW2RhdGEtbXV0YXRlXScpLnRyaWdnZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ191cGRhdGVBUklBJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQVJJQShpc09uKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT24gPyB0cnVlIDogZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudG9nZ2xlcicpO1xuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRvZ2dsZXI7XG4gIH0oKTtcblxuICBUb2dnbGVyLmRlZmF1bHRzID0ge1xuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBwbHVnaW4gaWYgdGhlIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGVkIHdoZW4gdG9nZ2xlZC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBhbmltYXRlOiBmYWxzZVxuICB9O1xuXG4gIC8vIFdpbmRvdyBleHBvcnRzXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRvZ2dsZXIsICdUb2dnbGVyJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udG9nZ2xlci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 19 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * Tooltip module.\n   * @module foundation.tooltip\n   * @requires foundation.util.box\n   * @requires foundation.util.mediaQuery\n   * @requires foundation.util.triggers\n   */\n\n  var Tooltip = function () {\n    /**\n     * Creates a new instance of a Tooltip.\n     * @class\n     * @fires Tooltip#init\n     * @param {jQuery} element - jQuery object to attach a tooltip to.\n     * @param {Object} options - object to extend the default configuration.\n     */\n    function Tooltip(element, options) {\n      _classCallCheck(this, Tooltip);\n\n      this.$element = element;\n      this.options = $.extend({}, Tooltip.defaults, this.$element.data(), options);\n\n      this.isActive = false;\n      this.isClick = false;\n      this._init();\n\n      Foundation.registerPlugin(this, 'Tooltip');\n    }\n\n    /**\n     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.\n     * @private\n     */\n\n\n    _createClass(Tooltip, [{\n      key: '_init',\n      value: function _init() {\n        var elemId = this.$element.attr('aria-describedby') || Foundation.GetYoDigits(6, 'tooltip');\n\n        this.options.positionClass = this.options.positionClass || this._getPositionClass(this.$element);\n        this.options.tipText = this.options.tipText || this.$element.attr('title');\n        this.template = this.options.template ? $(this.options.template) : this._buildTemplate(elemId);\n\n        if (this.options.allowHtml) {\n          this.template.appendTo(document.body).html(this.options.tipText).hide();\n        } else {\n          this.template.appendTo(document.body).text(this.options.tipText).hide();\n        }\n\n        this.$element.attr({\n          'title': '',\n          'aria-describedby': elemId,\n          'data-yeti-box': elemId,\n          'data-toggle': elemId,\n          'data-resize': elemId\n        }).addClass(this.options.triggerClass);\n\n        //helper variables to track movement on collisions\n        this.usedPositions = [];\n        this.counter = 4;\n        this.classChanged = false;\n\n        this._events();\n      }\n\n      /**\n       * Grabs the current positioning class, if present, and returns the value or an empty string.\n       * @private\n       */\n\n    }, {\n      key: '_getPositionClass',\n      value: function _getPositionClass(element) {\n        if (!element) {\n          return '';\n        }\n        // var position = element.attr('class').match(/top|left|right/g);\n        var position = element[0].className.match(/\\b(top|left|right)\\b/g);\n        position = position ? position[0] : '';\n        return position;\n      }\n    }, {\n      key: '_buildTemplate',\n\n      /**\n       * builds the tooltip element, adds attributes, and returns the template.\n       * @private\n       */\n      value: function _buildTemplate(id) {\n        var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass + ' ' + this.options.templateClasses).trim();\n        var $template = $('<div></div>').addClass(templateClasses).attr({\n          'role': 'tooltip',\n          'aria-hidden': true,\n          'data-is-active': false,\n          'data-is-focus': false,\n          'id': id\n        });\n        return $template;\n      }\n\n      /**\n       * Function that gets called if a collision event is detected.\n       * @param {String} position - positioning class to try\n       * @private\n       */\n\n    }, {\n      key: '_reposition',\n      value: function _reposition(position) {\n        this.usedPositions.push(position ? position : 'bottom');\n\n        //default, try switching to opposite side\n        if (!position && this.usedPositions.indexOf('top') < 0) {\n          this.template.addClass('top');\n        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {\n          this.template.removeClass(position);\n        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {\n          this.template.removeClass(position).addClass('right');\n        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {\n          this.template.removeClass(position).addClass('left');\n        }\n\n        //if default change didn't work, try bottom or left first\n        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {\n            this.template.addClass('left');\n          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {\n            this.template.removeClass(position).addClass('left');\n          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {\n            this.template.removeClass(position);\n          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {\n            this.template.removeClass(position);\n          }\n          //if nothing cleared, set to bottom\n          else {\n              this.template.removeClass(position);\n            }\n        this.classChanged = true;\n        this.counter--;\n      }\n\n      /**\n       * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.\n       * if the tooltip is larger than the screen width, default to full width - any user selected margin\n       * @private\n       */\n\n    }, {\n      key: '_setPosition',\n      value: function _setPosition() {\n        var position = this._getPositionClass(this.template),\n            $tipDims = Foundation.Box.GetDimensions(this.template),\n            $anchorDims = Foundation.Box.GetDimensions(this.$element),\n            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',\n            param = direction === 'top' ? 'height' : 'width',\n            offset = param === 'height' ? this.options.vOffset : this.options.hOffset,\n            _this = this;\n\n        if ($tipDims.width >= $tipDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.template)) {\n          this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({\n            // this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({\n            'width': $anchorDims.windowDims.width - this.options.hOffset * 2,\n            'height': 'auto'\n          });\n          return false;\n        }\n\n        this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center ' + (position || 'bottom'), this.options.vOffset, this.options.hOffset));\n\n        while (!Foundation.Box.ImNotTouchingYou(this.template) && this.counter) {\n          this._reposition(position);\n          this._setPosition();\n        }\n      }\n\n      /**\n       * reveals the tooltip, and fires an event to close any other open tooltips on the page\n       * @fires Tooltip#closeme\n       * @fires Tooltip#show\n       * @function\n       */\n\n    }, {\n      key: 'show',\n      value: function show() {\n        if (this.options.showOn !== 'all' && !Foundation.MediaQuery.is(this.options.showOn)) {\n          // console.error('The screen is too small to display this tooltip');\n          return false;\n        }\n\n        var _this = this;\n        this.template.css('visibility', 'hidden').show();\n        this._setPosition();\n\n        /**\n         * Fires to close all other open tooltips on the page\n         * @event Closeme#tooltip\n         */\n        this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));\n\n        this.template.attr({\n          'data-is-active': true,\n          'aria-hidden': false\n        });\n        _this.isActive = true;\n        // console.log(this.template);\n        this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {\n          //maybe do stuff?\n        });\n        /**\n         * Fires when the tooltip is shown\n         * @event Tooltip#show\n         */\n        this.$element.trigger('show.zf.tooltip');\n      }\n\n      /**\n       * Hides the current tooltip, and resets the positioning class if it was changed due to collision\n       * @fires Tooltip#hide\n       * @function\n       */\n\n    }, {\n      key: 'hide',\n      value: function hide() {\n        // console.log('hiding', this.$element.data('yeti-box'));\n        var _this = this;\n        this.template.stop().attr({\n          'aria-hidden': true,\n          'data-is-active': false\n        }).fadeOut(this.options.fadeOutDuration, function () {\n          _this.isActive = false;\n          _this.isClick = false;\n          if (_this.classChanged) {\n            _this.template.removeClass(_this._getPositionClass(_this.template)).addClass(_this.options.positionClass);\n\n            _this.usedPositions = [];\n            _this.counter = 4;\n            _this.classChanged = false;\n          }\n        });\n        /**\n         * fires when the tooltip is hidden\n         * @event Tooltip#hide\n         */\n        this.$element.trigger('hide.zf.tooltip');\n      }\n\n      /**\n       * adds event listeners for the tooltip and its anchor\n       * TODO combine some of the listeners like focus and mouseenter, etc.\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n        var $template = this.template;\n        var isFocus = false;\n\n        if (!this.options.disableHover) {\n\n          this.$element.on('mouseenter.zf.tooltip', function (e) {\n            if (!_this.isActive) {\n              _this.timeout = setTimeout(function () {\n                _this.show();\n              }, _this.options.hoverDelay);\n            }\n          }).on('mouseleave.zf.tooltip', function (e) {\n            clearTimeout(_this.timeout);\n            if (!isFocus || _this.isClick && !_this.options.clickOpen) {\n              _this.hide();\n            }\n          });\n        }\n\n        if (this.options.clickOpen) {\n          this.$element.on('mousedown.zf.tooltip', function (e) {\n            e.stopImmediatePropagation();\n            if (_this.isClick) {\n              //_this.hide();\n              // _this.isClick = false;\n            } else {\n              _this.isClick = true;\n              if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {\n                _this.show();\n              }\n            }\n          });\n        } else {\n          this.$element.on('mousedown.zf.tooltip', function (e) {\n            e.stopImmediatePropagation();\n            _this.isClick = true;\n          });\n        }\n\n        if (!this.options.disableForTouch) {\n          this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {\n            _this.isActive ? _this.hide() : _this.show();\n          });\n        }\n\n        this.$element.on({\n          // 'toggle.zf.trigger': this.toggle.bind(this),\n          // 'close.zf.trigger': this.hide.bind(this)\n          'close.zf.trigger': this.hide.bind(this)\n        });\n\n        this.$element.on('focus.zf.tooltip', function (e) {\n          isFocus = true;\n          if (_this.isClick) {\n            // If we're not showing open on clicks, we need to pretend a click-launched focus isn't\n            // a real focus, otherwise on hover and come back we get bad behavior\n            if (!_this.options.clickOpen) {\n              isFocus = false;\n            }\n            return false;\n          } else {\n            _this.show();\n          }\n        }).on('focusout.zf.tooltip', function (e) {\n          isFocus = false;\n          _this.isClick = false;\n          _this.hide();\n        }).on('resizeme.zf.trigger', function () {\n          if (_this.isActive) {\n            _this._setPosition();\n          }\n        });\n      }\n\n      /**\n       * adds a toggle method, in addition to the static show() & hide() functions\n       * @function\n       */\n\n    }, {\n      key: 'toggle',\n      value: function toggle() {\n        if (this.isActive) {\n          this.hide();\n        } else {\n          this.show();\n        }\n      }\n\n      /**\n       * Destroys an instance of tooltip, removes template element from the view.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tooltip').removeClass('has-tip top right left').removeAttr('aria-describedby aria-haspopup data-disable-hover data-resize data-toggle data-tooltip data-yeti-box');\n\n        this.template.remove();\n\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return Tooltip;\n  }();\n\n  Tooltip.defaults = {\n    disableForTouch: false,\n    /**\n     * Time, in ms, before a tooltip should open on hover.\n     * @option\n     * @type {number}\n     * @default 200\n     */\n    hoverDelay: 200,\n    /**\n     * Time, in ms, a tooltip should take to fade into view.\n     * @option\n     * @type {number}\n     * @default 150\n     */\n    fadeInDuration: 150,\n    /**\n     * Time, in ms, a tooltip should take to fade out of view.\n     * @option\n     * @type {number}\n     * @default 150\n     */\n    fadeOutDuration: 150,\n    /**\n     * Disables hover events from opening the tooltip if set to true\n     * @option\n     * @type {boolean}\n     * @default false\n     */\n    disableHover: false,\n    /**\n     * Optional addtional classes to apply to the tooltip template on init.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    templateClasses: '',\n    /**\n     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.\n     * @option\n     * @type {string}\n     * @default 'tooltip'\n     */\n    tooltipClass: 'tooltip',\n    /**\n     * Class applied to the tooltip anchor element.\n     * @option\n     * @type {string}\n     * @default 'has-tip'\n     */\n    triggerClass: 'has-tip',\n    /**\n     * Minimum breakpoint size at which to open the tooltip.\n     * @option\n     * @type {string}\n     * @default 'small'\n     */\n    showOn: 'small',\n    /**\n     * Custom template to be used to generate markup for tooltip.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    template: '',\n    /**\n     * Text displayed in the tooltip template on open.\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    tipText: '',\n    touchCloseText: 'Tap to close.',\n    /**\n     * Allows the tooltip to remain open if triggered with a click or touch event.\n     * @option\n     * @type {boolean}\n     * @default true\n     */\n    clickOpen: true,\n    /**\n     * Additional positioning classes, set by the JS\n     * @option\n     * @type {string}\n     * @default ''\n     */\n    positionClass: '',\n    /**\n     * Distance, in pixels, the template should push away from the anchor on the Y axis.\n     * @option\n     * @type {number}\n     * @default 10\n     */\n    vOffset: 10,\n    /**\n     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.\n     * @option\n     * @type {number}\n     * @default 12\n     */\n    hOffset: 12,\n    /**\n    * Allow HTML in tooltip. Warning: If you are loading user-generated content into tooltips,\n    * allowing HTML may open yourself up to XSS attacks.\n    * @option\n    * @type {boolean}\n    * @default false\n    */\n    allowHtml: false\n  };\n\n  /**\n   * TODO utilize resize event trigger\n   */\n\n  // Window exports\n  Foundation.plugin(Tooltip, 'Tooltip');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udG9vbHRpcC5qcz9iNWMxIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgLyoqXG4gICAqIFRvb2x0aXAgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udG9vbHRpcFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICAgKi9cblxuICB2YXIgVG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgVG9vbHRpcC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgVG9vbHRpcCNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCBhIHRvb2x0aXAgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvYmplY3QgdG8gZXh0ZW5kIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIFRvb2x0aXAuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5pc0NsaWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbml0KCk7XG5cbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Rvb2x0aXAnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdG9vbHRpcCBieSBzZXR0aW5nIHRoZSBjcmVhdGluZyB0aGUgdGlwIGVsZW1lbnQsIGFkZGluZyBpdCdzIHRleHQsIHNldHRpbmcgcHJpdmF0ZSB2YXJpYWJsZXMgYW5kIHNldHRpbmcgYXR0cmlidXRlcyBvbiB0aGUgYW5jaG9yLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhUb29sdGlwLCBbe1xuICAgICAga2V5OiAnX2luaXQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgICB2YXIgZWxlbUlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWRlc2NyaWJlZGJ5JykgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAndG9vbHRpcCcpO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgfHwgdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KTtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpcFRleHQgPSB0aGlzLm9wdGlvbnMudGlwVGV4dCB8fCB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJyk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUgPyAkKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSkgOiB0aGlzLl9idWlsZFRlbXBsYXRlKGVsZW1JZCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0h0bWwpIHtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLmh0bWwodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpLnRleHQodGhpcy5vcHRpb25zLnRpcFRleHQpLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cih7XG4gICAgICAgICAgJ3RpdGxlJzogJycsXG4gICAgICAgICAgJ2FyaWEtZGVzY3JpYmVkYnknOiBlbGVtSWQsXG4gICAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiBlbGVtSWQsXG4gICAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxuICAgICAgICAgICdkYXRhLXJlc2l6ZSc6IGVsZW1JZFxuICAgICAgICB9KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudHJpZ2dlckNsYXNzKTtcblxuICAgICAgICAvL2hlbHBlciB2YXJpYWJsZXMgdG8gdHJhY2sgbW92ZW1lbnQgb24gY29sbGlzaW9uc1xuICAgICAgICB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gNDtcbiAgICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBHcmFicyB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBjbGFzcywgaWYgcHJlc2VudCwgYW5kIHJldHVybnMgdGhlIHZhbHVlIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19nZXRQb3NpdGlvbkNsYXNzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UG9zaXRpb25DbGFzcyhlbGVtZW50KSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyB2YXIgcG9zaXRpb24gPSBlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3RvcHxsZWZ0fHJpZ2h0L2cpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcYi9nKTtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJyc7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfYnVpbGRUZW1wbGF0ZScsXG5cbiAgICAgIC8qKlxuICAgICAgICogYnVpbGRzIHRoZSB0b29sdGlwIGVsZW1lbnQsIGFkZHMgYXR0cmlidXRlcywgYW5kIHJldHVybnMgdGhlIHRlbXBsYXRlLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZFRlbXBsYXRlKGlkKSB7XG4gICAgICAgIHZhciB0ZW1wbGF0ZUNsYXNzZXMgPSAodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyArICcgJyArIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzICsgJyAnICsgdGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpO1xuICAgICAgICB2YXIgJHRlbXBsYXRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoe1xuICAgICAgICAgICdyb2xlJzogJ3Rvb2x0aXAnLFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2UsXG4gICAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcbiAgICAgICAgICAnaWQnOiBpZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICR0ZW1wbGF0ZTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBGdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gcG9zaXRpb25pbmcgY2xhc3MgdG8gdHJ5XG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfcmVwb3NpdGlvbicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24gPyBwb3NpdGlvbiA6ICdib3R0b20nKTtcblxuICAgICAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxuICAgICAgICBpZiAoIXBvc2l0aW9uICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlLmFkZENsYXNzKCd0b3AnKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkge1xuICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPCAwKSB7XG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbikuYWRkQ2xhc3MoJ3JpZ2h0Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApIHtcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiBkZWZhdWx0IGNoYW5nZSBkaWRuJ3Qgd29yaywgdHJ5IGJvdHRvbSBvciBsZWZ0IGZpcnN0XG4gICAgICAgIGVsc2UgaWYgKCFwb3NpdGlvbiAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJykgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkge1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcygnbGVmdCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvdW50ZXItLTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBzZXRzIHRoZSBwb3NpdGlvbiBjbGFzcyBvZiBhbiBlbGVtZW50IGFuZCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUgcG9zc2libGUgcG9zaXRpb25zIHRvIGF0dGVtcHQsIG9yIHRoZSB0b29sdGlwIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGNvbGxpZGluZy5cbiAgICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX3NldFBvc2l0aW9uJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2dldFBvc2l0aW9uQ2xhc3ModGhpcy50ZW1wbGF0ZSksXG4gICAgICAgICAgICAkdGlwRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy50ZW1wbGF0ZSksXG4gICAgICAgICAgICAkYW5jaG9yRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogcG9zaXRpb24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJyxcbiAgICAgICAgICAgIHBhcmFtID0gZGlyZWN0aW9uID09PSAndG9wJyA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcbiAgICAgICAgICAgIG9mZnNldCA9IHBhcmFtID09PSAnaGVpZ2h0JyA/IHRoaXMub3B0aW9ucy52T2Zmc2V0IDogdGhpcy5vcHRpb25zLmhPZmZzZXQsXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgaWYgKCR0aXBEaW1zLndpZHRoID49ICR0aXBEaW1zLndpbmRvd0RpbXMud2lkdGggfHwgIXRoaXMuY291bnRlciAmJiAhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSkge1xuICAgICAgICAgIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuICAgICAgICAgICAgLy8gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsICdjZW50ZXIgYm90dG9tJywgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCB0cnVlKSkuY3NzKHtcbiAgICAgICAgICAgICd3aWR0aCc6ICRhbmNob3JEaW1zLndpbmRvd0RpbXMud2lkdGggLSB0aGlzLm9wdGlvbnMuaE9mZnNldCAqIDIsXG4gICAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLCB0aGlzLiRlbGVtZW50LCAnY2VudGVyICcgKyAocG9zaXRpb24gfHwgJ2JvdHRvbScpLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQpKTtcblxuICAgICAgICB3aGlsZSAoIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkgJiYgdGhpcy5jb3VudGVyKSB7XG4gICAgICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIHJldmVhbHMgdGhlIHRvb2x0aXAsIGFuZCBmaXJlcyBhbiBldmVudCB0byBjbG9zZSBhbnkgb3RoZXIgb3BlbiB0b29sdGlwcyBvbiB0aGUgcGFnZVxuICAgICAgICogQGZpcmVzIFRvb2x0aXAjY2xvc2VtZVxuICAgICAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ3Nob3cnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd09uICE9PSAnYWxsJyAmJiAhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmlzKHRoaXMub3B0aW9ucy5zaG93T24pKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignVGhlIHNjcmVlbiBpcyB0b28gc21hbGwgdG8gZGlzcGxheSB0aGlzIHRvb2x0aXAnKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRlbXBsYXRlLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5zaG93KCk7XG4gICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHRvIGNsb3NlIGFsbCBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXG4gICAgICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi50b29sdGlwJywgdGhpcy50ZW1wbGF0ZS5hdHRyKCdpZCcpKTtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xuICAgICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IHRydWUsXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy50ZW1wbGF0ZSk7XG4gICAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vbWF5YmUgZG8gc3R1ZmY/XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxuICAgICAgICAgKiBAZXZlbnQgVG9vbHRpcCNzaG93XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYudG9vbHRpcCcpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEhpZGVzIHRoZSBjdXJyZW50IHRvb2x0aXAsIGFuZCByZXNldHMgdGhlIHBvc2l0aW9uaW5nIGNsYXNzIGlmIGl0IHdhcyBjaGFuZ2VkIGR1ZSB0byBjb2xsaXNpb25cbiAgICAgICAqIEBmaXJlcyBUb29sdGlwI2hpZGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdoaWRlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGlkaW5nJywgdGhpcy4kZWxlbWVudC5kYXRhKCd5ZXRpLWJveCcpKTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiBmYWxzZVxuICAgICAgICB9KS5mYWRlT3V0KHRoaXMub3B0aW9ucy5mYWRlT3V0RHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoX3RoaXMuY2xhc3NDaGFuZ2VkKSB7XG4gICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhfdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyhfdGhpcy50ZW1wbGF0ZSkpLmFkZENsYXNzKF90aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyk7XG5cbiAgICAgICAgICAgIF90aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmNvdW50ZXIgPSA0O1xuICAgICAgICAgICAgX3RoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuXG4gICAgICAgICAqIEBldmVudCBUb29sdGlwI2hpZGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogYWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpdHMgYW5jaG9yXG4gICAgICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ19ldmVudHMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgICAgICB2YXIgaXNGb2N1cyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xuXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICghaXNGb2N1cyB8fCBfdGhpcy5pc0NsaWNrICYmICFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykge1xuICAgICAgICAgICAgICAvL190aGlzLmhpZGUoKTtcbiAgICAgICAgICAgICAgLy8gX3RoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XG4gICAgICAgICAgICAgIGlmICgoX3RoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIgfHwgIV90aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykpICYmICFfdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVGb3JUb3VjaCkge1xuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPyBfdGhpcy5oaWRlKCkgOiBfdGhpcy5zaG93KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcbiAgICAgICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxuICAgICAgICAgIC8vICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcbiAgICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2ZvY3VzLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgIGlmIChfdGhpcy5pc0NsaWNrKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3Qgc2hvd2luZyBvcGVuIG9uIGNsaWNrcywgd2UgbmVlZCB0byBwcmV0ZW5kIGEgY2xpY2stbGF1bmNoZWQgZm9jdXMgaXNuJ3RcbiAgICAgICAgICAgIC8vIGEgcmVhbCBmb2N1cywgb3RoZXJ3aXNlIG9uIGhvdmVyIGFuZCBjb21lIGJhY2sgd2UgZ2V0IGJhZCBiZWhhdmlvclxuICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbikge1xuICAgICAgICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdmb2N1c291dC56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xuICAgICAgICAgIF90aGlzLmhpZGUoKTtcbiAgICAgICAgfSkub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIGFkZHMgYSB0b2dnbGUgbWV0aG9kLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhdGljIHNob3coKSAmIGhpZGUoKSBmdW5jdGlvbnNcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICd0b2dnbGUnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIHRvb2x0aXAsIHJlbW92ZXMgdGVtcGxhdGUgZWxlbWVudCBmcm9tIHRoZSB2aWV3LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKCcuemYudHJpZ2dlciAuemYudG9vbHRpcCcpLnJlbW92ZUNsYXNzKCdoYXMtdGlwIHRvcCByaWdodCBsZWZ0JykucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieSBhcmlhLWhhc3BvcHVwIGRhdGEtZGlzYWJsZS1ob3ZlciBkYXRhLXJlc2l6ZSBkYXRhLXRvZ2dsZSBkYXRhLXRvb2x0aXAgZGF0YS15ZXRpLWJveCcpO1xuXG4gICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlKCk7XG5cbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUb29sdGlwO1xuICB9KCk7XG5cbiAgVG9vbHRpcC5kZWZhdWx0cyA9IHtcbiAgICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFRpbWUsIGluIG1zLCBiZWZvcmUgYSB0b29sdGlwIHNob3VsZCBvcGVuIG9uIGhvdmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDIwMFxuICAgICAqL1xuICAgIGhvdmVyRGVsYXk6IDIwMCxcbiAgICAvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDE1MFxuICAgICAqL1xuICAgIGZhZGVJbkR1cmF0aW9uOiAxNTAsXG4gICAgLyoqXG4gICAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDE1MFxuICAgICAqL1xuICAgIGZhZGVPdXREdXJhdGlvbjogMTUwLFxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgdGhlIHRvb2x0aXAgaWYgc2V0IHRvIHRydWVcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIGFkZHRpb25hbCBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSB0b29sdGlwIHRlbXBsYXRlIG9uIGluaXQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJydcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZUNsYXNzZXM6ICcnLFxuICAgIC8qKlxuICAgICAqIE5vbi1vcHRpb25hbCBjbGFzcyBhZGRlZCB0byB0b29sdGlwIHRlbXBsYXRlcy4gRm91bmRhdGlvbiBkZWZhdWx0IGlzICd0b29sdGlwJy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAndG9vbHRpcCdcbiAgICAgKi9cbiAgICB0b29sdGlwQ2xhc3M6ICd0b29sdGlwJyxcbiAgICAvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSB0b29sdGlwIGFuY2hvciBlbGVtZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdoYXMtdGlwJ1xuICAgICAqL1xuICAgIHRyaWdnZXJDbGFzczogJ2hhcy10aXAnLFxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gYnJlYWtwb2ludCBzaXplIGF0IHdoaWNoIHRvIG9wZW4gdGhlIHRvb2x0aXAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3NtYWxsJ1xuICAgICAqL1xuICAgIHNob3dPbjogJ3NtYWxsJyxcbiAgICAvKipcbiAgICAgKiBDdXN0b20gdGVtcGxhdGUgdG8gYmUgdXNlZCB0byBnZW5lcmF0ZSBtYXJrdXAgZm9yIHRvb2x0aXAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJydcbiAgICAgKi9cbiAgICB0ZW1wbGF0ZTogJycsXG4gICAgLyoqXG4gICAgICogVGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnJ1xuICAgICAqL1xuICAgIHRpcFRleHQ6ICcnLFxuICAgIHRvdWNoQ2xvc2VUZXh0OiAnVGFwIHRvIGNsb3NlLicsXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB0b29sdGlwIHRvIHJlbWFpbiBvcGVuIGlmIHRyaWdnZXJlZCB3aXRoIGEgY2xpY2sgb3IgdG91Y2ggZXZlbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBjbGlja09wZW46IHRydWUsXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBwb3NpdGlvbmluZyBjbGFzc2VzLCBzZXQgYnkgdGhlIEpTXG4gICAgICogQG9wdGlvblxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJydcbiAgICAgKi9cbiAgICBwb3NpdGlvbkNsYXNzOiAnJyxcbiAgICAvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFkgYXhpcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAqL1xuICAgIHZPZmZzZXQ6IDEwLFxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWCBheGlzLCBpZiBhbGlnbmVkIHRvIGEgc2lkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAxMlxuICAgICAqL1xuICAgIGhPZmZzZXQ6IDEyLFxuICAgIC8qKlxuICAgICogQWxsb3cgSFRNTCBpbiB0b29sdGlwLiBXYXJuaW5nOiBJZiB5b3UgYXJlIGxvYWRpbmcgdXNlci1nZW5lcmF0ZWQgY29udGVudCBpbnRvIHRvb2x0aXBzLFxuICAgICogYWxsb3dpbmcgSFRNTCBtYXkgb3BlbiB5b3Vyc2VsZiB1cCB0byBYU1MgYXR0YWNrcy5cbiAgICAqIEBvcHRpb25cbiAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAqL1xuICAgIGFsbG93SHRtbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogVE9ETyB1dGlsaXplIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqL1xuXG4gIC8vIFdpbmRvdyBleHBvcnRzXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRvb2x0aXAsICdUb29sdGlwJyk7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udG9vbHRpcC5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  Foundation.Box = {\n    ImNotTouchingYou: ImNotTouchingYou,\n    GetDimensions: GetDimensions,\n    GetOffsets: GetOffsets\n  };\n\n  /**\n   * Compares the dimensions of an element to a container and determines collision events with container.\n   * @function\n   * @param {jQuery} element - jQuery object to test for collisions.\n   * @param {jQuery} parent - jQuery object to use as bounding container.\n   * @param {Boolean} lrOnly - set to true to check left and right values only.\n   * @param {Boolean} tbOnly - set to true to check top and bottom values only.\n   * @default if no parent object passed, detects collisions with `window`.\n   * @returns {Boolean} - true if collision free, false if a collision in any direction.\n   */\n  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {\n    var eleDims = GetDimensions(element),\n        top,\n        bottom,\n        left,\n        right;\n\n    if (parent) {\n      var parDims = GetDimensions(parent);\n\n      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;\n      top = eleDims.offset.top >= parDims.offset.top;\n      left = eleDims.offset.left >= parDims.offset.left;\n      right = eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left;\n    } else {\n      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;\n      top = eleDims.offset.top >= eleDims.windowDims.offset.top;\n      left = eleDims.offset.left >= eleDims.windowDims.offset.left;\n      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;\n    }\n\n    var allDirs = [bottom, top, left, right];\n\n    if (lrOnly) {\n      return left === right === true;\n    }\n\n    if (tbOnly) {\n      return top === bottom === true;\n    }\n\n    return allDirs.indexOf(false) === -1;\n  };\n\n  /**\n   * Uses native methods to return an object of dimension values.\n   * @function\n   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\n   * @returns {Object} - nested object of integer pixel values\n   * TODO - if element is window, return only those values.\n   */\n  function GetDimensions(elem, test) {\n    elem = elem.length ? elem[0] : elem;\n\n    if (elem === window || elem === document) {\n      throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");\n    }\n\n    var rect = elem.getBoundingClientRect(),\n        parRect = elem.parentNode.getBoundingClientRect(),\n        winRect = document.body.getBoundingClientRect(),\n        winY = window.pageYOffset,\n        winX = window.pageXOffset;\n\n    return {\n      width: rect.width,\n      height: rect.height,\n      offset: {\n        top: rect.top + winY,\n        left: rect.left + winX\n      },\n      parentDims: {\n        width: parRect.width,\n        height: parRect.height,\n        offset: {\n          top: parRect.top + winY,\n          left: parRect.left + winX\n        }\n      },\n      windowDims: {\n        width: winRect.width,\n        height: winRect.height,\n        offset: {\n          top: winY,\n          left: winX\n        }\n      }\n    };\n  }\n\n  /**\n   * Returns an object of top and left integer pixel values for dynamically rendered elements,\n   * such as: Tooltip, Reveal, and Dropdown\n   * @function\n   * @param {jQuery} element - jQuery object for the element being positioned.\n   * @param {jQuery} anchor - jQuery object for the element's anchor point.\n   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\n   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\n   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\n   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\n   * TODO alter/rewrite to work with `em` values as well/instead of pixels\n   */\n  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\n    var $eleDims = GetDimensions(element),\n        $anchorDims = anchor ? GetDimensions(anchor) : null;\n\n    switch (position) {\n      case 'top':\n        return {\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n        };\n        break;\n      case 'left':\n        return {\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n          top: $anchorDims.offset.top\n        };\n        break;\n      case 'right':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset,\n          top: $anchorDims.offset.top\n        };\n        break;\n      case 'center top':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\n        };\n        break;\n      case 'center bottom':\n        return {\n          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      case 'center left':\n        return {\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'center right':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'center':\n        return {\n          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,\n          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2\n        };\n        break;\n      case 'reveal':\n        return {\n          left: ($eleDims.windowDims.width - $eleDims.width) / 2,\n          top: $eleDims.windowDims.offset.top + vOffset\n        };\n      case 'reveal full':\n        return {\n          left: $eleDims.windowDims.offset.left,\n          top: $eleDims.windowDims.offset.top\n        };\n        break;\n      case 'left bottom':\n        return {\n          left: $anchorDims.offset.left,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      case 'right bottom':\n        return {\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n        break;\n      default:\n        return {\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left + hOffset,\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\n        };\n    }\n  }\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5ib3guanM/NWJmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIEZvdW5kYXRpb24uQm94ID0ge1xuICAgIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXG4gICAgR2V0RGltZW5zaW9uczogR2V0RGltZW5zaW9ucyxcbiAgICBHZXRPZmZzZXRzOiBHZXRPZmZzZXRzXG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB0ZXN0IGZvciBjb2xsaXNpb25zLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGxyT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIGxlZnQgYW5kIHJpZ2h0IHZhbHVlcyBvbmx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHRiT25seSAtIHNldCB0byB0cnVlIHRvIGNoZWNrIHRvcCBhbmQgYm90dG9tIHZhbHVlcyBvbmx5LlxuICAgKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSAtIHRydWUgaWYgY29sbGlzaW9uIGZyZWUsIGZhbHNlIGlmIGEgY29sbGlzaW9uIGluIGFueSBkaXJlY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHkpIHtcbiAgICB2YXIgZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHZhciBwYXJEaW1zID0gR2V0RGltZW5zaW9ucyhwYXJlbnQpO1xuXG4gICAgICBib3R0b20gPSBlbGVEaW1zLm9mZnNldC50b3AgKyBlbGVEaW1zLmhlaWdodCA8PSBwYXJEaW1zLmhlaWdodCArIHBhckRpbXMub2Zmc2V0LnRvcDtcbiAgICAgIHRvcCA9IGVsZURpbXMub2Zmc2V0LnRvcCA+PSBwYXJEaW1zLm9mZnNldC50b3A7XG4gICAgICBsZWZ0ID0gZWxlRGltcy5vZmZzZXQubGVmdCA+PSBwYXJEaW1zLm9mZnNldC5sZWZ0O1xuICAgICAgcmlnaHQgPSBlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBwYXJEaW1zLndpZHRoICsgcGFyRGltcy5vZmZzZXQubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm90dG9tID0gZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wO1xuICAgICAgdG9wID0gZWxlRGltcy5vZmZzZXQudG9wID49IGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wO1xuICAgICAgbGVmdCA9IGVsZURpbXMub2Zmc2V0LmxlZnQgPj0gZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC5sZWZ0O1xuICAgICAgcmlnaHQgPSBlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBlbGVEaW1zLndpbmRvd0RpbXMud2lkdGg7XG4gICAgfVxuXG4gICAgdmFyIGFsbERpcnMgPSBbYm90dG9tLCB0b3AsIGxlZnQsIHJpZ2h0XTtcblxuICAgIGlmIChsck9ubHkpIHtcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGJPbmx5KSB7XG4gICAgICByZXR1cm4gdG9wID09PSBib3R0b20gPT09IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsbERpcnMuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gICAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gR2V0RGltZW5zaW9ucyhlbGVtLCB0ZXN0KSB7XG4gICAgZWxlbSA9IGVsZW0ubGVuZ3RoID8gZWxlbVswXSA6IGVsZW07XG5cbiAgICBpZiAoZWxlbSA9PT0gd2luZG93IHx8IGVsZW0gPT09IGRvY3VtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlwiKTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBhclJlY3QgPSBlbGVtLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB3aW5ZID0gd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3aW5YID0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIG9mZnNldDoge1xuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luWSxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxuICAgICAgfSxcbiAgICAgIHBhcmVudERpbXM6IHtcbiAgICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyUmVjdC5oZWlnaHQsXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxuICAgICAgICAgIGxlZnQ6IHBhclJlY3QubGVmdCArIHdpblhcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdpbmRvd0RpbXM6IHtcbiAgICAgICAgd2lkdGg6IHdpblJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIHRvcDogd2luWSxcbiAgICAgICAgICBsZWZ0OiB3aW5YXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHRvcCBhbmQgbGVmdCBpbnRlZ2VyIHBpeGVsIHZhbHVlcyBmb3IgZHluYW1pY2FsbHkgcmVuZGVyZWQgZWxlbWVudHMsXG4gICAqIHN1Y2ggYXM6IFRvb2x0aXAsIFJldmVhbCwgYW5kIERyb3Bkb3duXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSBhbmNob3IgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCdzIGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2T2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoT2Zmc2V0IC0gaW50ZWdlciBwaXhlbCB2YWx1ZSBvZiBkZXNpcmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBiZXR3ZWVuIGFuY2hvciBhbmQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXG4gICAqIFRPRE8gYWx0ZXIvcmV3cml0ZSB0byB3b3JrIHdpdGggYGVtYCB2YWx1ZXMgYXMgd2VsbC9pbnN0ZWFkIG9mIHBpeGVsc1xuICAgKi9cbiAgZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XG4gICAgdmFyICRlbGVEaW1zID0gR2V0RGltZW5zaW9ucyhlbGVtZW50KSxcbiAgICAgICAgJGFuY2hvckRpbXMgPSBhbmNob3IgPyBHZXREaW1lbnNpb25zKGFuY2hvcikgOiBudWxsO1xuXG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCAvIDIgLSAkZWxlRGltcy53aWR0aCAvIDIsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wIC0gKCRlbGVEaW1zLmhlaWdodCArIHZPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogaXNPdmVyZmxvdyA/IGhPZmZzZXQgOiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMixcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGxlZnQnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0IC8gMiAtICRlbGVEaW1zLmhlaWdodCAvIDJcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgcmlnaHQnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0ICsgMSxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgLyAyIC0gJGVsZURpbXMuaGVpZ2h0IC8gMlxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCArICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyLFxuICAgICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgJGVsZURpbXMud2luZG93RGltcy5oZWlnaHQgLyAyIC0gJGVsZURpbXMuaGVpZ2h0IC8gMlxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JldmVhbCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogKCRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSAkZWxlRGltcy53aWR0aCkgLyAyLFxuICAgICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wICsgdk9mZnNldFxuICAgICAgICB9O1xuICAgICAgY2FzZSAncmV2ZWFsIGZ1bGwnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3BcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0ICsgdk9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCArIGhPZmZzZXQgLSAkZWxlRGltcy53aWR0aCxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgKyB2T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsZWZ0OiBGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyBoT2Zmc2V0LFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcbiAgICAgICAgfTtcbiAgICB9XG4gIH1cbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLmJveC5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 21 */
/***/ function(module, exports) {

"use strict";
eval("/*******************************************\n *                                         *\n * This util was created by Marius Olbertz *\n * Please thank Marius on GitHub /owlbertz *\n * or the web http://www.mariusolbertz.de/ *\n *                                         *\n ******************************************/\n\n'use strict';\n\n!function ($) {\n\n  var keyCodes = {\n    9: 'TAB',\n    13: 'ENTER',\n    27: 'ESCAPE',\n    32: 'SPACE',\n    37: 'ARROW_LEFT',\n    38: 'ARROW_UP',\n    39: 'ARROW_RIGHT',\n    40: 'ARROW_DOWN'\n  };\n\n  var commands = {};\n\n  var Keyboard = {\n    keys: getKeyCodes(keyCodes),\n\n    /**\n     * Parses the (keyboard) event and returns a String that represents its key\n     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n     * @param {Event} event - the event generated by the event handler\n     * @return String key - String that represents the key pressed\n     */\n    parseKey: function (event) {\n      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();\n\n      // Remove un-printable characters, e.g. for `fromCharCode` calls for CTRL only events\n      key = key.replace(/\\W+/, '');\n\n      if (event.shiftKey) key = 'SHIFT_' + key;\n      if (event.ctrlKey) key = 'CTRL_' + key;\n      if (event.altKey) key = 'ALT_' + key;\n\n      // Remove trailing underscore, in case only modifiers were used (e.g. only `CTRL_ALT`)\n      key = key.replace(/_$/, '');\n\n      return key;\n    },\n\n\n    /**\n     * Handles the given (keyboard) event\n     * @param {Event} event - the event generated by the event handler\n     * @param {String} component - Foundation component's name, e.g. Slider or Reveal\n     * @param {Objects} functions - collection of functions that are to be executed\n     */\n    handleKey: function (event, component, functions) {\n      var commandList = commands[component],\n          keyCode = this.parseKey(event),\n          cmds,\n          command,\n          fn;\n\n      if (!commandList) return console.warn('Component not defined!');\n\n      if (typeof commandList.ltr === 'undefined') {\n        // this component does not differentiate between ltr and rtl\n        cmds = commandList; // use plain list\n      } else {\n        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\n        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);\n      }\n      command = cmds[keyCode];\n\n      fn = functions[command];\n      if (fn && typeof fn === 'function') {\n        // execute function  if exists\n        var returnValue = fn.apply();\n        if (functions.handled || typeof functions.handled === 'function') {\n          // execute function when event was handled\n          functions.handled(returnValue);\n        }\n      } else {\n        if (functions.unhandled || typeof functions.unhandled === 'function') {\n          // execute function when event was not handled\n          functions.unhandled();\n        }\n      }\n    },\n\n\n    /**\n     * Finds all focusable elements within the given `$element`\n     * @param {jQuery} $element - jQuery object to search within\n     * @return {jQuery} $focusable - all focusable elements within `$element`\n     */\n    findFocusable: function ($element) {\n      if (!$element) {\n        return false;\n      }\n      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\n        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {\n          return false;\n        } //only have visible elements and those that have a tabindex greater or equal 0\n        return true;\n      });\n    },\n\n\n    /**\n     * Returns the component name name\n     * @param {Object} component - Foundation component, e.g. Slider or Reveal\n     * @return String componentName\n     */\n\n    register: function (componentName, cmds) {\n      commands[componentName] = cmds;\n    },\n\n\n    /**\n     * Traps the focus in the given element.\n     * @param  {jQuery} $element  jQuery object to trap the foucs into.\n     */\n    trapFocus: function ($element) {\n      var $focusable = Foundation.Keyboard.findFocusable($element),\n          $firstFocusable = $focusable.eq(0),\n          $lastFocusable = $focusable.eq(-1);\n\n      $element.on('keydown.zf.trapfocus', function (event) {\n        if (event.target === $lastFocusable[0] && Foundation.Keyboard.parseKey(event) === 'TAB') {\n          event.preventDefault();\n          $firstFocusable.focus();\n        } else if (event.target === $firstFocusable[0] && Foundation.Keyboard.parseKey(event) === 'SHIFT_TAB') {\n          event.preventDefault();\n          $lastFocusable.focus();\n        }\n      });\n    },\n\n    /**\n     * Releases the trapped focus from the given element.\n     * @param  {jQuery} $element  jQuery object to release the focus for.\n     */\n    releaseFocus: function ($element) {\n      $element.off('keydown.zf.trapfocus');\n    }\n  };\n\n  /*\n   * Constants for easier comparing.\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\n   */\n  function getKeyCodes(kcs) {\n    var k = {};\n    for (var kc in kcs) {\n      k[kcs[kc]] = kcs[kc];\n    }return k;\n  }\n\n  Foundation.Keyboard = Keyboard;\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5rZXlib2FyZC5qcz9jOGVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogVGhpcyB1dGlsIHdhcyBjcmVhdGVkIGJ5IE1hcml1cyBPbGJlcnR6ICpcbiAqIFBsZWFzZSB0aGFuayBNYXJpdXMgb24gR2l0SHViIC9vd2xiZXJ0eiAqXG4gKiBvciB0aGUgd2ViIGh0dHA6Ly93d3cubWFyaXVzb2xiZXJ0ei5kZS8gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgdmFyIGtleUNvZGVzID0ge1xuICAgIDk6ICdUQUInLFxuICAgIDEzOiAnRU5URVInLFxuICAgIDI3OiAnRVNDQVBFJyxcbiAgICAzMjogJ1NQQUNFJyxcbiAgICAzNzogJ0FSUk9XX0xFRlQnLFxuICAgIDM4OiAnQVJST1dfVVAnLFxuICAgIDM5OiAnQVJST1dfUklHSFQnLFxuICAgIDQwOiAnQVJST1dfRE9XTidcbiAgfTtcblxuICB2YXIgY29tbWFuZHMgPSB7fTtcblxuICB2YXIgS2V5Ym9hcmQgPSB7XG4gICAga2V5czogZ2V0S2V5Q29kZXMoa2V5Q29kZXMpLFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSAoa2V5Ym9hcmQpIGV2ZW50IGFuZCByZXR1cm5zIGEgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyBpdHMga2V5XG4gICAgICogQ2FuIGJlIHVzZWQgbGlrZSBGb3VuZGF0aW9uLnBhcnNlS2V5KGV2ZW50KSA9PT0gRm91bmRhdGlvbi5rZXlzLlNQQUNFXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAgICogQHJldHVybiBTdHJpbmcga2V5IC0gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUga2V5IHByZXNzZWRcbiAgICAgKi9cbiAgICBwYXJzZUtleTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5ID0ga2V5Q29kZXNbZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZV0gfHwgU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC53aGljaCkudG9VcHBlckNhc2UoKTtcblxuICAgICAgLy8gUmVtb3ZlIHVuLXByaW50YWJsZSBjaGFyYWN0ZXJzLCBlLmcuIGZvciBgZnJvbUNoYXJDb2RlYCBjYWxscyBmb3IgQ1RSTCBvbmx5IGV2ZW50c1xuICAgICAga2V5ID0ga2V5LnJlcGxhY2UoL1xcVysvLCAnJyk7XG5cbiAgICAgIGlmIChldmVudC5zaGlmdEtleSkga2V5ID0gJ1NISUZUXycgKyBrZXk7XG4gICAgICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gJ0NUUkxfJyArIGtleTtcbiAgICAgIGlmIChldmVudC5hbHRLZXkpIGtleSA9ICdBTFRfJyArIGtleTtcblxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHVuZGVyc2NvcmUsIGluIGNhc2Ugb25seSBtb2RpZmllcnMgd2VyZSB1c2VkIChlLmcuIG9ubHkgYENUUkxfQUxUYClcbiAgICAgIGtleSA9IGtleS5yZXBsYWNlKC9fJC8sICcnKTtcblxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBnaXZlbiAoa2V5Ym9hcmQpIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgICAqL1xuICAgIGhhbmRsZUtleTogZnVuY3Rpb24gKGV2ZW50LCBjb21wb25lbnQsIGZ1bmN0aW9ucykge1xuICAgICAgdmFyIGNvbW1hbmRMaXN0ID0gY29tbWFuZHNbY29tcG9uZW50XSxcbiAgICAgICAgICBrZXlDb2RlID0gdGhpcy5wYXJzZUtleShldmVudCksXG4gICAgICAgICAgY21kcyxcbiAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgIGZuO1xuXG4gICAgICBpZiAoIWNvbW1hbmRMaXN0KSByZXR1cm4gY29uc29sZS53YXJuKCdDb21wb25lbnQgbm90IGRlZmluZWQhJyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29tbWFuZExpc3QubHRyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyB0aGlzIGNvbXBvbmVudCBkb2VzIG5vdCBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbHRyIGFuZCBydGxcbiAgICAgICAgY21kcyA9IGNvbW1hbmRMaXN0OyAvLyB1c2UgcGxhaW4gbGlzdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIGlmIChGb3VuZGF0aW9uLnJ0bCgpKSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0Lmx0ciwgY29tbWFuZExpc3QucnRsKTtlbHNlIGNtZHMgPSAkLmV4dGVuZCh7fSwgY29tbWFuZExpc3QucnRsLCBjb21tYW5kTGlzdC5sdHIpO1xuICAgICAgfVxuICAgICAgY29tbWFuZCA9IGNtZHNba2V5Q29kZV07XG5cbiAgICAgIGZuID0gZnVuY3Rpb25zW2NvbW1hbmRdO1xuICAgICAgaWYgKGZuICYmIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0gZm4uYXBwbHkoKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9ucy5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMuaGFuZGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxuICAgICAgICAgIGZ1bmN0aW9ucy5oYW5kbGVkKHJldHVyblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZ1bmN0aW9ucy51bmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXG4gICAgICAgICAgZnVuY3Rpb25zLnVuaGFuZGxlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGdpdmVuIGAkZWxlbWVudGBcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHNlYXJjaCB3aXRoaW5cbiAgICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXG4gICAgICovXG4gICAgZmluZEZvY3VzYWJsZTogZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgICBpZiAoISRlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkZWxlbWVudC5maW5kKCdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdJykuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEkKHRoaXMpLmlzKCc6dmlzaWJsZScpIHx8ICQodGhpcykuYXR0cigndGFiaW5kZXgnKSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG5hbWUgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAgICogQHJldHVybiBTdHJpbmcgY29tcG9uZW50TmFtZVxuICAgICAqL1xuXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBjbWRzKSB7XG4gICAgICBjb21tYW5kc1tjb21wb25lbnROYW1lXSA9IGNtZHM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogVHJhcHMgdGhlIGZvY3VzIGluIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEBwYXJhbSAge2pRdWVyeX0gJGVsZW1lbnQgIGpRdWVyeSBvYmplY3QgdG8gdHJhcCB0aGUgZm91Y3MgaW50by5cbiAgICAgKi9cbiAgICB0cmFwRm9jdXM6IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICAgdmFyICRmb2N1c2FibGUgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoJGVsZW1lbnQpLFxuICAgICAgICAgICRmaXJzdEZvY3VzYWJsZSA9ICRmb2N1c2FibGUuZXEoMCksXG4gICAgICAgICAgJGxhc3RGb2N1c2FibGUgPSAkZm9jdXNhYmxlLmVxKC0xKTtcblxuICAgICAgJGVsZW1lbnQub24oJ2tleWRvd24uemYudHJhcGZvY3VzJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09ICRsYXN0Rm9jdXNhYmxlWzBdICYmIEZvdW5kYXRpb24uS2V5Ym9hcmQucGFyc2VLZXkoZXZlbnQpID09PSAnVEFCJykge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJGZpcnN0Rm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudGFyZ2V0ID09PSAkZmlyc3RGb2N1c2FibGVbMF0gJiYgRm91bmRhdGlvbi5LZXlib2FyZC5wYXJzZUtleShldmVudCkgPT09ICdTSElGVF9UQUInKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkbGFzdEZvY3VzYWJsZS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgdGhlIHRyYXBwZWQgZm9jdXMgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtqUXVlcnl9ICRlbGVtZW50ICBqUXVlcnkgb2JqZWN0IHRvIHJlbGVhc2UgdGhlIGZvY3VzIGZvci5cbiAgICAgKi9cbiAgICByZWxlYXNlRm9jdXM6IGZ1bmN0aW9uICgkZWxlbWVudCkge1xuICAgICAgJGVsZW1lbnQub2ZmKCdrZXlkb3duLnpmLnRyYXBmb2N1cycpO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBDb25zdGFudHMgZm9yIGVhc2llciBjb21wYXJpbmcuXG4gICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0S2V5Q29kZXMoa2NzKSB7XG4gICAgdmFyIGsgPSB7fTtcbiAgICBmb3IgKHZhciBrYyBpbiBrY3MpIHtcbiAgICAgIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xuICAgIH1yZXR1cm4gaztcbiAgfVxuXG4gIEZvdW5kYXRpb24uS2V5Ym9hcmQgPSBLZXlib2FyZDtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  // Default set of media queries\n  var defaultQueries = {\n    'default': 'only screen',\n    landscape: 'only screen and (orientation: landscape)',\n    portrait: 'only screen and (orientation: portrait)',\n    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\n  };\n\n  var MediaQuery = {\n    queries: [],\n\n    current: '',\n\n    /**\n     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\n     * @function\n     * @private\n     */\n    _init: function () {\n      var self = this;\n      var extractedStyles = $('.foundation-mq').css('font-family');\n      var namedQueries;\n\n      namedQueries = parseStyleToObject(extractedStyles);\n\n      for (var key in namedQueries) {\n        if (namedQueries.hasOwnProperty(key)) {\n          self.queries.push({\n            name: key,\n            value: 'only screen and (min-width: ' + namedQueries[key] + ')'\n          });\n        }\n      }\n\n      this.current = this._getCurrentSize();\n\n      this._watcher();\n    },\n\n\n    /**\n     * Checks if the screen is at least as wide as a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to check.\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\n     */\n    atLeast: function (size) {\n      var query = this.get(size);\n\n      if (query) {\n        return window.matchMedia(query).matches;\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Checks if the screen matches to a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to check, either 'small only' or 'small'. Omitting 'only' falls back to using atLeast() method.\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it does not.\n     */\n    is: function (size) {\n      size = size.trim().split(' ');\n      if (size.length > 1 && size[1] === 'only') {\n        if (size[0] === this._getCurrentSize()) return true;\n      } else {\n        return this.atLeast(size[0]);\n      }\n      return false;\n    },\n\n\n    /**\n     * Gets the media query of a breakpoint.\n     * @function\n     * @param {String} size - Name of the breakpoint to get.\n     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\n     */\n    get: function (size) {\n      for (var i in this.queries) {\n        if (this.queries.hasOwnProperty(i)) {\n          var query = this.queries[i];\n          if (size === query.name) return query.value;\n        }\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\n     * @function\n     * @private\n     * @returns {String} Name of the current breakpoint.\n     */\n    _getCurrentSize: function () {\n      var matched;\n\n      for (var i = 0; i < this.queries.length; i++) {\n        var query = this.queries[i];\n\n        if (window.matchMedia(query.value).matches) {\n          matched = query;\n        }\n      }\n\n      if (typeof matched === 'object') {\n        return matched.name;\n      } else {\n        return matched;\n      }\n    },\n\n\n    /**\n     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\n     * @function\n     * @private\n     */\n    _watcher: function () {\n      var _this = this;\n\n      $(window).on('resize.zf.mediaquery', function () {\n        var newSize = _this._getCurrentSize(),\n            currentSize = _this.current;\n\n        if (newSize !== currentSize) {\n          // Change the current media query\n          _this.current = newSize;\n\n          // Broadcast the media query change on the window\n          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\n        }\n      });\n    }\n  };\n\n  Foundation.MediaQuery = MediaQuery;\n\n  // matchMedia() polyfill - Test a CSS media type/query in JS.\n  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\n  window.matchMedia || (window.matchMedia = function () {\n    'use strict';\n\n    // For browsers that support matchMedium api such as IE 9 and webkit\n\n    var styleMedia = window.styleMedia || window.media;\n\n    // For those that don't support matchMedium\n    if (!styleMedia) {\n      var style = document.createElement('style'),\n          script = document.getElementsByTagName('script')[0],\n          info = null;\n\n      style.type = 'text/css';\n      style.id = 'matchmediajs-test';\n\n      script && script.parentNode && script.parentNode.insertBefore(style, script);\n\n      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\n      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\n\n      styleMedia = {\n        matchMedium: function (media) {\n          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\n\n          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\n          if (style.styleSheet) {\n            style.styleSheet.cssText = text;\n          } else {\n            style.textContent = text;\n          }\n\n          // Test if media query is true or false\n          return info.width === '1px';\n        }\n      };\n    }\n\n    return function (media) {\n      return {\n        matches: styleMedia.matchMedium(media || 'all'),\n        media: media || 'all'\n      };\n    };\n  }());\n\n  // Thank you: https://github.com/sindresorhus/query-string\n  function parseStyleToObject(str) {\n    var styleObject = {};\n\n    if (typeof str !== 'string') {\n      return styleObject;\n    }\n\n    str = str.trim().slice(1, -1); // browsers re-quote string style values\n\n    if (!str) {\n      return styleObject;\n    }\n\n    styleObject = str.split('&').reduce(function (ret, param) {\n      var parts = param.replace(/\\+/g, ' ').split('=');\n      var key = parts[0];\n      var val = parts[1];\n      key = decodeURIComponent(key);\n\n      // missing `=` should be `null`:\n      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n      val = val === undefined ? null : decodeURIComponent(val);\n\n      if (!ret.hasOwnProperty(key)) {\n        ret[key] = val;\n      } else if (Array.isArray(ret[key])) {\n        ret[key].push(val);\n      } else {\n        ret[key] = [ret[key], val];\n      }\n      return ret;\n    }, {});\n\n    return styleObject;\n  }\n\n  Foundation.MediaQuery = MediaQuery;\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5LmpzPzZmMzIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24gKCQpIHtcblxuICAvLyBEZWZhdWx0IHNldCBvZiBtZWRpYSBxdWVyaWVzXG4gIHZhciBkZWZhdWx0UXVlcmllcyA9IHtcbiAgICAnZGVmYXVsdCc6ICdvbmx5IHNjcmVlbicsXG4gICAgbGFuZHNjYXBlOiAnb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXG4gICAgcG9ydHJhaXQ6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxuICAgIHJldGluYTogJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ1xuICB9O1xuXG4gIHZhciBNZWRpYVF1ZXJ5ID0ge1xuICAgIHF1ZXJpZXM6IFtdLFxuXG4gICAgY3VycmVudDogJycsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgbWVkaWEgcXVlcnkgaGVscGVyLCBieSBleHRyYWN0aW5nIHRoZSBicmVha3BvaW50IGxpc3QgZnJvbSB0aGUgQ1NTIGFuZCBhY3RpdmF0aW5nIHRoZSBicmVha3BvaW50IHdhdGNoZXIuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGV4dHJhY3RlZFN0eWxlcyA9ICQoJy5mb3VuZGF0aW9uLW1xJykuY3NzKCdmb250LWZhbWlseScpO1xuICAgICAgdmFyIG5hbWVkUXVlcmllcztcblxuICAgICAgbmFtZWRRdWVyaWVzID0gcGFyc2VTdHlsZVRvT2JqZWN0KGV4dHJhY3RlZFN0eWxlcyk7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lZFF1ZXJpZXMpIHtcbiAgICAgICAgaWYgKG5hbWVkUXVlcmllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgc2VsZi5xdWVyaWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgdmFsdWU6ICdvbmx5IHNjcmVlbiBhbmQgKG1pbi13aWR0aDogJyArIG5hbWVkUXVlcmllc1trZXldICsgJyknXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcblxuICAgICAgdGhpcy5fd2F0Y2hlcigpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc2NyZWVuIGlzIGF0IGxlYXN0IGFzIHdpZGUgYXMgYSBicmVha3BvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBicmVha3BvaW50IG1hdGNoZXMsIGBmYWxzZWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAqL1xuICAgIGF0TGVhc3Q6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLmdldChzaXplKTtcblxuICAgICAgaWYgKHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYShxdWVyeSkubWF0Y2hlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgc2NyZWVuIG1hdGNoZXMgdG8gYSBicmVha3BvaW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjaywgZWl0aGVyICdzbWFsbCBvbmx5JyBvciAnc21hbGwnLiBPbWl0dGluZyAnb25seScgZmFsbHMgYmFjayB0byB1c2luZyBhdExlYXN0KCkgbWV0aG9kLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGJyZWFrcG9pbnQgbWF0Y2hlcywgYGZhbHNlYCBpZiBpdCBkb2VzIG5vdC5cbiAgICAgKi9cbiAgICBpczogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHNpemUgPSBzaXplLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgICAgaWYgKHNpemUubGVuZ3RoID4gMSAmJiBzaXplWzFdID09PSAnb25seScpIHtcbiAgICAgICAgaWYgKHNpemVbMF0gPT09IHRoaXMuX2dldEN1cnJlbnRTaXplKCkpIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdChzaXplWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtZWRpYSBxdWVyeSBvZiBhIGJyZWFrcG9pbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpemUgLSBOYW1lIG9mIHRoZSBicmVha3BvaW50IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfG51bGx9IC0gVGhlIG1lZGlhIHF1ZXJ5IG9mIHRoZSBicmVha3BvaW50LCBvciBgbnVsbGAgaWYgdGhlIGJyZWFrcG9pbnQgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHRoaXMucXVlcmllcykge1xuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xuICAgICAgICAgIGlmIChzaXplID09PSBxdWVyeS5uYW1lKSByZXR1cm4gcXVlcnkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgICAqL1xuICAgIF9nZXRDdXJyZW50U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hdGNoZWQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5xdWVyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcblxuICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEocXVlcnkudmFsdWUpLm1hdGNoZXMpIHtcbiAgICAgICAgICBtYXRjaGVkID0gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBtYXRjaGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbWF0Y2hlZC5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF93YXRjaGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3U2l6ZSA9IF90aGlzLl9nZXRDdXJyZW50U2l6ZSgpLFxuICAgICAgICAgICAgY3VycmVudFNpemUgPSBfdGhpcy5jdXJyZW50O1xuXG4gICAgICAgIGlmIChuZXdTaXplICE9PSBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxuICAgICAgICAgIF90aGlzLmN1cnJlbnQgPSBuZXdTaXplO1xuXG4gICAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xuICAgICAgICAgICQod2luZG93KS50cmlnZ2VyKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCBbbmV3U2l6ZSwgY3VycmVudFNpemVdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIEZvdW5kYXRpb24uTWVkaWFRdWVyeSA9IE1lZGlhUXVlcnk7XG5cbiAgLy8gbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLlxuICAvLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxuICB3aW5kb3cubWF0Y2hNZWRpYSB8fCAod2luZG93Lm1hdGNoTWVkaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcblxuICAgIHZhciBzdHlsZU1lZGlhID0gd2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhO1xuXG4gICAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuICAgIGlmICghc3R5bGVNZWRpYSkge1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSxcbiAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXG4gICAgICAgICAgaW5mbyA9IG51bGw7XG5cbiAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgc3R5bGUuaWQgPSAnbWF0Y2htZWRpYWpzLXRlc3QnO1xuXG4gICAgICBzY3JpcHQgJiYgc2NyaXB0LnBhcmVudE5vZGUgJiYgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuXG4gICAgICAvLyAnc3R5bGUuY3VycmVudFN0eWxlJyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICd3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZScgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgaW5mbyA9ICdnZXRDb21wdXRlZFN0eWxlJyBpbiB3aW5kb3cgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcblxuICAgICAgc3R5bGVNZWRpYSA9IHtcbiAgICAgICAgbWF0Y2hNZWRpdW06IGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gJ0BtZWRpYSAnICsgbWVkaWEgKyAneyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH0nO1xuXG4gICAgICAgICAgLy8gJ3N0eWxlLnN0eWxlU2hlZXQnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3N0eWxlLnRleHRDb250ZW50JyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUZXN0IGlmIG1lZGlhIHF1ZXJ5IGlzIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZWRpYSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWF0Y2hlczogc3R5bGVNZWRpYS5tYXRjaE1lZGl1bShtZWRpYSB8fCAnYWxsJyksXG4gICAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xuICAgICAgfTtcbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIFRoYW5rIHlvdTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmdcbiAgZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xuICAgIHZhciBzdHlsZU9iamVjdCA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfVxuXG4gICAgc3RyID0gc3RyLnRyaW0oKS5zbGljZSgxLCAtMSk7IC8vIGJyb3dzZXJzIHJlLXF1b3RlIHN0cmluZyBzdHlsZSB2YWx1ZXNcblxuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gc3R5bGVPYmplY3Q7XG4gICAgfVxuXG4gICAgc3R5bGVPYmplY3QgPSBzdHIuc3BsaXQoJyYnKS5yZWR1Y2UoZnVuY3Rpb24gKHJldCwgcGFyYW0pIHtcbiAgICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgICB2YXIga2V5ID0gcGFydHNbMF07XG4gICAgICB2YXIgdmFsID0gcGFydHNbMV07XG4gICAgICBrZXkgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5KTtcblxuICAgICAgLy8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcbiAgICAgIC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcbiAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlY29kZVVSSUNvbXBvbmVudCh2YWwpO1xuXG4gICAgICBpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldFtrZXldID0gdmFsO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xuICAgICAgICByZXRba2V5XS5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG5cbiAgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gTWVkaWFRdWVyeTtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 23 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  /**\n   * Motion module.\n   * @module foundation.motion\n   */\n\n  var initClasses = ['mui-enter', 'mui-leave'];\n  var activeClasses = ['mui-enter-active', 'mui-leave-active'];\n\n  var Motion = {\n    animateIn: function (element, animation, cb) {\n      animate(true, element, animation, cb);\n    },\n\n    animateOut: function (element, animation, cb) {\n      animate(false, element, animation, cb);\n    }\n  };\n\n  function Move(duration, elem, fn) {\n    var anim,\n        prog,\n        start = null;\n    // console.log('called');\n\n    if (duration === 0) {\n      fn.apply(elem);\n      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n      return;\n    }\n\n    function move(ts) {\n      if (!start) start = ts;\n      // console.log(start, ts);\n      prog = ts - start;\n      fn.apply(elem);\n\n      if (prog < duration) {\n        anim = window.requestAnimationFrame(move, elem);\n      } else {\n        window.cancelAnimationFrame(anim);\n        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\n      }\n    }\n    anim = window.requestAnimationFrame(move);\n  }\n\n  /**\n   * Animates an element in or out using a CSS transition class.\n   * @function\n   * @private\n   * @param {Boolean} isIn - Defines if the animation is in or out.\n   * @param {Object} element - jQuery or HTML object to animate.\n   * @param {String} animation - CSS class to use.\n   * @param {Function} cb - Callback to run when animation is finished.\n   */\n  function animate(isIn, element, animation, cb) {\n    element = $(element).eq(0);\n\n    if (!element.length) return;\n\n    var initClass = isIn ? initClasses[0] : initClasses[1];\n    var activeClass = isIn ? activeClasses[0] : activeClasses[1];\n\n    // Set up the animation\n    reset();\n\n    element.addClass(animation).css('transition', 'none');\n\n    requestAnimationFrame(function () {\n      element.addClass(initClass);\n      if (isIn) element.show();\n    });\n\n    // Start the animation\n    requestAnimationFrame(function () {\n      element[0].offsetWidth;\n      element.css('transition', '').addClass(activeClass);\n    });\n\n    // Clean up the animation when it finishes\n    element.one(Foundation.transitionend(element), finish);\n\n    // Hides the element (for out animations), resets the element, and runs a callback\n    function finish() {\n      if (!isIn) element.hide();\n      reset();\n      if (cb) cb.apply(element);\n    }\n\n    // Resets transitions and removes motion-specific classes\n    function reset() {\n      element[0].style.transitionDuration = 0;\n      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);\n    }\n  }\n\n  Foundation.Move = Move;\n  Foundation.Motion = Motion;\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5tb3Rpb24uanM/ZjY0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBNb3Rpb24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXG4gICAqL1xuXG4gIHZhciBpbml0Q2xhc3NlcyA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xuICB2YXIgYWN0aXZlQ2xhc3NlcyA9IFsnbXVpLWVudGVyLWFjdGl2ZScsICdtdWktbGVhdmUtYWN0aXZlJ107XG5cbiAgdmFyIE1vdGlvbiA9IHtcbiAgICBhbmltYXRlSW46IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XG4gICAgICBhbmltYXRlKHRydWUsIGVsZW1lbnQsIGFuaW1hdGlvbiwgY2IpO1xuICAgIH0sXG5cbiAgICBhbmltYXRlT3V0OiBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgICAgYW5pbWF0ZShmYWxzZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1vdmUoZHVyYXRpb24sIGVsZW0sIGZuKSB7XG4gICAgdmFyIGFuaW0sXG4gICAgICAgIHByb2csXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5cbiAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgIGZuLmFwcGx5KGVsZW0pO1xuICAgICAgZWxlbS50cmlnZ2VyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKS50cmlnZ2VySGFuZGxlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZSh0cykge1xuICAgICAgaWYgKCFzdGFydCkgc3RhcnQgPSB0cztcbiAgICAgIC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG4gICAgICBwcm9nID0gdHMgLSBzdGFydDtcbiAgICAgIGZuLmFwcGx5KGVsZW0pO1xuXG4gICAgICBpZiAocHJvZyA8IGR1cmF0aW9uKSB7XG4gICAgICAgIGFuaW0gPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vdmUsIGVsZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW0pO1xuICAgICAgICBlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pLnRyaWdnZXJIYW5kbGVyKCdmaW5pc2hlZC56Zi5hbmltYXRlJywgW2VsZW1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSk7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9yIEhUTUwgb2JqZWN0IHRvIGFuaW1hdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbmltYXRpb24gLSBDU1MgY2xhc3MgdG8gdXNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFuaW1hdGUoaXNJbiwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xuICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpLmVxKDApO1xuXG4gICAgaWYgKCFlbGVtZW50Lmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIGluaXRDbGFzcyA9IGlzSW4gPyBpbml0Q2xhc3Nlc1swXSA6IGluaXRDbGFzc2VzWzFdO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IGlzSW4gPyBhY3RpdmVDbGFzc2VzWzBdIDogYWN0aXZlQ2xhc3Nlc1sxXTtcblxuICAgIC8vIFNldCB1cCB0aGUgYW5pbWF0aW9uXG4gICAgcmVzZXQoKTtcblxuICAgIGVsZW1lbnQuYWRkQ2xhc3MoYW5pbWF0aW9uKS5jc3MoJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoaW5pdENsYXNzKTtcbiAgICAgIGlmIChpc0luKSBlbGVtZW50LnNob3coKTtcbiAgICB9KTtcblxuICAgIC8vIFN0YXJ0IHRoZSBhbmltYXRpb25cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgZWxlbWVudFswXS5vZmZzZXRXaWR0aDtcbiAgICAgIGVsZW1lbnQuY3NzKCd0cmFuc2l0aW9uJywgJycpLmFkZENsYXNzKGFjdGl2ZUNsYXNzKTtcbiAgICB9KTtcblxuICAgIC8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuICAgIGVsZW1lbnQub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChlbGVtZW50KSwgZmluaXNoKTtcblxuICAgIC8vIEhpZGVzIHRoZSBlbGVtZW50IChmb3Igb3V0IGFuaW1hdGlvbnMpLCByZXNldHMgdGhlIGVsZW1lbnQsIGFuZCBydW5zIGEgY2FsbGJhY2tcbiAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICBpZiAoIWlzSW4pIGVsZW1lbnQuaGlkZSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlmIChjYikgY2IuYXBwbHkoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBlbGVtZW50WzBdLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IDA7XG4gICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGluaXRDbGFzcyArICcgJyArIGFjdGl2ZUNsYXNzICsgJyAnICsgYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBGb3VuZGF0aW9uLk1vdmUgPSBNb3ZlO1xuICBGb3VuZGF0aW9uLk1vdGlvbiA9IE1vdGlvbjtcbn0oalF1ZXJ5KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLm1vdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 24 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  var Nest = {\n    Feather: function (menu) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'zf';\n\n      menu.attr('role', 'menubar');\n\n      var items = menu.find('li').attr({ 'role': 'menuitem' }),\n          subMenuClass = 'is-' + type + '-submenu',\n          subItemClass = subMenuClass + '-item',\n          hasSubClass = 'is-' + type + '-submenu-parent';\n\n      items.each(function () {\n        var $item = $(this),\n            $sub = $item.children('ul');\n\n        if ($sub.length) {\n          $item.addClass(hasSubClass).attr({\n            'aria-haspopup': true,\n            'aria-label': $item.children('a:first').text()\n          });\n          // Note:  Drilldowns behave differently in how they hide, and so need\n          // additional attributes.  We should look if this possibly over-generalized\n          // utility (Nest) is appropriate when we rework menus in 6.4\n          if (type === 'drilldown') {\n            $item.attr({ 'aria-expanded': false });\n          }\n\n          $sub.addClass('submenu ' + subMenuClass).attr({\n            'data-submenu': '',\n            'role': 'menu'\n          });\n          if (type === 'drilldown') {\n            $sub.attr({ 'aria-hidden': true });\n          }\n        }\n\n        if ($item.parent('[data-submenu]').length) {\n          $item.addClass('is-submenu-item ' + subItemClass);\n        }\n      });\n\n      return;\n    },\n    Burn: function (menu, type) {\n      var //items = menu.find('li'),\n      subMenuClass = 'is-' + type + '-submenu',\n          subItemClass = subMenuClass + '-item',\n          hasSubClass = 'is-' + type + '-submenu-parent';\n\n      menu.find('>li, .menu, .menu > li').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');\n\n      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')\n      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')\n      //           .removeAttr('data-submenu'));\n      // items.each(function(){\n      //   var $item = $(this),\n      //       $sub = $item.children('ul');\n      //   if($item.parent('[data-submenu]').length){\n      //     $item.removeClass('is-submenu-item ' + subItemClass);\n      //   }\n      //   if($sub.length){\n      //     $item.removeClass('has-submenu');\n      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');\n      //   }\n      // });\n    }\n  };\n\n  Foundation.Nest = Nest;\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzPzQxMWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24gKCQpIHtcblxuICB2YXIgTmVzdCA9IHtcbiAgICBGZWF0aGVyOiBmdW5jdGlvbiAobWVudSkge1xuICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd6Zic7XG5cbiAgICAgIG1lbnUuYXR0cigncm9sZScsICdtZW51YmFyJyk7XG5cbiAgICAgIHZhciBpdGVtcyA9IG1lbnUuZmluZCgnbGknKS5hdHRyKHsgJ3JvbGUnOiAnbWVudWl0ZW0nIH0pLFxuICAgICAgICAgIHN1Yk1lbnVDbGFzcyA9ICdpcy0nICsgdHlwZSArICctc3VibWVudScsXG4gICAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcbiAgICAgICAgICBoYXNTdWJDbGFzcyA9ICdpcy0nICsgdHlwZSArICctc3VibWVudS1wYXJlbnQnO1xuXG4gICAgICBpdGVtcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAgICAgICAgICRzdWIgPSAkaXRlbS5jaGlsZHJlbigndWwnKTtcblxuICAgICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcbiAgICAgICAgICAkaXRlbS5hZGRDbGFzcyhoYXNTdWJDbGFzcykuYXR0cih7XG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6ICRpdGVtLmNoaWxkcmVuKCdhOmZpcnN0JykudGV4dCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gTm90ZTogIERyaWxsZG93bnMgYmVoYXZlIGRpZmZlcmVudGx5IGluIGhvdyB0aGV5IGhpZGUsIGFuZCBzbyBuZWVkXG4gICAgICAgICAgLy8gYWRkaXRpb25hbCBhdHRyaWJ1dGVzLiAgV2Ugc2hvdWxkIGxvb2sgaWYgdGhpcyBwb3NzaWJseSBvdmVyLWdlbmVyYWxpemVkXG4gICAgICAgICAgLy8gdXRpbGl0eSAoTmVzdCkgaXMgYXBwcm9wcmlhdGUgd2hlbiB3ZSByZXdvcmsgbWVudXMgaW4gNi40XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkcmlsbGRvd24nKSB7XG4gICAgICAgICAgICAkaXRlbS5hdHRyKHsgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAkc3ViLmFkZENsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLmF0dHIoe1xuICAgICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxuICAgICAgICAgICAgJ3JvbGUnOiAnbWVudSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2RyaWxsZG93bicpIHtcbiAgICAgICAgICAgICRzdWIuYXR0cih7ICdhcmlhLWhpZGRlbic6IHRydWUgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRpdGVtLnBhcmVudCgnW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcbiAgICAgICAgICAkaXRlbS5hZGRDbGFzcygnaXMtc3VibWVudS1pdGVtICcgKyBzdWJJdGVtQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgQnVybjogZnVuY3Rpb24gKG1lbnUsIHR5cGUpIHtcbiAgICAgIHZhciAvL2l0ZW1zID0gbWVudS5maW5kKCdsaScpLFxuICAgICAgc3ViTWVudUNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51JyxcbiAgICAgICAgICBzdWJJdGVtQ2xhc3MgPSBzdWJNZW51Q2xhc3MgKyAnLWl0ZW0nLFxuICAgICAgICAgIGhhc1N1YkNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51LXBhcmVudCc7XG5cbiAgICAgIG1lbnUuZmluZCgnPmxpLCAubWVudSwgLm1lbnUgPiBsaScpLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgJyArIGhhc1N1YkNsYXNzICsgJyBpcy1zdWJtZW51LWl0ZW0gc3VibWVudSBpcy1hY3RpdmUnKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKS5jc3MoJ2Rpc3BsYXknLCAnJyk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCAgICAgIG1lbnUuZmluZCgnLicgKyBzdWJNZW51Q2xhc3MgKyAnLCAuJyArIHN1Ykl0ZW1DbGFzcyArICcsIC5oYXMtc3VibWVudSwgLmlzLXN1Ym1lbnUtaXRlbSwgLnN1Ym1lbnUsIFtkYXRhLXN1Ym1lbnVdJylcbiAgICAgIC8vICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc3ViTWVudUNsYXNzICsgJyAnICsgc3ViSXRlbUNsYXNzICsgJyBoYXMtc3VibWVudSBpcy1zdWJtZW51LWl0ZW0gc3VibWVudScpXG4gICAgICAvLyAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpKTtcbiAgICAgIC8vIGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIC8vICAgdmFyICRpdGVtID0gJCh0aGlzKSxcbiAgICAgIC8vICAgICAgICRzdWIgPSAkaXRlbS5jaGlsZHJlbigndWwnKTtcbiAgICAgIC8vICAgaWYoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCl7XG4gICAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2lzLXN1Ym1lbnUtaXRlbSAnICsgc3ViSXRlbUNsYXNzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gICBpZigkc3ViLmxlbmd0aCl7XG4gICAgICAvLyAgICAgJGl0ZW0ucmVtb3ZlQ2xhc3MoJ2hhcy1zdWJtZW51Jyk7XG4gICAgICAvLyAgICAgJHN1Yi5yZW1vdmVDbGFzcygnc3VibWVudSAnICsgc3ViTWVudUNsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLXN1Ym1lbnUnKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSk7XG4gICAgfVxuICB9O1xuXG4gIEZvdW5kYXRpb24uTmVzdCA9IE5lc3Q7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC5uZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  function Timer(elem, options, cb) {\n    var _this = this,\n        duration = options.duration,\n        //options is an object for easily adding features later.\n    nameSpace = Object.keys(elem.data())[0] || 'timer',\n        remain = -1,\n        start,\n        timer;\n\n    this.isPaused = false;\n\n    this.restart = function () {\n      remain = -1;\n      clearTimeout(timer);\n      this.start();\n    };\n\n    this.start = function () {\n      this.isPaused = false;\n      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\n      clearTimeout(timer);\n      remain = remain <= 0 ? duration : remain;\n      elem.data('paused', false);\n      start = Date.now();\n      timer = setTimeout(function () {\n        if (options.infinite) {\n          _this.restart(); //rerun the timer.\n        }\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      }, remain);\n      elem.trigger('timerstart.zf.' + nameSpace);\n    };\n\n    this.pause = function () {\n      this.isPaused = true;\n      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\n      clearTimeout(timer);\n      elem.data('paused', true);\n      var end = Date.now();\n      remain = remain - (end - start);\n      elem.trigger('timerpaused.zf.' + nameSpace);\n    };\n  }\n\n  /**\n   * Runs a callback function when images are fully loaded.\n   * @param {Object} images - Image(s) to check if loaded.\n   * @param {Func} callback - Function to execute when image is fully loaded.\n   */\n  function onImagesLoaded(images, callback) {\n    var self = this,\n        unloaded = images.length;\n\n    if (unloaded === 0) {\n      callback();\n    }\n\n    images.each(function () {\n      // Check if image is loaded\n      if (this.complete || this.readyState === 4 || this.readyState === 'complete') {\n        singleImageLoaded();\n      }\n      // Force load the image\n      else {\n          // fix for IE. See https://css-tricks.com/snippets/jquery/fixing-load-in-ie-for-cached-images/\n          var src = $(this).attr('src');\n          $(this).attr('src', src + (src.indexOf('?') >= 0 ? '&' : '?') + new Date().getTime());\n          $(this).one('load', function () {\n            singleImageLoaded();\n          });\n        }\n    });\n\n    function singleImageLoaded() {\n      unloaded--;\n      if (unloaded === 0) {\n        callback();\n      }\n    }\n  }\n\n  Foundation.Timer = Timer;\n  Foundation.onImagesLoaded = onImagesLoaded;\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyLmpzPzc0MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4hZnVuY3Rpb24gKCQpIHtcblxuICBmdW5jdGlvbiBUaW1lcihlbGVtLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgLy9vcHRpb25zIGlzIGFuIG9iamVjdCBmb3IgZWFzaWx5IGFkZGluZyBmZWF0dXJlcyBsYXRlci5cbiAgICBuYW1lU3BhY2UgPSBPYmplY3Qua2V5cyhlbGVtLmRhdGEoKSlbMF0gfHwgJ3RpbWVyJyxcbiAgICAgICAgcmVtYWluID0gLTEsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICB0aW1lcjtcblxuICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbWFpbiA9IC0xO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIC8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHJlbWFpbiA9IHJlbWFpbiA8PSAwID8gZHVyYXRpb24gOiByZW1haW47XG4gICAgICBlbGVtLmRhdGEoJ3BhdXNlZCcsIGZhbHNlKTtcbiAgICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluZmluaXRlKSB7XG4gICAgICAgICAgX3RoaXMucmVzdGFydCgpOyAvL3JlcnVuIHRoZSB0aW1lci5cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfSwgcmVtYWluKTtcbiAgICAgIGVsZW0udHJpZ2dlcigndGltZXJzdGFydC56Zi4nICsgbmFtZVNwYWNlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuICAgICAgLy9pZihlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIGVsZW0uZGF0YSgncGF1c2VkJywgdHJ1ZSk7XG4gICAgICB2YXIgZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgIHJlbWFpbiA9IHJlbWFpbiAtIChlbmQgLSBzdGFydCk7XG4gICAgICBlbGVtLnRyaWdnZXIoJ3RpbWVycGF1c2VkLnpmLicgKyBuYW1lU3BhY2UpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gaW1hZ2VzIGFyZSBmdWxseSBsb2FkZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXG4gICAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gb25JbWFnZXNMb2FkZWQoaW1hZ2VzLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdW5sb2FkZWQgPSBpbWFnZXMubGVuZ3RoO1xuXG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGltYWdlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIENoZWNrIGlmIGltYWdlIGlzIGxvYWRlZFxuICAgICAgaWYgKHRoaXMuY29tcGxldGUgfHwgdGhpcy5yZWFkeVN0YXRlID09PSA0IHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBzaW5nbGVJbWFnZUxvYWRlZCgpO1xuICAgICAgfVxuICAgICAgLy8gRm9yY2UgbG9hZCB0aGUgaW1hZ2VcbiAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGZpeCBmb3IgSUUuIFNlZSBodHRwczovL2Nzcy10cmlja3MuY29tL3NuaXBwZXRzL2pxdWVyeS9maXhpbmctbG9hZC1pbi1pZS1mb3ItY2FjaGVkLWltYWdlcy9cbiAgICAgICAgICB2YXIgc3JjID0gJCh0aGlzKS5hdHRyKCdzcmMnKTtcbiAgICAgICAgICAkKHRoaXMpLmF0dHIoJ3NyYycsIHNyYyArIChzcmMuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICQodGhpcykub25lKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gc2luZ2xlSW1hZ2VMb2FkZWQoKSB7XG4gICAgICB1bmxvYWRlZC0tO1xuICAgICAgaWYgKHVubG9hZGVkID09PSAwKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgRm91bmRhdGlvbi5UaW1lciA9IFRpbWVyO1xuICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkID0gb25JbWFnZXNMb2FkZWQ7XG59KGpRdWVyeSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 26 */
/***/ function(module, exports) {

eval("//**************************************************\n//**Work inspired by multiple jquery swipe plugins**\n//**Done by Yohai Ararat ***************************\n//**************************************************\n(function ($) {\n\n\t$.spotSwipe = {\n\t\tversion: '1.0.0',\n\t\tenabled: 'ontouchstart' in document.documentElement,\n\t\tpreventDefault: false,\n\t\tmoveThreshold: 75,\n\t\ttimeThreshold: 200\n\t};\n\n\tvar startPosX,\n\t    startPosY,\n\t    startTime,\n\t    elapsedTime,\n\t    isMoving = false;\n\n\tfunction onTouchEnd() {\n\t\t//  alert(this);\n\t\tthis.removeEventListener('touchmove', onTouchMove);\n\t\tthis.removeEventListener('touchend', onTouchEnd);\n\t\tisMoving = false;\n\t}\n\n\tfunction onTouchMove(e) {\n\t\tif ($.spotSwipe.preventDefault) {\n\t\t\te.preventDefault();\n\t\t}\n\t\tif (isMoving) {\n\t\t\tvar x = e.touches[0].pageX;\n\t\t\tvar y = e.touches[0].pageY;\n\t\t\tvar dx = startPosX - x;\n\t\t\tvar dy = startPosY - y;\n\t\t\tvar dir;\n\t\t\telapsedTime = new Date().getTime() - startTime;\n\t\t\tif (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\n\t\t\t\tdir = dx > 0 ? 'left' : 'right';\n\t\t\t}\n\t\t\t// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\n\t\t\t//   dir = dy > 0 ? 'down' : 'up';\n\t\t\t// }\n\t\t\tif (dir) {\n\t\t\t\te.preventDefault();\n\t\t\t\tonTouchEnd.call(this);\n\t\t\t\t$(this).trigger('swipe', dir).trigger('swipe' + dir);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onTouchStart(e) {\n\t\tif (e.touches.length == 1) {\n\t\t\tstartPosX = e.touches[0].pageX;\n\t\t\tstartPosY = e.touches[0].pageY;\n\t\t\tisMoving = true;\n\t\t\tstartTime = new Date().getTime();\n\t\t\tthis.addEventListener('touchmove', onTouchMove, false);\n\t\t\tthis.addEventListener('touchend', onTouchEnd, false);\n\t\t}\n\t}\n\n\tfunction init() {\n\t\tthis.addEventListener && this.addEventListener('touchstart', onTouchStart, false);\n\t}\n\n\tfunction teardown() {\n\t\tthis.removeEventListener('touchstart', onTouchStart);\n\t}\n\n\t$.event.special.swipe = { setup: init };\n\n\t$.each(['left', 'up', 'down', 'right'], function () {\n\t\t$.event.special['swipe' + this] = { setup: function () {\n\t\t\t\t$(this).on('swipe', $.noop);\n\t\t\t} };\n\t});\n})(jQuery);\n/****************************************************\n * Method for adding psuedo drag events to elements *\n ***************************************************/\n!function ($) {\n\t$.fn.addTouch = function () {\n\t\tthis.each(function (i, el) {\n\t\t\t$(el).bind('touchstart touchmove touchend touchcancel', function () {\n\t\t\t\t//we pass the original event object because the jQuery event\n\t\t\t\t//object is normalized to w3c specs and does not provide the TouchList\n\t\t\t\thandleTouch(event);\n\t\t\t});\n\t\t});\n\n\t\tvar handleTouch = function (event) {\n\t\t\tvar touches = event.changedTouches,\n\t\t\t    first = touches[0],\n\t\t\t    eventTypes = {\n\t\t\t\ttouchstart: 'mousedown',\n\t\t\t\ttouchmove: 'mousemove',\n\t\t\t\ttouchend: 'mouseup'\n\t\t\t},\n\t\t\t    type = eventTypes[event.type],\n\t\t\t    simulatedEvent;\n\n\t\t\tif ('MouseEvent' in window && typeof window.MouseEvent === 'function') {\n\t\t\t\tsimulatedEvent = new window.MouseEvent(type, {\n\t\t\t\t\t'bubbles': true,\n\t\t\t\t\t'cancelable': true,\n\t\t\t\t\t'screenX': first.screenX,\n\t\t\t\t\t'screenY': first.screenY,\n\t\t\t\t\t'clientX': first.clientX,\n\t\t\t\t\t'clientY': first.clientY\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsimulatedEvent = document.createEvent('MouseEvent');\n\t\t\t\tsimulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);\n\t\t\t}\n\t\t\tfirst.target.dispatchEvent(simulatedEvent);\n\t\t};\n\t};\n}(jQuery);\n\n//**********************************\n//**From the jQuery Mobile Library**\n//**need to recreate functionality**\n//**and try to improve if possible**\n//**********************************\n\n/* Removing the jQuery function ****\n************************************\n\n(function( $, window, undefined ) {\n\n\tvar $document = $( document ),\n\t\t// supportTouch = $.mobile.support.touch,\n\t\ttouchStartEvent = 'touchstart'//supportTouch ? \"touchstart\" : \"mousedown\",\n\t\ttouchStopEvent = 'touchend'//supportTouch ? \"touchend\" : \"mouseup\",\n\t\ttouchMoveEvent = 'touchmove'//supportTouch ? \"touchmove\" : \"mousemove\";\n\n\t// setup new event shortcuts\n\t$.each( ( \"touchstart touchmove touchend \" +\n\t\t\"swipe swipeleft swiperight\" ).split( \" \" ), function( i, name ) {\n\n\t\t$.fn[ name ] = function( fn ) {\n\t\t\treturn fn ? this.bind( name, fn ) : this.trigger( name );\n\t\t};\n\n\t\t// jQuery < 1.8\n\t\tif ( $.attrFn ) {\n\t\t\t$.attrFn[ name ] = true;\n\t\t}\n\t});\n\n\tfunction triggerCustomEvent( obj, eventType, event, bubble ) {\n\t\tvar originalType = event.type;\n\t\tevent.type = eventType;\n\t\tif ( bubble ) {\n\t\t\t$.event.trigger( event, undefined, obj );\n\t\t} else {\n\t\t\t$.event.dispatch.call( obj, event );\n\t\t}\n\t\tevent.type = originalType;\n\t}\n\n\t// also handles taphold\n\n\t// Also handles swipeleft, swiperight\n\t$.event.special.swipe = {\n\n\t\t// More than this horizontal displacement, and we will suppress scrolling.\n\t\tscrollSupressionThreshold: 30,\n\n\t\t// More time than this, and it isn't a swipe.\n\t\tdurationThreshold: 1000,\n\n\t\t// Swipe horizontal displacement must be more than this.\n\t\thorizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,\n\n\t\t// Swipe vertical displacement must be less than this.\n\t\tverticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,\n\n\t\tgetLocation: function ( event ) {\n\t\t\tvar winPageX = window.pageXOffset,\n\t\t\t\twinPageY = window.pageYOffset,\n\t\t\t\tx = event.clientX,\n\t\t\t\ty = event.clientY;\n\n\t\t\tif ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||\n\t\t\t\tevent.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {\n\n\t\t\t\t// iOS4 clientX/clientY have the value that should have been\n\t\t\t\t// in pageX/pageY. While pageX/page/ have the value 0\n\t\t\t\tx = x - winPageX;\n\t\t\t\ty = y - winPageY;\n\t\t\t} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {\n\n\t\t\t\t// Some Android browsers have totally bogus values for clientX/Y\n\t\t\t\t// when scrolling/zooming a page. Detectable since clientX/clientY\n\t\t\t\t// should never be smaller than pageX/pageY minus page scroll\n\t\t\t\tx = event.pageX - winPageX;\n\t\t\t\ty = event.pageY - winPageY;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t};\n\t\t},\n\n\t\tstart: function( event ) {\n\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,\n\t\t\t\tlocation = $.event.special.swipe.getLocation( data );\n\t\t\treturn {\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\t\tcoords: [ location.x, location.y ],\n\t\t\t\t\t\torigin: $( event.target )\n\t\t\t\t\t};\n\t\t},\n\n\t\tstop: function( event ) {\n\t\t\tvar data = event.originalEvent.touches ?\n\t\t\t\t\tevent.originalEvent.touches[ 0 ] : event,\n\t\t\t\tlocation = $.event.special.swipe.getLocation( data );\n\t\t\treturn {\n\t\t\t\t\t\ttime: ( new Date() ).getTime(),\n\t\t\t\t\t\tcoords: [ location.x, location.y ]\n\t\t\t\t\t};\n\t\t},\n\n\t\thandleSwipe: function( start, stop, thisObject, origTarget ) {\n\t\t\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&\n\t\t\t\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&\n\t\t\t\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {\n\t\t\t\tvar direction = start.coords[0] > stop.coords[ 0 ] ? \"swipeleft\" : \"swiperight\";\n\n\t\t\t\ttriggerCustomEvent( thisObject, \"swipe\", $.Event( \"swipe\", { target: origTarget, swipestart: start, swipestop: stop }), true );\n\t\t\t\ttriggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\n\t\t},\n\n\t\t// This serves as a flag to ensure that at most one swipe event event is\n\t\t// in work at any given time\n\t\teventInProgress: false,\n\n\t\tsetup: function() {\n\t\t\tvar events,\n\t\t\t\tthisObject = this,\n\t\t\t\t$this = $( thisObject ),\n\t\t\t\tcontext = {};\n\n\t\t\t// Retrieve the events data for this element and add the swipe context\n\t\t\tevents = $.data( this, \"mobile-events\" );\n\t\t\tif ( !events ) {\n\t\t\t\tevents = { length: 0 };\n\t\t\t\t$.data( this, \"mobile-events\", events );\n\t\t\t}\n\t\t\tevents.length++;\n\t\t\tevents.swipe = context;\n\n\t\t\tcontext.start = function( event ) {\n\n\t\t\t\t// Bail if we're already working on a swipe event\n\t\t\t\tif ( $.event.special.swipe.eventInProgress ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t$.event.special.swipe.eventInProgress = true;\n\n\t\t\t\tvar stop,\n\t\t\t\t\tstart = $.event.special.swipe.start( event ),\n\t\t\t\t\torigTarget = event.target,\n\t\t\t\t\temitted = false;\n\n\t\t\t\tcontext.move = function( event ) {\n\t\t\t\t\tif ( !start || event.isDefaultPrevented() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstop = $.event.special.swipe.stop( event );\n\t\t\t\t\tif ( !emitted ) {\n\t\t\t\t\t\temitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );\n\t\t\t\t\t\tif ( emitted ) {\n\n\t\t\t\t\t\t\t// Reset the context to make way for the next swipe event\n\t\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// prevent scrolling\n\t\t\t\t\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tcontext.stop = function() {\n\t\t\t\t\t\temitted = true;\n\n\t\t\t\t\t\t// Reset the context to make way for the next swipe event\n\t\t\t\t\t\t$.event.special.swipe.eventInProgress = false;\n\t\t\t\t\t\t$document.off( touchMoveEvent, context.move );\n\t\t\t\t\t\tcontext.move = null;\n\t\t\t\t};\n\n\t\t\t\t$document.on( touchMoveEvent, context.move )\n\t\t\t\t\t.one( touchStopEvent, context.stop );\n\t\t\t};\n\t\t\t$this.on( touchStartEvent, context.start );\n\t\t},\n\n\t\tteardown: function() {\n\t\t\tvar events, context;\n\n\t\t\tevents = $.data( this, \"mobile-events\" );\n\t\t\tif ( events ) {\n\t\t\t\tcontext = events.swipe;\n\t\t\t\tdelete events.swipe;\n\t\t\t\tevents.length--;\n\t\t\t\tif ( events.length === 0 ) {\n\t\t\t\t\t$.removeData( this, \"mobile-events\" );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( context ) {\n\t\t\t\tif ( context.start ) {\n\t\t\t\t\t$( this ).off( touchStartEvent, context.start );\n\t\t\t\t}\n\t\t\t\tif ( context.move ) {\n\t\t\t\t\t$document.off( touchMoveEvent, context.move );\n\t\t\t\t}\n\t\t\t\tif ( context.stop ) {\n\t\t\t\t\t$document.off( touchStopEvent, context.stop );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\t$.each({\n\t\tswipeleft: \"swipe.left\",\n\t\tswiperight: \"swipe.right\"\n\t}, function( event, sourceEvent ) {\n\n\t\t$.event.special[ event ] = {\n\t\t\tsetup: function() {\n\t\t\t\t$( this ).bind( sourceEvent, $.noop );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\t$( this ).unbind( sourceEvent );\n\t\t\t}\n\t\t};\n\t});\n})( jQuery, this );\n*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50b3VjaC5qcz9jZThkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipXb3JrIGluc3BpcmVkIGJ5IG11bHRpcGxlIGpxdWVyeSBzd2lwZSBwbHVnaW5zKipcbi8vKipEb25lIGJ5IFlvaGFpIEFyYXJhdCAqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbihmdW5jdGlvbiAoJCkge1xuXG5cdCQuc3BvdFN3aXBlID0ge1xuXHRcdHZlcnNpb246ICcxLjAuMCcsXG5cdFx0ZW5hYmxlZDogJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuXHRcdHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblx0XHRtb3ZlVGhyZXNob2xkOiA3NSxcblx0XHR0aW1lVGhyZXNob2xkOiAyMDBcblx0fTtcblxuXHR2YXIgc3RhcnRQb3NYLFxuXHQgICAgc3RhcnRQb3NZLFxuXHQgICAgc3RhcnRUaW1lLFxuXHQgICAgZWxhcHNlZFRpbWUsXG5cdCAgICBpc01vdmluZyA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIG9uVG91Y2hFbmQoKSB7XG5cdFx0Ly8gIGFsZXJ0KHRoaXMpO1xuXHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Ub3VjaE1vdmUpO1xuXHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoRW5kKTtcblx0XHRpc01vdmluZyA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xuXHRcdGlmICgkLnNwb3RTd2lwZS5wcmV2ZW50RGVmYXVsdCkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0XHRpZiAoaXNNb3ZpbmcpIHtcblx0XHRcdHZhciB4ID0gZS50b3VjaGVzWzBdLnBhZ2VYO1xuXHRcdFx0dmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XG5cdFx0XHR2YXIgZHggPSBzdGFydFBvc1ggLSB4O1xuXHRcdFx0dmFyIGR5ID0gc3RhcnRQb3NZIC0geTtcblx0XHRcdHZhciBkaXI7XG5cdFx0XHRlbGFwc2VkVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lO1xuXHRcdFx0aWYgKE1hdGguYWJzKGR4KSA+PSAkLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkICYmIGVsYXBzZWRUaW1lIDw9ICQuc3BvdFN3aXBlLnRpbWVUaHJlc2hvbGQpIHtcblx0XHRcdFx0ZGlyID0gZHggPiAwID8gJ2xlZnQnIDogJ3JpZ2h0Jztcblx0XHRcdH1cblx0XHRcdC8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuXHRcdFx0Ly8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xuXHRcdFx0Ly8gfVxuXHRcdFx0aWYgKGRpcikge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdG9uVG91Y2hFbmQuY2FsbCh0aGlzKTtcblx0XHRcdFx0JCh0aGlzKS50cmlnZ2VyKCdzd2lwZScsIGRpcikudHJpZ2dlcignc3dpcGUnICsgZGlyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcblx0XHRcdHN0YXJ0UG9zWCA9IGUudG91Y2hlc1swXS5wYWdlWDtcblx0XHRcdHN0YXJ0UG9zWSA9IGUudG91Y2hlc1swXS5wYWdlWTtcblx0XHRcdGlzTW92aW5nID0gdHJ1ZTtcblx0XHRcdHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHRlYXJkb3duKCkge1xuXHRcdHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCk7XG5cdH1cblxuXHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7IHNldHVwOiBpbml0IH07XG5cblx0JC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcblx0XHQkLmV2ZW50LnNwZWNpYWxbJ3N3aXBlJyArIHRoaXNdID0geyBzZXR1cDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQkKHRoaXMpLm9uKCdzd2lwZScsICQubm9vcCk7XG5cdFx0XHR9IH07XG5cdH0pO1xufSkoalF1ZXJ5KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBNZXRob2QgZm9yIGFkZGluZyBwc3VlZG8gZHJhZyBldmVudHMgdG8gZWxlbWVudHMgKlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiFmdW5jdGlvbiAoJCkge1xuXHQkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcblx0XHRcdCQoZWwpLmJpbmQoJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvL3dlIHBhc3MgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBiZWNhdXNlIHRoZSBqUXVlcnkgZXZlbnRcblx0XHRcdFx0Ly9vYmplY3QgaXMgbm9ybWFsaXplZCB0byB3M2Mgc3BlY3MgYW5kIGRvZXMgbm90IHByb3ZpZGUgdGhlIFRvdWNoTGlzdFxuXHRcdFx0XHRoYW5kbGVUb3VjaChldmVudCk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHZhciBoYW5kbGVUb3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0dmFyIHRvdWNoZXMgPSBldmVudC5jaGFuZ2VkVG91Y2hlcyxcblx0XHRcdCAgICBmaXJzdCA9IHRvdWNoZXNbMF0sXG5cdFx0XHQgICAgZXZlbnRUeXBlcyA9IHtcblx0XHRcdFx0dG91Y2hzdGFydDogJ21vdXNlZG93bicsXG5cdFx0XHRcdHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG5cdFx0XHRcdHRvdWNoZW5kOiAnbW91c2V1cCdcblx0XHRcdH0sXG5cdFx0XHQgICAgdHlwZSA9IGV2ZW50VHlwZXNbZXZlbnQudHlwZV0sXG5cdFx0XHQgICAgc2ltdWxhdGVkRXZlbnQ7XG5cblx0XHRcdGlmICgnTW91c2VFdmVudCcgaW4gd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRzaW11bGF0ZWRFdmVudCA9IG5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLCB7XG5cdFx0XHRcdFx0J2J1YmJsZXMnOiB0cnVlLFxuXHRcdFx0XHRcdCdjYW5jZWxhYmxlJzogdHJ1ZSxcblx0XHRcdFx0XHQnc2NyZWVuWCc6IGZpcnN0LnNjcmVlblgsXG5cdFx0XHRcdFx0J3NjcmVlblknOiBmaXJzdC5zY3JlZW5ZLFxuXHRcdFx0XHRcdCdjbGllbnRYJzogZmlyc3QuY2xpZW50WCxcblx0XHRcdFx0XHQnY2xpZW50WSc6IGZpcnN0LmNsaWVudFlcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XG5cdFx0XHRcdHNpbXVsYXRlZEV2ZW50LmluaXRNb3VzZUV2ZW50KHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgZmlyc3Quc2NyZWVuWCwgZmlyc3Quc2NyZWVuWSwgZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAgLypsZWZ0Ki8sIG51bGwpO1xuXHRcdFx0fVxuXHRcdFx0Zmlyc3QudGFyZ2V0LmRpc3BhdGNoRXZlbnQoc2ltdWxhdGVkRXZlbnQpO1xuXHRcdH07XG5cdH07XG59KGpRdWVyeSk7XG5cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKkZyb20gdGhlIGpRdWVyeSBNb2JpbGUgTGlicmFyeSoqXG4vLyoqbmVlZCB0byByZWNyZWF0ZSBmdW5jdGlvbmFsaXR5Kipcbi8vKiphbmQgdHJ5IHRvIGltcHJvdmUgaWYgcG9zc2libGUqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8qIFJlbW92aW5nIHRoZSBqUXVlcnkgZnVuY3Rpb24gKioqKlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XG5cblx0dmFyICRkb2N1bWVudCA9ICQoIGRvY3VtZW50ICksXG5cdFx0Ly8gc3VwcG9ydFRvdWNoID0gJC5tb2JpbGUuc3VwcG9ydC50b3VjaCxcblx0XHR0b3VjaFN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCcvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWRvd25cIixcblx0XHR0b3VjaFN0b3BFdmVudCA9ICd0b3VjaGVuZCcvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2V1cFwiLFxuXHRcdHRvdWNoTW92ZUV2ZW50ID0gJ3RvdWNobW92ZScvL3N1cHBvcnRUb3VjaCA/IFwidG91Y2htb3ZlXCIgOiBcIm1vdXNlbW92ZVwiO1xuXG5cdC8vIHNldHVwIG5ldyBldmVudCBzaG9ydGN1dHNcblx0JC5lYWNoKCAoIFwidG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgXCIgK1xuXHRcdFwic3dpcGUgc3dpcGVsZWZ0IHN3aXBlcmlnaHRcIiApLnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHRcdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdHJldHVybiBmbiA/IHRoaXMuYmluZCggbmFtZSwgZm4gKSA6IHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cblx0XHQvLyBqUXVlcnkgPCAxLjhcblx0XHRpZiAoICQuYXR0ckZuICkge1xuXHRcdFx0JC5hdHRyRm5bIG5hbWUgXSA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiB0cmlnZ2VyQ3VzdG9tRXZlbnQoIG9iaiwgZXZlbnRUeXBlLCBldmVudCwgYnViYmxlICkge1xuXHRcdHZhciBvcmlnaW5hbFR5cGUgPSBldmVudC50eXBlO1xuXHRcdGV2ZW50LnR5cGUgPSBldmVudFR5cGU7XG5cdFx0aWYgKCBidWJibGUgKSB7XG5cdFx0XHQkLmV2ZW50LnRyaWdnZXIoIGV2ZW50LCB1bmRlZmluZWQsIG9iaiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV2ZW50LmRpc3BhdGNoLmNhbGwoIG9iaiwgZXZlbnQgKTtcblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IG9yaWdpbmFsVHlwZTtcblx0fVxuXG5cdC8vIGFsc28gaGFuZGxlcyB0YXBob2xkXG5cblx0Ly8gQWxzbyBoYW5kbGVzIHN3aXBlbGVmdCwgc3dpcGVyaWdodFxuXHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7XG5cblx0XHQvLyBNb3JlIHRoYW4gdGhpcyBob3Jpem9udGFsIGRpc3BsYWNlbWVudCwgYW5kIHdlIHdpbGwgc3VwcHJlc3Mgc2Nyb2xsaW5nLlxuXHRcdHNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQ6IDMwLFxuXG5cdFx0Ly8gTW9yZSB0aW1lIHRoYW4gdGhpcywgYW5kIGl0IGlzbid0IGEgc3dpcGUuXG5cdFx0ZHVyYXRpb25UaHJlc2hvbGQ6IDEwMDAsXG5cblx0XHQvLyBTd2lwZSBob3Jpem9udGFsIGRpc3BsYWNlbWVudCBtdXN0IGJlIG1vcmUgdGhhbiB0aGlzLlxuXHRcdGhvcml6b250YWxEaXN0YW5jZVRocmVzaG9sZDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDE1IDogMzAsXG5cblx0XHQvLyBTd2lwZSB2ZXJ0aWNhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBsZXNzIHRoYW4gdGhpcy5cblx0XHR2ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcblxuXHRcdGdldExvY2F0aW9uOiBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXHRcdFx0dmFyIHdpblBhZ2VYID0gd2luZG93LnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHR3aW5QYWdlWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcblx0XHRcdFx0eCA9IGV2ZW50LmNsaWVudFgsXG5cdFx0XHRcdHkgPSBldmVudC5jbGllbnRZO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnBhZ2VZID09PSAwICYmIE1hdGguZmxvb3IoIHkgKSA+IE1hdGguZmxvb3IoIGV2ZW50LnBhZ2VZICkgfHxcblx0XHRcdFx0ZXZlbnQucGFnZVggPT09IDAgJiYgTWF0aC5mbG9vciggeCApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVggKSApIHtcblxuXHRcdFx0XHQvLyBpT1M0IGNsaWVudFgvY2xpZW50WSBoYXZlIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBoYXZlIGJlZW5cblx0XHRcdFx0Ly8gaW4gcGFnZVgvcGFnZVkuIFdoaWxlIHBhZ2VYL3BhZ2UvIGhhdmUgdGhlIHZhbHVlIDBcblx0XHRcdFx0eCA9IHggLSB3aW5QYWdlWDtcblx0XHRcdFx0eSA9IHkgLSB3aW5QYWdlWTtcblx0XHRcdH0gZWxzZSBpZiAoIHkgPCAoIGV2ZW50LnBhZ2VZIC0gd2luUGFnZVkpIHx8IHggPCAoIGV2ZW50LnBhZ2VYIC0gd2luUGFnZVggKSApIHtcblxuXHRcdFx0XHQvLyBTb21lIEFuZHJvaWQgYnJvd3NlcnMgaGF2ZSB0b3RhbGx5IGJvZ3VzIHZhbHVlcyBmb3IgY2xpZW50WC9ZXG5cdFx0XHRcdC8vIHdoZW4gc2Nyb2xsaW5nL3pvb21pbmcgYSBwYWdlLiBEZXRlY3RhYmxlIHNpbmNlIGNsaWVudFgvY2xpZW50WVxuXHRcdFx0XHQvLyBzaG91bGQgbmV2ZXIgYmUgc21hbGxlciB0aGFuIHBhZ2VYL3BhZ2VZIG1pbnVzIHBhZ2Ugc2Nyb2xsXG5cdFx0XHRcdHggPSBldmVudC5wYWdlWCAtIHdpblBhZ2VYO1xuXHRcdFx0XHR5ID0gZXZlbnQucGFnZVkgLSB3aW5QYWdlWTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0eDogeCxcblx0XHRcdFx0eTogeVxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBkYXRhID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzID9cblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbIDAgXSA6IGV2ZW50LFxuXHRcdFx0XHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcblx0XHRcdFx0XHRcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF0sXG5cdFx0XHRcdFx0XHRvcmlnaW46ICQoIGV2ZW50LnRhcmdldCApXG5cdFx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0c3RvcDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXG5cdFx0XHRcdGxvY2F0aW9uID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmdldExvY2F0aW9uKCBkYXRhICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0Y29vcmRzOiBbIGxvY2F0aW9uLngsIGxvY2F0aW9uLnkgXVxuXHRcdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdGhhbmRsZVN3aXBlOiBmdW5jdGlvbiggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKSB7XG5cdFx0XHRpZiAoIHN0b3AudGltZSAtIHN0YXJ0LnRpbWUgPCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZHVyYXRpb25UaHJlc2hvbGQgJiZcblx0XHRcdFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhvcml6b250YWxEaXN0YW5jZVRocmVzaG9sZCAmJlxuXHRcdFx0XHRNYXRoLmFicyggc3RhcnQuY29vcmRzWyAxIF0gLSBzdG9wLmNvb3Jkc1sgMSBdICkgPCAkLmV2ZW50LnNwZWNpYWwuc3dpcGUudmVydGljYWxEaXN0YW5jZVRocmVzaG9sZCApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGlvbiA9IHN0YXJ0LmNvb3Jkc1swXSA+IHN0b3AuY29vcmRzWyAwIF0gPyBcInN3aXBlbGVmdFwiIDogXCJzd2lwZXJpZ2h0XCI7XG5cblx0XHRcdFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBcInN3aXBlXCIsICQuRXZlbnQoIFwic3dpcGVcIiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSksIHRydWUgKTtcblx0XHRcdFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBkaXJlY3Rpb24sJC5FdmVudCggZGlyZWN0aW9uLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9ICksIHRydWUgKTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHR9LFxuXG5cdFx0Ly8gVGhpcyBzZXJ2ZXMgYXMgYSBmbGFnIHRvIGVuc3VyZSB0aGF0IGF0IG1vc3Qgb25lIHN3aXBlIGV2ZW50IGV2ZW50IGlzXG5cdFx0Ly8gaW4gd29yayBhdCBhbnkgZ2l2ZW4gdGltZVxuXHRcdGV2ZW50SW5Qcm9ncmVzczogZmFsc2UsXG5cblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZXZlbnRzLFxuXHRcdFx0XHR0aGlzT2JqZWN0ID0gdGhpcyxcblx0XHRcdFx0JHRoaXMgPSAkKCB0aGlzT2JqZWN0ICksXG5cdFx0XHRcdGNvbnRleHQgPSB7fTtcblxuXHRcdFx0Ly8gUmV0cmlldmUgdGhlIGV2ZW50cyBkYXRhIGZvciB0aGlzIGVsZW1lbnQgYW5kIGFkZCB0aGUgc3dpcGUgY29udGV4dFxuXHRcdFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0aWYgKCAhZXZlbnRzICkge1xuXHRcdFx0XHRldmVudHMgPSB7IGxlbmd0aDogMCB9O1xuXHRcdFx0XHQkLmRhdGEoIHRoaXMsIFwibW9iaWxlLWV2ZW50c1wiLCBldmVudHMgKTtcblx0XHRcdH1cblx0XHRcdGV2ZW50cy5sZW5ndGgrKztcblx0XHRcdGV2ZW50cy5zd2lwZSA9IGNvbnRleHQ7XG5cblx0XHRcdGNvbnRleHQuc3RhcnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gQmFpbCBpZiB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb24gYSBzd2lwZSBldmVudFxuXHRcdFx0XHRpZiAoICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG5cdFx0XHRcdHZhciBzdG9wLFxuXHRcdFx0XHRcdHN0YXJ0ID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnN0YXJ0KCBldmVudCApLFxuXHRcdFx0XHRcdG9yaWdUYXJnZXQgPSBldmVudC50YXJnZXQsXG5cdFx0XHRcdFx0ZW1pdHRlZCA9IGZhbHNlO1xuXG5cdFx0XHRcdGNvbnRleHQubW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFzdGFydCB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdG9wID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnN0b3AoIGV2ZW50ICk7XG5cdFx0XHRcdFx0aWYgKCAhZW1pdHRlZCApIHtcblx0XHRcdFx0XHRcdGVtaXR0ZWQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaGFuZGxlU3dpcGUoIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGVtaXR0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGNvbnRleHQgdG8gbWFrZSB3YXkgZm9yIHRoZSBuZXh0IHN3aXBlIGV2ZW50XG5cdFx0XHRcdFx0XHRcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcHJldmVudCBzY3JvbGxpbmdcblx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDAgXSAtIHN0b3AuY29vcmRzWyAwIF0gKSA+ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5zY3JvbGxTdXByZXNzaW9uVGhyZXNob2xkICkge1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Y29udGV4dC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRlbWl0dGVkID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGNvbnRleHQgdG8gbWFrZSB3YXkgZm9yIHRoZSBuZXh0IHN3aXBlIGV2ZW50XG5cdFx0XHRcdFx0XHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZXZlbnRJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlICk7XG5cdFx0XHRcdFx0XHRjb250ZXh0Lm1vdmUgPSBudWxsO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdCRkb2N1bWVudC5vbiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApXG5cdFx0XHRcdFx0Lm9uZSggdG91Y2hTdG9wRXZlbnQsIGNvbnRleHQuc3RvcCApO1xuXHRcdFx0fTtcblx0XHRcdCR0aGlzLm9uKCB0b3VjaFN0YXJ0RXZlbnQsIGNvbnRleHQuc3RhcnQgKTtcblx0XHR9LFxuXG5cdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGV2ZW50cywgY29udGV4dDtcblxuXHRcdFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcIm1vYmlsZS1ldmVudHNcIiApO1xuXHRcdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBldmVudHMuc3dpcGU7XG5cdFx0XHRcdGRlbGV0ZSBldmVudHMuc3dpcGU7XG5cdFx0XHRcdGV2ZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0aWYgKCBldmVudHMubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRcdCQucmVtb3ZlRGF0YSggdGhpcywgXCJtb2JpbGUtZXZlbnRzXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNvbnRleHQgKSB7XG5cdFx0XHRcdGlmICggY29udGV4dC5zdGFydCApIHtcblx0XHRcdFx0XHQkKCB0aGlzICkub2ZmKCB0b3VjaFN0YXJ0RXZlbnQsIGNvbnRleHQuc3RhcnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNvbnRleHQubW92ZSApIHtcblx0XHRcdFx0XHQkZG9jdW1lbnQub2ZmKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjb250ZXh0LnN0b3AgKSB7XG5cdFx0XHRcdFx0JGRvY3VtZW50Lm9mZiggdG91Y2hTdG9wRXZlbnQsIGNvbnRleHQuc3RvcCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHQkLmVhY2goe1xuXHRcdHN3aXBlbGVmdDogXCJzd2lwZS5sZWZ0XCIsXG5cdFx0c3dpcGVyaWdodDogXCJzd2lwZS5yaWdodFwiXG5cdH0sIGZ1bmN0aW9uKCBldmVudCwgc291cmNlRXZlbnQgKSB7XG5cblx0XHQkLmV2ZW50LnNwZWNpYWxbIGV2ZW50IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdCQoIHRoaXMgKS5iaW5kKCBzb3VyY2VFdmVudCwgJC5ub29wICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQkKCB0aGlzICkudW5iaW5kKCBzb3VyY2VFdmVudCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0pO1xufSkoIGpRdWVyeSwgdGhpcyApO1xuKi9cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLnRvdWNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\n!function ($) {\n\n  var MutationObserver = function () {\n    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\n    for (var i = 0; i < prefixes.length; i++) {\n      if (prefixes[i] + 'MutationObserver' in window) {\n        return window[prefixes[i] + 'MutationObserver'];\n      }\n    }\n    return false;\n  }();\n\n  var triggers = function (el, type) {\n    el.data(type).split(' ').forEach(function (id) {\n      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);\n    });\n  };\n  // Elements with [data-open] will reveal a plugin that supports it when clicked.\n  $(document).on('click.zf.trigger', '[data-open]', function () {\n    triggers($(this), 'open');\n  });\n\n  // Elements with [data-close] will close a plugin that supports it when clicked.\n  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\n  $(document).on('click.zf.trigger', '[data-close]', function () {\n    var id = $(this).data('close');\n    if (id) {\n      triggers($(this), 'close');\n    } else {\n      $(this).trigger('close.zf.trigger');\n    }\n  });\n\n  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.\n  $(document).on('click.zf.trigger', '[data-toggle]', function () {\n    var id = $(this).data('toggle');\n    if (id) {\n      triggers($(this), 'toggle');\n    } else {\n      $(this).trigger('toggle.zf.trigger');\n    }\n  });\n\n  // Elements with [data-closable] will respond to close.zf.trigger events.\n  $(document).on('close.zf.trigger', '[data-closable]', function (e) {\n    e.stopPropagation();\n    var animation = $(this).data('closable');\n\n    if (animation !== '') {\n      Foundation.Motion.animateOut($(this), animation, function () {\n        $(this).trigger('closed.zf');\n      });\n    } else {\n      $(this).fadeOut().trigger('closed.zf');\n    }\n  });\n\n  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {\n    var id = $(this).data('toggle-focus');\n    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);\n  });\n\n  /**\n  * Fires once after all other scripts have loaded\n  * @function\n  * @private\n  */\n  $(window).on('load', function () {\n    checkListeners();\n  });\n\n  function checkListeners() {\n    eventsListener();\n    resizeListener();\n    scrollListener();\n    mutateListener();\n    closemeListener();\n  }\n\n  //******** only fires this function once on load, if there's something to watch ********\n  function closemeListener(pluginName) {\n    var yetiBoxes = $('[data-yeti-box]'),\n        plugNames = ['dropdown', 'tooltip', 'reveal'];\n\n    if (pluginName) {\n      if (typeof pluginName === 'string') {\n        plugNames.push(pluginName);\n      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {\n        plugNames.concat(pluginName);\n      } else {\n        console.error('Plugin names must be strings');\n      }\n    }\n    if (yetiBoxes.length) {\n      var listeners = plugNames.map(function (name) {\n        return 'closeme.zf.' + name;\n      }).join(' ');\n\n      $(window).off(listeners).on(listeners, function (e, pluginId) {\n        var plugin = e.namespace.split('.')[0];\n        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box=\"' + pluginId + '\"]');\n\n        plugins.each(function () {\n          var _this = $(this);\n\n          _this.triggerHandler('close.zf.trigger', [_this]);\n        });\n      });\n    }\n  }\n\n  function resizeListener(debounce) {\n    var timer = void 0,\n        $nodes = $('[data-resize]');\n    if ($nodes.length) {\n      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        timer = setTimeout(function () {\n\n          if (!MutationObserver) {\n            //fallback for IE 9\n            $nodes.each(function () {\n              $(this).triggerHandler('resizeme.zf.trigger');\n            });\n          }\n          //trigger all listening elements and signal a resize event\n          $nodes.attr('data-events', \"resize\");\n        }, debounce || 10); //default time to emit resize event\n      });\n    }\n  }\n\n  function scrollListener(debounce) {\n    var timer = void 0,\n        $nodes = $('[data-scroll]');\n    if ($nodes.length) {\n      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        timer = setTimeout(function () {\n\n          if (!MutationObserver) {\n            //fallback for IE 9\n            $nodes.each(function () {\n              $(this).triggerHandler('scrollme.zf.trigger');\n            });\n          }\n          //trigger all listening elements and signal a scroll event\n          $nodes.attr('data-events', \"scroll\");\n        }, debounce || 10); //default time to emit scroll event\n      });\n    }\n  }\n\n  function mutateListener(debounce) {\n    var $nodes = $('[data-mutate]');\n    if ($nodes.length && MutationObserver) {\n      //trigger all listening elements and signal a mutate event\n      //no IE 9 or 10\n      $nodes.each(function () {\n        $(this).triggerHandler('mutateme.zf.trigger');\n      });\n    }\n  }\n\n  function eventsListener() {\n    if (!MutationObserver) {\n      return false;\n    }\n    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');\n\n    //element callback\n    var listeningElementsMutation = function (mutationRecordsList) {\n      var $target = $(mutationRecordsList[0].target);\n\n      //trigger the event handler for the element depending on type\n      switch (mutationRecordsList[0].type) {\n\n        case \"attributes\":\n          if ($target.attr(\"data-events\") === \"scroll\" && mutationRecordsList[0].attributeName === \"data-events\") {\n            $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\n          }\n          if ($target.attr(\"data-events\") === \"resize\" && mutationRecordsList[0].attributeName === \"data-events\") {\n            $target.triggerHandler('resizeme.zf.trigger', [$target]);\n          }\n          if (mutationRecordsList[0].attributeName === \"style\") {\n            $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n            $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n          }\n          break;\n\n        case \"childList\":\n          $target.closest(\"[data-mutate]\").attr(\"data-events\", \"mutate\");\n          $target.closest(\"[data-mutate]\").triggerHandler('mutateme.zf.trigger', [$target.closest(\"[data-mutate]\")]);\n          break;\n\n        default:\n          return false;\n        //nothing\n      }\n    };\n\n    if (nodes.length) {\n      //for each element that needs to listen for resizing, scrolling, or mutation add a single observer\n      for (var i = 0; i <= nodes.length - 1; i++) {\n        var elementObserver = new MutationObserver(listeningElementsMutation);\n        elementObserver.observe(nodes[i], { attributes: true, childList: true, characterData: false, subtree: true, attributeFilter: [\"data-events\", \"style\"] });\n      }\n    }\n  }\n\n  // ------------------------------------\n\n  // [PH]\n  // Foundation.CheckWatchers = checkWatchers;\n  Foundation.IHearYou = checkListeners;\n  // Foundation.ISeeYou = scrollListener;\n  // Foundation.IFeelYou = closemeListener;\n}(jQuery);\n\n// function domMutationObserver(debounce) {\n//   // !!! This is coming soon and needs more work; not active  !!! //\n//   var timer,\n//   nodes = document.querySelectorAll('[data-mutate]');\n//   //\n//   if (nodes.length) {\n//     // var MutationObserver = (function () {\n//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\n//     //   for (var i=0; i < prefixes.length; i++) {\n//     //     if (prefixes[i] + 'MutationObserver' in window) {\n//     //       return window[prefixes[i] + 'MutationObserver'];\n//     //     }\n//     //   }\n//     //   return false;\n//     // }());\n//\n//\n//     //for the body, we need to listen for all changes effecting the style and class attributes\n//     var bodyObserver = new MutationObserver(bodyMutation);\n//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:[\"style\", \"class\"]});\n//\n//\n//     //body callback\n//     function bodyMutation(mutate) {\n//       //trigger all listening elements and signal a mutation event\n//       if (timer) { clearTimeout(timer); }\n//\n//       timer = setTimeout(function() {\n//         bodyObserver.disconnect();\n//         $('[data-mutate]').attr('data-events',\"mutate\");\n//       }, debounce || 150);\n//     }\n//   }\n// }//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qcz8xZGQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuIWZ1bmN0aW9uICgkKSB7XG5cbiAgdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZWZpeGVzID0gWydXZWJLaXQnLCAnTW96JywgJ08nLCAnTXMnLCAnJ107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgICByZXR1cm4gd2luZG93W3ByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KCk7XG5cbiAgdmFyIHRyaWdnZXJzID0gZnVuY3Rpb24gKGVsLCB0eXBlKSB7XG4gICAgZWwuZGF0YSh0eXBlKS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAkKCcjJyArIGlkKVt0eXBlID09PSAnY2xvc2UnID8gJ3RyaWdnZXInIDogJ3RyaWdnZXJIYW5kbGVyJ10odHlwZSArICcuemYudHJpZ2dlcicsIFtlbF0pO1xuICAgIH0pO1xuICB9O1xuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLW9wZW5dIHdpbGwgcmV2ZWFsIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1vcGVuXScsIGZ1bmN0aW9uICgpIHtcbiAgICB0cmlnZ2VycygkKHRoaXMpLCAnb3BlbicpO1xuICB9KTtcblxuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuICAvLyBJZiB1c2VkIHdpdGhvdXQgYSB2YWx1ZSBvbiBbZGF0YS1jbG9zZV0sIHRoZSBldmVudCB3aWxsIGJ1YmJsZSwgYWxsb3dpbmcgaXQgdG8gY2xvc2UgYSBwYXJlbnQgY29tcG9uZW50LlxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS1jbG9zZV0nLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xuICAgIGlmIChpZCkge1xuICAgICAgdHJpZ2dlcnMoJCh0aGlzKSwgJ2Nsb3NlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2UuemYudHJpZ2dlcicpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS10b2dnbGVdIHdpbGwgdG9nZ2xlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGVdJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9ICQodGhpcykuZGF0YSgndG9nZ2xlJyk7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0cmlnZ2VycygkKHRoaXMpLCAndG9nZ2xlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcykudHJpZ2dlcigndG9nZ2xlLnpmLnRyaWdnZXInKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cbiAgJChkb2N1bWVudCkub24oJ2Nsb3NlLnpmLnRyaWdnZXInLCAnW2RhdGEtY2xvc2FibGVdJywgZnVuY3Rpb24gKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBhbmltYXRpb24gPSAkKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7XG5cbiAgICBpZiAoYW5pbWF0aW9uICE9PSAnJykge1xuICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKHRoaXMpLmZhZGVPdXQoKS50cmlnZ2VyKCdjbG9zZWQuemYnKTtcbiAgICB9XG4gIH0pO1xuXG4gICQoZG9jdW1lbnQpLm9uKCdmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGUtZm9jdXNdJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9ICQodGhpcykuZGF0YSgndG9nZ2xlLWZvY3VzJyk7XG4gICAgJCgnIycgKyBpZCkudHJpZ2dlckhhbmRsZXIoJ3RvZ2dsZS56Zi50cmlnZ2VyJywgWyQodGhpcyldKTtcbiAgfSk7XG5cbiAgLyoqXG4gICogRmlyZXMgb25jZSBhZnRlciBhbGwgb3RoZXIgc2NyaXB0cyBoYXZlIGxvYWRlZFxuICAqIEBmdW5jdGlvblxuICAqIEBwcml2YXRlXG4gICovXG4gICQod2luZG93KS5vbignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBjaGVja0xpc3RlbmVycygpO1xuICB9KTtcblxuICBmdW5jdGlvbiBjaGVja0xpc3RlbmVycygpIHtcbiAgICBldmVudHNMaXN0ZW5lcigpO1xuICAgIHJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgc2Nyb2xsTGlzdGVuZXIoKTtcbiAgICBtdXRhdGVMaXN0ZW5lcigpO1xuICAgIGNsb3NlbWVMaXN0ZW5lcigpO1xuICB9XG5cbiAgLy8qKioqKioqKiBvbmx5IGZpcmVzIHRoaXMgZnVuY3Rpb24gb25jZSBvbiBsb2FkLCBpZiB0aGVyZSdzIHNvbWV0aGluZyB0byB3YXRjaCAqKioqKioqKlxuICBmdW5jdGlvbiBjbG9zZW1lTGlzdGVuZXIocGx1Z2luTmFtZSkge1xuICAgIHZhciB5ZXRpQm94ZXMgPSAkKCdbZGF0YS15ZXRpLWJveF0nKSxcbiAgICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xuXG4gICAgaWYgKHBsdWdpbk5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGx1Z05hbWVzLnB1c2gocGx1Z2luTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5OYW1lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGx1Z2luTmFtZVswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BsdWdpbiBuYW1lcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHlldGlCb3hlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBwbHVnTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnY2xvc2VtZS56Zi4nICsgbmFtZTtcbiAgICAgIH0pLmpvaW4oJyAnKTtcblxuICAgICAgJCh3aW5kb3cpLm9mZihsaXN0ZW5lcnMpLm9uKGxpc3RlbmVycywgZnVuY3Rpb24gKGUsIHBsdWdpbklkKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBlLm5hbWVzcGFjZS5zcGxpdCgnLicpWzBdO1xuICAgICAgICB2YXIgcGx1Z2lucyA9ICQoJ1tkYXRhLScgKyBwbHVnaW4gKyAnXScpLm5vdCgnW2RhdGEteWV0aS1ib3g9XCInICsgcGx1Z2luSWQgKyAnXCJdJyk7XG5cbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgX3RoaXMudHJpZ2dlckhhbmRsZXIoJ2Nsb3NlLnpmLnRyaWdnZXInLCBbX3RoaXNdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcihkZWJvdW5jZSkge1xuICAgIHZhciB0aW1lciA9IHZvaWQgMCxcbiAgICAgICAgJG5vZGVzID0gJCgnW2RhdGEtcmVzaXplXScpO1xuICAgIGlmICgkbm9kZXMubGVuZ3RoKSB7XG4gICAgICAkKHdpbmRvdykub2ZmKCdyZXNpemUuemYudHJpZ2dlcicpLm9uKCdyZXNpemUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XG4gICAgICAgICAgICAkbm9kZXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3RyaWdnZXIgYWxsIGxpc3RlbmluZyBlbGVtZW50cyBhbmQgc2lnbmFsIGEgcmVzaXplIGV2ZW50XG4gICAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXCJyZXNpemVcIik7XG4gICAgICAgIH0sIGRlYm91bmNlIHx8IDEwKTsgLy9kZWZhdWx0IHRpbWUgdG8gZW1pdCByZXNpemUgZXZlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbExpc3RlbmVyKGRlYm91bmNlKSB7XG4gICAgdmFyIHRpbWVyID0gdm9pZCAwLFxuICAgICAgICAkbm9kZXMgPSAkKCdbZGF0YS1zY3JvbGxdJyk7XG4gICAgaWYgKCRub2Rlcy5sZW5ndGgpIHtcbiAgICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi50cmlnZ2VyJykub24oJ3Njcm9sbC56Zi50cmlnZ2VyJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIC8vZmFsbGJhY2sgZm9yIElFIDlcbiAgICAgICAgICAgICRub2Rlcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcbiAgICAgICAgICAkbm9kZXMuYXR0cignZGF0YS1ldmVudHMnLCBcInNjcm9sbFwiKTtcbiAgICAgICAgfSwgZGVib3VuY2UgfHwgMTApOyAvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbXV0YXRlTGlzdGVuZXIoZGVib3VuY2UpIHtcbiAgICB2YXIgJG5vZGVzID0gJCgnW2RhdGEtbXV0YXRlXScpO1xuICAgIGlmICgkbm9kZXMubGVuZ3RoICYmIE11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBtdXRhdGUgZXZlbnRcbiAgICAgIC8vbm8gSUUgOSBvciAxMFxuICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdtdXRhdGVtZS56Zi50cmlnZ2VyJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHNMaXN0ZW5lcigpIHtcbiAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcmVzaXplXSwgW2RhdGEtc2Nyb2xsXSwgW2RhdGEtbXV0YXRlXScpO1xuXG4gICAgLy9lbGVtZW50IGNhbGxiYWNrXG4gICAgdmFyIGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24gPSBmdW5jdGlvbiAobXV0YXRpb25SZWNvcmRzTGlzdCkge1xuICAgICAgdmFyICR0YXJnZXQgPSAkKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0udGFyZ2V0KTtcblxuICAgICAgLy90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxuICAgICAgc3dpdGNoIChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnR5cGUpIHtcblxuICAgICAgICBjYXNlIFwiYXR0cmlidXRlc1wiOlxuICAgICAgICAgIGlmICgkdGFyZ2V0LmF0dHIoXCJkYXRhLWV2ZW50c1wiKSA9PT0gXCJzY3JvbGxcIiAmJiBtdXRhdGlvblJlY29yZHNMaXN0WzBdLmF0dHJpYnV0ZU5hbWUgPT09IFwiZGF0YS1ldmVudHNcIikge1xuICAgICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LCB3aW5kb3cucGFnZVlPZmZzZXRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCR0YXJnZXQuYXR0cihcImRhdGEtZXZlbnRzXCIpID09PSBcInJlc2l6ZVwiICYmIG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXCJkYXRhLWV2ZW50c1wiKSB7XG4gICAgICAgICAgICAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJywgWyR0YXJnZXRdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG11dGF0aW9uUmVjb3Jkc0xpc3RbMF0uYXR0cmlidXRlTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgICAgICAkdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpLmF0dHIoXCJkYXRhLWV2ZW50c1wiLCBcIm11dGF0ZVwiKTtcbiAgICAgICAgICAgICR0YXJnZXQuY2xvc2VzdChcIltkYXRhLW11dGF0ZV1cIikudHJpZ2dlckhhbmRsZXIoJ211dGF0ZW1lLnpmLnRyaWdnZXInLCBbJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiY2hpbGRMaXN0XCI6XG4gICAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS5hdHRyKFwiZGF0YS1ldmVudHNcIiwgXCJtdXRhdGVcIik7XG4gICAgICAgICAgJHRhcmdldC5jbG9zZXN0KFwiW2RhdGEtbXV0YXRlXVwiKS50cmlnZ2VySGFuZGxlcignbXV0YXRlbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LmNsb3Nlc3QoXCJbZGF0YS1tdXRhdGVdXCIpXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vbm90aGluZ1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIG9yIG11dGF0aW9uIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uKTtcbiAgICAgICAgZWxlbWVudE9ic2VydmVyLm9ic2VydmUobm9kZXNbaV0sIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbXCJkYXRhLWV2ZW50c1wiLCBcInN0eWxlXCJdIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFtQSF1cbiAgLy8gRm91bmRhdGlvbi5DaGVja1dhdGNoZXJzID0gY2hlY2tXYXRjaGVycztcbiAgRm91bmRhdGlvbi5JSGVhcllvdSA9IGNoZWNrTGlzdGVuZXJzO1xuICAvLyBGb3VuZGF0aW9uLklTZWVZb3UgPSBzY3JvbGxMaXN0ZW5lcjtcbiAgLy8gRm91bmRhdGlvbi5JRmVlbFlvdSA9IGNsb3NlbWVMaXN0ZW5lcjtcbn0oalF1ZXJ5KTtcblxuLy8gZnVuY3Rpb24gZG9tTXV0YXRpb25PYnNlcnZlcihkZWJvdW5jZSkge1xuLy8gICAvLyAhISEgVGhpcyBpcyBjb21pbmcgc29vbiBhbmQgbmVlZHMgbW9yZSB3b3JrOyBub3QgYWN0aXZlICAhISEgLy9cbi8vICAgdmFyIHRpbWVyLFxuLy8gICBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW11dGF0ZV0nKTtcbi8vICAgLy9cbi8vICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuLy8gICAgIC8vIHZhciBNdXRhdGlvbk9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbi8vICAgICAvLyAgIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xuLy8gICAgIC8vICAgZm9yICh2YXIgaT0wOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbi8vICAgICAvLyAgICAgaWYgKHByZWZpeGVzW2ldICsgJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuLy8gICAgIC8vICAgICAgIHJldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlciddO1xuLy8gICAgIC8vICAgICB9XG4vLyAgICAgLy8gICB9XG4vLyAgICAgLy8gICByZXR1cm4gZmFsc2U7XG4vLyAgICAgLy8gfSgpKTtcbi8vXG4vL1xuLy8gICAgIC8vZm9yIHRoZSBib2R5LCB3ZSBuZWVkIHRvIGxpc3RlbiBmb3IgYWxsIGNoYW5nZXMgZWZmZWN0aW5nIHRoZSBzdHlsZSBhbmQgY2xhc3MgYXR0cmlidXRlc1xuLy8gICAgIHZhciBib2R5T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihib2R5TXV0YXRpb24pO1xuLy8gICAgIGJvZHlPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTp0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6W1wic3R5bGVcIiwgXCJjbGFzc1wiXX0pO1xuLy9cbi8vXG4vLyAgICAgLy9ib2R5IGNhbGxiYWNrXG4vLyAgICAgZnVuY3Rpb24gYm9keU11dGF0aW9uKG11dGF0ZSkge1xuLy8gICAgICAgLy90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIG11dGF0aW9uIGV2ZW50XG4vLyAgICAgICBpZiAodGltZXIpIHsgY2xlYXJUaW1lb3V0KHRpbWVyKTsgfVxuLy9cbi8vICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgICAgICAgYm9keU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbi8vICAgICAgICAgJCgnW2RhdGEtbXV0YXRlXScpLmF0dHIoJ2RhdGEtZXZlbnRzJyxcIm11dGF0ZVwiKTtcbi8vICAgICAgIH0sIGRlYm91bmNlIHx8IDE1MCk7XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50cmlnZ2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 28 */
/***/ function(module, exports) {

"use strict";
eval("'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n!function ($) {\n\n  /**\n   * ResponsiveAccordionTabs module.\n   * @module foundation.responsiveAccordionTabs\n   * @requires foundation.util.keyboard\n   * @requires foundation.util.timerAndImageLoader\n   * @requires foundation.util.motion\n   * @requires foundation.accordion\n   * @requires foundation.tabs\n   */\n\n  var ResponsiveAccordionTabs = function () {\n    /**\n     * Creates a new instance of a responsive accordion tabs.\n     * @class\n     * @fires ResponsiveAccordionTabs#init\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\n     * @param {Object} options - Overrides to the default plugin settings.\n     */\n    function ResponsiveAccordionTabs(element, options) {\n      _classCallCheck(this, ResponsiveAccordionTabs);\n\n      this.$element = $(element);\n      this.options = $.extend({}, this.$element.data(), options);\n      this.rules = this.$element.data('responsive-accordion-tabs');\n      this.currentMq = null;\n      this.currentPlugin = null;\n      if (!this.$element.attr('id')) {\n        this.$element.attr('id', Foundation.GetYoDigits(6, 'responsiveaccordiontabs'));\n      };\n\n      this._init();\n      this._events();\n\n      Foundation.registerPlugin(this, 'ResponsiveAccordionTabs');\n    }\n\n    /**\n     * Initializes the Menu by parsing the classes from the 'data-responsive-accordion-tabs' attribute on the element.\n     * @function\n     * @private\n     */\n\n\n    _createClass(ResponsiveAccordionTabs, [{\n      key: '_init',\n      value: function _init() {\n        // The first time an Interchange plugin is initialized, this.rules is converted from a string of \"classes\" to an object of rules\n        if (typeof this.rules === 'string') {\n          var rulesTree = {};\n\n          // Parse rules from \"classes\" pulled from data attribute\n          var rules = this.rules.split(' ');\n\n          // Iterate through every rule found\n          for (var i = 0; i < rules.length; i++) {\n            var rule = rules[i].split('-');\n            var ruleSize = rule.length > 1 ? rule[0] : 'small';\n            var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\n\n            if (MenuPlugins[rulePlugin] !== null) {\n              rulesTree[ruleSize] = MenuPlugins[rulePlugin];\n            }\n          }\n\n          this.rules = rulesTree;\n        }\n\n        this._getAllOptions();\n\n        if (!$.isEmptyObject(this.rules)) {\n          this._checkMediaQueries();\n        }\n      }\n    }, {\n      key: '_getAllOptions',\n      value: function _getAllOptions() {\n        //get all defaults and options\n        var _this = this;\n        _this.allOptions = {};\n        for (var key in MenuPlugins) {\n          if (MenuPlugins.hasOwnProperty(key)) {\n            var obj = MenuPlugins[key];\n            try {\n              var dummyPlugin = $('<ul></ul>');\n              var tmpPlugin = new obj.plugin(dummyPlugin, _this.options);\n              for (var keyKey in tmpPlugin.options) {\n                if (tmpPlugin.options.hasOwnProperty(keyKey) && keyKey !== 'zfPlugin') {\n                  var objObj = tmpPlugin.options[keyKey];\n                  _this.allOptions[keyKey] = objObj;\n                }\n              }\n              tmpPlugin.destroy();\n            } catch (e) {}\n          }\n        }\n      }\n\n      /**\n       * Initializes events for the Menu.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_events',\n      value: function _events() {\n        var _this = this;\n\n        $(window).on('changed.zf.mediaquery', function () {\n          _this._checkMediaQueries();\n        });\n      }\n\n      /**\n       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\n       * @function\n       * @private\n       */\n\n    }, {\n      key: '_checkMediaQueries',\n      value: function _checkMediaQueries() {\n        var matchedMq,\n            _this = this;\n        // Iterate through each rule and find the last matching rule\n        $.each(this.rules, function (key) {\n          if (Foundation.MediaQuery.atLeast(key)) {\n            matchedMq = key;\n          }\n        });\n\n        // No match? No dice\n        if (!matchedMq) return;\n\n        // Plugin already initialized? We good\n        if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;\n\n        // Remove existing plugin-specific CSS classes\n        $.each(MenuPlugins, function (key, value) {\n          _this.$element.removeClass(value.cssClass);\n        });\n\n        // Add the CSS class for the new plugin\n        this.$element.addClass(this.rules[matchedMq].cssClass);\n\n        // Create an instance of the new plugin\n        if (this.currentPlugin) {\n          //don't know why but on nested elements data zfPlugin get's lost\n          if (!this.currentPlugin.$element.data('zfPlugin') && this.storezfData) this.currentPlugin.$element.data('zfPlugin', this.storezfData);\n          this.currentPlugin.destroy();\n        }\n        this._handleMarkup(this.rules[matchedMq].cssClass);\n        this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\n        this.storezfData = this.currentPlugin.$element.data('zfPlugin');\n      }\n    }, {\n      key: '_handleMarkup',\n      value: function _handleMarkup(toSet) {\n        var _this = this,\n            fromString = 'accordion';\n        var $panels = $('[data-tabs-content=' + this.$element.attr('id') + ']');\n        if ($panels.length) fromString = 'tabs';\n        if (fromString === toSet) {\n          return;\n        };\n\n        var tabsTitle = _this.allOptions.linkClass ? _this.allOptions.linkClass : 'tabs-title';\n        var tabsPanel = _this.allOptions.panelClass ? _this.allOptions.panelClass : 'tabs-panel';\n\n        this.$element.removeAttr('role');\n        var $liHeads = this.$element.children('.' + tabsTitle + ',[data-accordion-item]').removeClass(tabsTitle).removeClass('accordion-item').removeAttr('data-accordion-item');\n        var $liHeadsA = $liHeads.children('a').removeClass('accordion-title');\n\n        if (fromString === 'tabs') {\n          $panels = $panels.children('.' + tabsPanel).removeClass(tabsPanel).removeAttr('role').removeAttr('aria-hidden').removeAttr('aria-labelledby');\n          $panels.children('a').removeAttr('role').removeAttr('aria-controls').removeAttr('aria-selected');\n        } else {\n          $panels = $liHeads.children('[data-tab-content]').removeClass('accordion-content');\n        };\n\n        $panels.css({ display: '', visibility: '' });\n        $liHeads.css({ display: '', visibility: '' });\n        if (toSet === 'accordion') {\n          $panels.each(function (key, value) {\n            $(value).appendTo($liHeads.get(key)).addClass('accordion-content').attr('data-tab-content', '').removeClass('is-active').css({ height: '' });\n            $('[data-tabs-content=' + _this.$element.attr('id') + ']').after('<div id=\"tabs-placeholder-' + _this.$element.attr('id') + '\"></div>').remove();\n            $liHeads.addClass('accordion-item').attr('data-accordion-item', '');\n            $liHeadsA.addClass('accordion-title');\n          });\n        } else if (toSet === 'tabs') {\n          var $tabsContent = $('[data-tabs-content=' + _this.$element.attr('id') + ']');\n          var $placeholder = $('#tabs-placeholder-' + _this.$element.attr('id'));\n          if ($placeholder.length) {\n            $tabsContent = $('<div class=\"tabs-content\"></div>').insertAfter($placeholder).attr('data-tabs-content', _this.$element.attr('id'));\n            $placeholder.remove();\n          } else {\n            $tabsContent = $('<div class=\"tabs-content\"></div>').insertAfter(_this.$element).attr('data-tabs-content', _this.$element.attr('id'));\n          };\n          $panels.each(function (key, value) {\n            var tempValue = $(value).appendTo($tabsContent).addClass(tabsPanel);\n            var hash = $liHeadsA.get(key).hash.slice(1);\n            var id = $(value).attr('id') || Foundation.GetYoDigits(6, 'accordion');\n            if (hash !== id) {\n              if (hash !== '') {\n                $(value).attr('id', hash);\n              } else {\n                hash = id;\n                $(value).attr('id', hash);\n                $($liHeadsA.get(key)).attr('href', $($liHeadsA.get(key)).attr('href').replace('#', '') + '#' + hash);\n              };\n            };\n            var isActive = $($liHeads.get(key)).hasClass('is-active');\n            if (isActive) {\n              tempValue.addClass('is-active');\n            };\n          });\n          $liHeads.addClass(tabsTitle);\n        };\n      }\n\n      /**\n       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\n       * @function\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        if (this.currentPlugin) this.currentPlugin.destroy();\n        $(window).off('.zf.ResponsiveAccordionTabs');\n        Foundation.unregisterPlugin(this);\n      }\n    }]);\n\n    return ResponsiveAccordionTabs;\n  }();\n\n  ResponsiveAccordionTabs.defaults = {};\n\n  // The plugin matches the plugin classes with these plugin instances.\n  var MenuPlugins = {\n    tabs: {\n      cssClass: 'tabs',\n      plugin: Foundation._plugins.tabs || null\n    },\n    accordion: {\n      cssClass: 'accordion',\n      plugin: Foundation._plugins.accordion || null\n    }\n  };\n\n  // Window exports\n  Foundation.plugin(ResponsiveAccordionTabs, 'ResponsiveAccordionTabs');\n}(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uemYucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMuanM/MDYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiFmdW5jdGlvbiAoJCkge1xuXG4gIC8qKlxuICAgKiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicyBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlQWNjb3JkaW9uVGFic1xuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi5hY2NvcmRpb25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udGFic1xuICAgKi9cblxuICB2YXIgUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHJlc3BvbnNpdmUgYWNjb3JkaW9uIHRhYnMuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzKTtcblxuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycpO1xuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpKSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignaWQnLCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdyZXNwb25zaXZlYWNjb3JkaW9udGFicycpKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2luaXQoKTtcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xuXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtcmVzcG9uc2l2ZS1hY2NvcmRpb24tdGFicycgYXR0cmlidXRlIG9uIHRoZSBlbGVtZW50LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlQWNjb3JkaW9uVGFicywgW3tcbiAgICAgIGtleTogJ19pbml0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgYW4gSW50ZXJjaGFuZ2UgcGx1Z2luIGlzIGluaXRpYWxpemVkLCB0aGlzLnJ1bGVzIGlzIGNvbnZlcnRlZCBmcm9tIGEgc3RyaW5nIG9mIFwiY2xhc3Nlc1wiIHRvIGFuIG9iamVjdCBvZiBydWxlc1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHJ1bGVzVHJlZSA9IHt9O1xuXG4gICAgICAgICAgLy8gUGFyc2UgcnVsZXMgZnJvbSBcImNsYXNzZXNcIiBwdWxsZWQgZnJvbSBkYXRhIGF0dHJpYnV0ZVxuICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMucnVsZXMuc3BsaXQoJyAnKTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBydWxlIGZvdW5kXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgdmFyIHJ1bGVTaXplID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVswXSA6ICdzbWFsbCc7XG4gICAgICAgICAgICB2YXIgcnVsZVBsdWdpbiA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMV0gOiBydWxlWzBdO1xuXG4gICAgICAgICAgICBpZiAoTWVudVBsdWdpbnNbcnVsZVBsdWdpbl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcnVsZXNUcmVlW3J1bGVTaXplXSA9IE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9nZXRBbGxPcHRpb25zKCk7XG5cbiAgICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcykpIHtcbiAgICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2dldEFsbE9wdGlvbnMnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxPcHRpb25zKCkge1xuICAgICAgICAvL2dldCBhbGwgZGVmYXVsdHMgYW5kIG9wdGlvbnNcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3RoaXMuYWxsT3B0aW9ucyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gTWVudVBsdWdpbnMpIHtcbiAgICAgICAgICBpZiAoTWVudVBsdWdpbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIG9iaiA9IE1lbnVQbHVnaW5zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgZHVtbXlQbHVnaW4gPSAkKCc8dWw+PC91bD4nKTtcbiAgICAgICAgICAgICAgdmFyIHRtcFBsdWdpbiA9IG5ldyBvYmoucGx1Z2luKGR1bW15UGx1Z2luLCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5S2V5IGluIHRtcFBsdWdpbi5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRtcFBsdWdpbi5vcHRpb25zLmhhc093blByb3BlcnR5KGtleUtleSkgJiYga2V5S2V5ICE9PSAnemZQbHVnaW4nKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2JqT2JqID0gdG1wUGx1Z2luLm9wdGlvbnNba2V5S2V5XTtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmFsbE9wdGlvbnNba2V5S2V5XSA9IG9iak9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG1wUGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2V2ZW50cycsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IHNjcmVlbiB3aWR0aCBhZ2FpbnN0IGF2YWlsYWJsZSBtZWRpYSBxdWVyaWVzLiBJZiB0aGUgbWVkaWEgcXVlcnkgaGFzIGNoYW5nZWQsIGFuZCB0aGUgcGx1Z2luIG5lZWRlZCBoYXMgY2hhbmdlZCwgdGhlIHBsdWdpbnMgd2lsbCBzd2FwIG91dC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAga2V5OiAnX2NoZWNrTWVkaWFRdWVyaWVzJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tNZWRpYVF1ZXJpZXMoKSB7XG4gICAgICAgIHZhciBtYXRjaGVkTXEsXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUgYW5kIGZpbmQgdGhlIGxhc3QgbWF0Y2hpbmcgcnVsZVxuICAgICAgICAkLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChrZXkpKSB7XG4gICAgICAgICAgICBtYXRjaGVkTXEgPSBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBObyBtYXRjaD8gTm8gZGljZVxuICAgICAgICBpZiAoIW1hdGNoZWRNcSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKSByZXR1cm47XG5cbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xuICAgICAgICAkLmVhY2goTWVudVBsdWdpbnMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModmFsdWUuY3NzQ2xhc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIENTUyBjbGFzcyBmb3IgdGhlIG5ldyBwbHVnaW5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGUgbmV3IHBsdWdpblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB7XG4gICAgICAgICAgLy9kb24ndCBrbm93IHdoeSBidXQgb24gbmVzdGVkIGVsZW1lbnRzIGRhdGEgemZQbHVnaW4gZ2V0J3MgbG9zdFxuICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykgJiYgdGhpcy5zdG9yZXpmRGF0YSkgdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJywgdGhpcy5zdG9yZXpmRGF0YSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oYW5kbGVNYXJrdXAodGhpcy5ydWxlc1ttYXRjaGVkTXFdLmNzc0NsYXNzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCwge30pO1xuICAgICAgICB0aGlzLnN0b3JlemZEYXRhID0gdGhpcy5jdXJyZW50UGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZU1hcmt1cCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU1hcmt1cCh0b1NldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICAgICAgZnJvbVN0cmluZyA9ICdhY2NvcmRpb24nO1xuICAgICAgICB2YXIgJHBhbmVscyA9ICQoJ1tkYXRhLXRhYnMtY29udGVudD0nICsgdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKTtcbiAgICAgICAgaWYgKCRwYW5lbHMubGVuZ3RoKSBmcm9tU3RyaW5nID0gJ3RhYnMnO1xuICAgICAgICBpZiAoZnJvbVN0cmluZyA9PT0gdG9TZXQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHRhYnNUaXRsZSA9IF90aGlzLmFsbE9wdGlvbnMubGlua0NsYXNzID8gX3RoaXMuYWxsT3B0aW9ucy5saW5rQ2xhc3MgOiAndGFicy10aXRsZSc7XG4gICAgICAgIHZhciB0YWJzUGFuZWwgPSBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgPyBfdGhpcy5hbGxPcHRpb25zLnBhbmVsQ2xhc3MgOiAndGFicy1wYW5lbCc7XG5cbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVBdHRyKCdyb2xlJyk7XG4gICAgICAgIHZhciAkbGlIZWFkcyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy4nICsgdGFic1RpdGxlICsgJyxbZGF0YS1hY2NvcmRpb24taXRlbV0nKS5yZW1vdmVDbGFzcyh0YWJzVGl0bGUpLnJlbW92ZUNsYXNzKCdhY2NvcmRpb24taXRlbScpLnJlbW92ZUF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nKTtcbiAgICAgICAgdmFyICRsaUhlYWRzQSA9ICRsaUhlYWRzLmNoaWxkcmVuKCdhJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi10aXRsZScpO1xuXG4gICAgICAgIGlmIChmcm9tU3RyaW5nID09PSAndGFicycpIHtcbiAgICAgICAgICAkcGFuZWxzID0gJHBhbmVscy5jaGlsZHJlbignLicgKyB0YWJzUGFuZWwpLnJlbW92ZUNsYXNzKHRhYnNQYW5lbCkucmVtb3ZlQXR0cigncm9sZScpLnJlbW92ZUF0dHIoJ2FyaWEtaGlkZGVuJykucmVtb3ZlQXR0cignYXJpYS1sYWJlbGxlZGJ5Jyk7XG4gICAgICAgICAgJHBhbmVscy5jaGlsZHJlbignYScpLnJlbW92ZUF0dHIoJ3JvbGUnKS5yZW1vdmVBdHRyKCdhcmlhLWNvbnRyb2xzJykucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRwYW5lbHMgPSAkbGlIZWFkcy5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJykucmVtb3ZlQ2xhc3MoJ2FjY29yZGlvbi1jb250ZW50Jyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgJHBhbmVscy5jc3MoeyBkaXNwbGF5OiAnJywgdmlzaWJpbGl0eTogJycgfSk7XG4gICAgICAgICRsaUhlYWRzLmNzcyh7IGRpc3BsYXk6ICcnLCB2aXNpYmlsaXR5OiAnJyB9KTtcbiAgICAgICAgaWYgKHRvU2V0ID09PSAnYWNjb3JkaW9uJykge1xuICAgICAgICAgICRwYW5lbHMuZWFjaChmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgJCh2YWx1ZSkuYXBwZW5kVG8oJGxpSGVhZHMuZ2V0KGtleSkpLmFkZENsYXNzKCdhY2NvcmRpb24tY29udGVudCcpLmF0dHIoJ2RhdGEtdGFiLWNvbnRlbnQnLCAnJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmNzcyh7IGhlaWdodDogJycgfSk7XG4gICAgICAgICAgICAkKCdbZGF0YS10YWJzLWNvbnRlbnQ9JyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykgKyAnXScpLmFmdGVyKCc8ZGl2IGlkPVwidGFicy1wbGFjZWhvbGRlci0nICsgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSArICdcIj48L2Rpdj4nKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICRsaUhlYWRzLmFkZENsYXNzKCdhY2NvcmRpb24taXRlbScpLmF0dHIoJ2RhdGEtYWNjb3JkaW9uLWl0ZW0nLCAnJyk7XG4gICAgICAgICAgICAkbGlIZWFkc0EuYWRkQ2xhc3MoJ2FjY29yZGlvbi10aXRsZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU2V0ID09PSAndGFicycpIHtcbiAgICAgICAgICB2YXIgJHRhYnNDb250ZW50ID0gJCgnW2RhdGEtdGFicy1jb250ZW50PScgKyBfdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpICsgJ10nKTtcbiAgICAgICAgICB2YXIgJHBsYWNlaG9sZGVyID0gJCgnI3RhYnMtcGxhY2Vob2xkZXItJyArIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgICAgICAgIGlmICgkcGxhY2Vob2xkZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAkdGFic0NvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwidGFicy1jb250ZW50XCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoJHBsYWNlaG9sZGVyKS5hdHRyKCdkYXRhLXRhYnMtY29udGVudCcsIF90aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xuICAgICAgICAgICAgJHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkdGFic0NvbnRlbnQgPSAkKCc8ZGl2IGNsYXNzPVwidGFicy1jb250ZW50XCI+PC9kaXY+JykuaW5zZXJ0QWZ0ZXIoX3RoaXMuJGVsZW1lbnQpLmF0dHIoJ2RhdGEtdGFicy1jb250ZW50JywgX3RoaXMuJGVsZW1lbnQuYXR0cignaWQnKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAkcGFuZWxzLmVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wVmFsdWUgPSAkKHZhbHVlKS5hcHBlbmRUbygkdGFic0NvbnRlbnQpLmFkZENsYXNzKHRhYnNQYW5lbCk7XG4gICAgICAgICAgICB2YXIgaGFzaCA9ICRsaUhlYWRzQS5nZXQoa2V5KS5oYXNoLnNsaWNlKDEpO1xuICAgICAgICAgICAgdmFyIGlkID0gJCh2YWx1ZSkuYXR0cignaWQnKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2NvcmRpb24nKTtcbiAgICAgICAgICAgIGlmIChoYXNoICE9PSBpZCkge1xuICAgICAgICAgICAgICBpZiAoaGFzaCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAkKHZhbHVlKS5hdHRyKCdpZCcsIGhhc2gpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhc2ggPSBpZDtcbiAgICAgICAgICAgICAgICAkKHZhbHVlKS5hdHRyKCdpZCcsIGhhc2gpO1xuICAgICAgICAgICAgICAgICQoJGxpSGVhZHNBLmdldChrZXkpKS5hdHRyKCdocmVmJywgJCgkbGlIZWFkc0EuZ2V0KGtleSkpLmF0dHIoJ2hyZWYnKS5yZXBsYWNlKCcjJywgJycpICsgJyMnICsgaGFzaCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlzQWN0aXZlID0gJCgkbGlIZWFkcy5nZXQoa2V5KSkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgIHRlbXBWYWx1ZS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICRsaUhlYWRzLmFkZENsYXNzKHRhYnNUaXRsZSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICBrZXk6ICdkZXN0cm95JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xuICAgICAgICAkKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMnKTtcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBSZXNwb25zaXZlQWNjb3JkaW9uVGFicztcbiAgfSgpO1xuXG4gIFJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLmRlZmF1bHRzID0ge307XG5cbiAgLy8gVGhlIHBsdWdpbiBtYXRjaGVzIHRoZSBwbHVnaW4gY2xhc3NlcyB3aXRoIHRoZXNlIHBsdWdpbiBpbnN0YW5jZXMuXG4gIHZhciBNZW51UGx1Z2lucyA9IHtcbiAgICB0YWJzOiB7XG4gICAgICBjc3NDbGFzczogJ3RhYnMnLFxuICAgICAgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zLnRhYnMgfHwgbnVsbFxuICAgIH0sXG4gICAgYWNjb3JkaW9uOiB7XG4gICAgICBjc3NDbGFzczogJ2FjY29yZGlvbicsXG4gICAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnMuYWNjb3JkaW9uIHx8IG51bGxcbiAgICB9XG4gIH07XG5cbiAgLy8gV2luZG93IGV4cG9ydHNcbiAgRm91bmRhdGlvbi5wbHVnaW4oUmVzcG9uc2l2ZUFjY29yZGlvblRhYnMsICdSZXNwb25zaXZlQWNjb3JkaW9uVGFicycpO1xufShqUXVlcnkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnpmLnJlc3BvbnNpdmVBY2NvcmRpb25UYWJzLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

eval("/**\n * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).\n * @version v4.1.1\n * @link https://github.com/ten1seven/what-input\n * @license MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"whatInput\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"whatInput\"] = factory();\n\telse\n\t\troot[\"whatInput\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = function () {\n\t  /*\n\t   * variables\n\t   */\n\n\t  // cache document.documentElement\n\t  var docElem = document.documentElement;\n\n\t  // last used input type\n\t  var currentInput = 'initial';\n\n\t  // last used input intent\n\t  var currentIntent = null;\n\n\t  // form input types\n\t  var formInputs = ['input', 'select', 'textarea'];\n\n\t  // list of modifier keys commonly used with the mouse and\n\t  // can be safely ignored to prevent false keyboard detection\n\t  var ignoreMap = [16, // shift\n\t  17, // control\n\t  18, // alt\n\t  91, // Windows key / left Apple cmd\n\t  93 // Windows menu / right Apple cmd\n\t  ];\n\n\t  // mapping of events to input types\n\t  var inputMap = {\n\t    'keyup': 'keyboard',\n\t    'mousedown': 'mouse',\n\t    'mousemove': 'mouse',\n\t    'MSPointerDown': 'pointer',\n\t    'MSPointerMove': 'pointer',\n\t    'pointerdown': 'pointer',\n\t    'pointermove': 'pointer',\n\t    'touchstart': 'touch'\n\t  };\n\n\t  // array of all used input types\n\t  var inputTypes = [];\n\n\t  // boolean: true if touch buffer is active\n\t  var isBuffering = false;\n\n\t  // boolean: true if the page is being scrolled\n\t  var isScrolling = false;\n\n\t  // store current mouse position\n\t  var mousePos = {\n\t    'x': null,\n\t    'y': null\n\t  };\n\n\t  // map of IE 10 pointer events\n\t  var pointerMap = {\n\t    2: 'touch',\n\t    3: 'touch', // treat pen like touch\n\t    4: 'mouse'\n\t  };\n\n\t  /*\n\t   * set up\n\t   */\n\n\t  var setUp = function setUp() {\n\t    // add correct mouse wheel event mapping to `inputMap`\n\t    inputMap[detectWheel()] = 'mouse';\n\n\t    addListeners();\n\t    setInput();\n\t  };\n\n\t  /*\n\t   * events\n\t   */\n\n\t  var addListeners = function addListeners() {\n\t    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding\n\t    // can only demonstrate potential, but not actual, interaction\n\t    // and are treated separately\n\n\t    // pointer events (mouse, pen, touch)\n\t    if (window.PointerEvent) {\n\t      docElem.addEventListener('pointerdown', updateInput);\n\t      docElem.addEventListener('pointermove', setIntent);\n\t    } else if (window.MSPointerEvent) {\n\t      docElem.addEventListener('MSPointerDown', updateInput);\n\t      docElem.addEventListener('MSPointerMove', setIntent);\n\t    } else {\n\t      // mouse events\n\t      docElem.addEventListener('mousedown', updateInput);\n\t      docElem.addEventListener('mousemove', setIntent);\n\n\t      // touch events\n\t      if ('ontouchstart' in window) {\n\t        docElem.addEventListener('touchstart', touchBuffer);\n\t        docElem.addEventListener('touchend', touchBuffer);\n\t      }\n\t    }\n\n\t    // mouse wheel\n\t    docElem.addEventListener(detectWheel(), setIntent);\n\n\t    // keyboard events\n\t    docElem.addEventListener('keydown', updateInput);\n\t    docElem.addEventListener('keyup', updateInput);\n\t  };\n\n\t  // checks conditions before updating new input\n\t  var updateInput = function updateInput(event) {\n\t    // only execute if the touch buffer timer isn't running\n\t    if (!isBuffering) {\n\t      var eventKey = event.which;\n\t      var value = inputMap[event.type];\n\t      if (value === 'pointer') value = pointerType(event);\n\n\t      if (currentInput !== value || currentIntent !== value) {\n\t        var activeElem = document.activeElement;\n\t        var activeInput = false;\n\n\t        if (activeElem && activeElem.nodeName && formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1) {\n\t          activeInput = true;\n\t        }\n\n\t        if (value === 'touch' ||\n\n\t        // ignore mouse modifier keys\n\t        value === 'mouse' && ignoreMap.indexOf(eventKey) === -1 ||\n\n\t        // don't switch if the current element is a form input\n\t        value === 'keyboard' && activeInput) {\n\t          // set the current and catch-all variable\n\t          currentInput = currentIntent = value;\n\n\t          setInput();\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  // updates the doc and `inputTypes` array with new input\n\t  var setInput = function setInput() {\n\t    docElem.setAttribute('data-whatinput', currentInput);\n\t    docElem.setAttribute('data-whatintent', currentInput);\n\n\t    if (inputTypes.indexOf(currentInput) === -1) {\n\t      inputTypes.push(currentInput);\n\t      docElem.className += ' whatinput-types-' + currentInput;\n\t    }\n\t  };\n\n\t  // updates input intent for `mousemove` and `pointermove`\n\t  var setIntent = function setIntent(event) {\n\t    // test to see if `mousemove` happened relative to the screen\n\t    // to detect scrolling versus mousemove\n\t    if (mousePos['x'] !== event.screenX || mousePos['y'] !== event.screenY) {\n\t      isScrolling = false;\n\n\t      mousePos['x'] = event.screenX;\n\t      mousePos['y'] = event.screenY;\n\t    } else {\n\t      isScrolling = true;\n\t    }\n\n\t    // only execute if the touch buffer timer isn't running\n\t    // or scrolling isn't happening\n\t    if (!isBuffering && !isScrolling) {\n\t      var value = inputMap[event.type];\n\t      if (value === 'pointer') value = pointerType(event);\n\n\t      if (currentIntent !== value) {\n\t        currentIntent = value;\n\n\t        docElem.setAttribute('data-whatintent', currentIntent);\n\t      }\n\t    }\n\t  };\n\n\t  // buffers touch events because they frequently also fire mouse events\n\t  var touchBuffer = function touchBuffer(event) {\n\t    if (event.type === 'touchstart') {\n\t      isBuffering = false;\n\n\t      // set the current input\n\t      updateInput(event);\n\t    } else {\n\t      isBuffering = true;\n\t    }\n\t  };\n\n\t  /*\n\t   * utilities\n\t   */\n\n\t  var pointerType = function pointerType(event) {\n\t    if (typeof event.pointerType === 'number') {\n\t      return pointerMap[event.pointerType];\n\t    } else {\n\t      // treat pen like touch\n\t      return event.pointerType === 'pen' ? 'touch' : event.pointerType;\n\t    }\n\t  };\n\n\t  // detect version of mouse wheel event to use\n\t  // via https://developer.mozilla.org/en-US/docs/Web/Events/wheel\n\t  var detectWheel = function detectWheel() {\n\t    var wheelType = void 0;\n\n\t    // Modern browsers support \"wheel\"\n\t    if ('onwheel' in document.createElement('div')) {\n\t      wheelType = 'wheel';\n\t    } else {\n\t      // Webkit and IE support at least \"mousewheel\"\n\t      // or assume that remaining browsers are older Firefox\n\t      wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';\n\t    }\n\n\t    return wheelType;\n\t  };\n\n\t  /*\n\t   * init\n\t   */\n\n\t  // don't start script unless browser cuts the mustard\n\t  // (also passes if polyfills are used)\n\t  if ('addEventListener' in window && Array.prototype.indexOf) {\n\t    setUp();\n\t  }\n\n\t  /*\n\t   * api\n\t   */\n\n\t  return {\n\t    // returns string: the current input type\n\t    // opt: 'loose'|'strict'\n\t    // 'strict' (default): returns the same value as the `data-whatinput` attribute\n\t    // 'loose': includes `data-whatintent` value if it's more current than `data-whatinput`\n\t    ask: function ask(opt) {\n\t      return opt === 'loose' ? currentIntent : currentInput;\n\t    },\n\n\t    // returns array: all the detected input types\n\t    types: function types() {\n\t      return inputTypes;\n\t    }\n\t  };\n\t}();\n\n/***/ }\n/******/ ])\n});\n;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3doYXQtaW5wdXQvZGlzdC93aGF0LWlucHV0LmpzPzhlYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB3aGF0LWlucHV0IC0gQSBnbG9iYWwgdXRpbGl0eSBmb3IgdHJhY2tpbmcgdGhlIGN1cnJlbnQgaW5wdXQgbWV0aG9kIChtb3VzZSwga2V5Ym9hcmQgb3IgdG91Y2gpLlxuICogQHZlcnNpb24gdjQuMS4xXG4gKiBAbGluayBodHRwczovL2dpdGh1Yi5jb20vdGVuMXNldmVuL3doYXQtaW5wdXRcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIndoYXRJbnB1dFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJ3aGF0SW5wdXRcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wid2hhdElucHV0XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0ICAvKlxuXHQgICAqIHZhcmlhYmxlc1xuXHQgICAqL1xuXG5cdCAgLy8gY2FjaGUgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG5cdCAgdmFyIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblx0ICAvLyBsYXN0IHVzZWQgaW5wdXQgdHlwZVxuXHQgIHZhciBjdXJyZW50SW5wdXQgPSAnaW5pdGlhbCc7XG5cblx0ICAvLyBsYXN0IHVzZWQgaW5wdXQgaW50ZW50XG5cdCAgdmFyIGN1cnJlbnRJbnRlbnQgPSBudWxsO1xuXG5cdCAgLy8gZm9ybSBpbnB1dCB0eXBlc1xuXHQgIHZhciBmb3JtSW5wdXRzID0gWydpbnB1dCcsICdzZWxlY3QnLCAndGV4dGFyZWEnXTtcblxuXHQgIC8vIGxpc3Qgb2YgbW9kaWZpZXIga2V5cyBjb21tb25seSB1c2VkIHdpdGggdGhlIG1vdXNlIGFuZFxuXHQgIC8vIGNhbiBiZSBzYWZlbHkgaWdub3JlZCB0byBwcmV2ZW50IGZhbHNlIGtleWJvYXJkIGRldGVjdGlvblxuXHQgIHZhciBpZ25vcmVNYXAgPSBbMTYsIC8vIHNoaWZ0XG5cdCAgMTcsIC8vIGNvbnRyb2xcblx0ICAxOCwgLy8gYWx0XG5cdCAgOTEsIC8vIFdpbmRvd3Mga2V5IC8gbGVmdCBBcHBsZSBjbWRcblx0ICA5MyAvLyBXaW5kb3dzIG1lbnUgLyByaWdodCBBcHBsZSBjbWRcblx0ICBdO1xuXG5cdCAgLy8gbWFwcGluZyBvZiBldmVudHMgdG8gaW5wdXQgdHlwZXNcblx0ICB2YXIgaW5wdXRNYXAgPSB7XG5cdCAgICAna2V5dXAnOiAna2V5Ym9hcmQnLFxuXHQgICAgJ21vdXNlZG93bic6ICdtb3VzZScsXG5cdCAgICAnbW91c2Vtb3ZlJzogJ21vdXNlJyxcblx0ICAgICdNU1BvaW50ZXJEb3duJzogJ3BvaW50ZXInLFxuXHQgICAgJ01TUG9pbnRlck1vdmUnOiAncG9pbnRlcicsXG5cdCAgICAncG9pbnRlcmRvd24nOiAncG9pbnRlcicsXG5cdCAgICAncG9pbnRlcm1vdmUnOiAncG9pbnRlcicsXG5cdCAgICAndG91Y2hzdGFydCc6ICd0b3VjaCdcblx0ICB9O1xuXG5cdCAgLy8gYXJyYXkgb2YgYWxsIHVzZWQgaW5wdXQgdHlwZXNcblx0ICB2YXIgaW5wdXRUeXBlcyA9IFtdO1xuXG5cdCAgLy8gYm9vbGVhbjogdHJ1ZSBpZiB0b3VjaCBidWZmZXIgaXMgYWN0aXZlXG5cdCAgdmFyIGlzQnVmZmVyaW5nID0gZmFsc2U7XG5cblx0ICAvLyBib29sZWFuOiB0cnVlIGlmIHRoZSBwYWdlIGlzIGJlaW5nIHNjcm9sbGVkXG5cdCAgdmFyIGlzU2Nyb2xsaW5nID0gZmFsc2U7XG5cblx0ICAvLyBzdG9yZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG5cdCAgdmFyIG1vdXNlUG9zID0ge1xuXHQgICAgJ3gnOiBudWxsLFxuXHQgICAgJ3knOiBudWxsXG5cdCAgfTtcblxuXHQgIC8vIG1hcCBvZiBJRSAxMCBwb2ludGVyIGV2ZW50c1xuXHQgIHZhciBwb2ludGVyTWFwID0ge1xuXHQgICAgMjogJ3RvdWNoJyxcblx0ICAgIDM6ICd0b3VjaCcsIC8vIHRyZWF0IHBlbiBsaWtlIHRvdWNoXG5cdCAgICA0OiAnbW91c2UnXG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICogc2V0IHVwXG5cdCAgICovXG5cblx0ICB2YXIgc2V0VXAgPSBmdW5jdGlvbiBzZXRVcCgpIHtcblx0ICAgIC8vIGFkZCBjb3JyZWN0IG1vdXNlIHdoZWVsIGV2ZW50IG1hcHBpbmcgdG8gYGlucHV0TWFwYFxuXHQgICAgaW5wdXRNYXBbZGV0ZWN0V2hlZWwoKV0gPSAnbW91c2UnO1xuXG5cdCAgICBhZGRMaXN0ZW5lcnMoKTtcblx0ICAgIHNldElucHV0KCk7XG5cdCAgfTtcblxuXHQgIC8qXG5cdCAgICogZXZlbnRzXG5cdCAgICovXG5cblx0ICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuXHQgICAgLy8gYHBvaW50ZXJtb3ZlYCwgYE1TUG9pbnRlck1vdmVgLCBgbW91c2Vtb3ZlYCBhbmQgbW91c2Ugd2hlZWwgZXZlbnQgYmluZGluZ1xuXHQgICAgLy8gY2FuIG9ubHkgZGVtb25zdHJhdGUgcG90ZW50aWFsLCBidXQgbm90IGFjdHVhbCwgaW50ZXJhY3Rpb25cblx0ICAgIC8vIGFuZCBhcmUgdHJlYXRlZCBzZXBhcmF0ZWx5XG5cblx0ICAgIC8vIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgcGVuLCB0b3VjaClcblx0ICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG5cdCAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB1cGRhdGVJbnB1dCk7XG5cdCAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCBzZXRJbnRlbnQpO1xuXHQgICAgfSBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcblx0ICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgICBkb2NFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCBzZXRJbnRlbnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgLy8gbW91c2UgZXZlbnRzXG5cdCAgICAgIGRvY0VsZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgICBkb2NFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHNldEludGVudCk7XG5cblx0ICAgICAgLy8gdG91Y2ggZXZlbnRzXG5cdCAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHtcblx0ICAgICAgICBkb2NFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaEJ1ZmZlcik7XG5cdCAgICAgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoQnVmZmVyKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICAvLyBtb3VzZSB3aGVlbFxuXHQgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKGRldGVjdFdoZWVsKCksIHNldEludGVudCk7XG5cblx0ICAgIC8vIGtleWJvYXJkIGV2ZW50c1xuXHQgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdXBkYXRlSW5wdXQpO1xuXHQgICAgZG9jRWxlbS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwZGF0ZUlucHV0KTtcblx0ICB9O1xuXG5cdCAgLy8gY2hlY2tzIGNvbmRpdGlvbnMgYmVmb3JlIHVwZGF0aW5nIG5ldyBpbnB1dFxuXHQgIHZhciB1cGRhdGVJbnB1dCA9IGZ1bmN0aW9uIHVwZGF0ZUlucHV0KGV2ZW50KSB7XG5cdCAgICAvLyBvbmx5IGV4ZWN1dGUgaWYgdGhlIHRvdWNoIGJ1ZmZlciB0aW1lciBpc24ndCBydW5uaW5nXG5cdCAgICBpZiAoIWlzQnVmZmVyaW5nKSB7XG5cdCAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LndoaWNoO1xuXHQgICAgICB2YXIgdmFsdWUgPSBpbnB1dE1hcFtldmVudC50eXBlXTtcblx0ICAgICAgaWYgKHZhbHVlID09PSAncG9pbnRlcicpIHZhbHVlID0gcG9pbnRlclR5cGUoZXZlbnQpO1xuXG5cdCAgICAgIGlmIChjdXJyZW50SW5wdXQgIT09IHZhbHVlIHx8IGN1cnJlbnRJbnRlbnQgIT09IHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIGFjdGl2ZUVsZW0gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgICAgICAgIHZhciBhY3RpdmVJbnB1dCA9IGZhbHNlO1xuXG5cdCAgICAgICAgaWYgKGFjdGl2ZUVsZW0gJiYgYWN0aXZlRWxlbS5ub2RlTmFtZSAmJiBmb3JtSW5wdXRzLmluZGV4T2YoYWN0aXZlRWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcblx0ICAgICAgICAgIGFjdGl2ZUlucHV0ID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodmFsdWUgPT09ICd0b3VjaCcgfHxcblxuXHQgICAgICAgIC8vIGlnbm9yZSBtb3VzZSBtb2RpZmllciBrZXlzXG5cdCAgICAgICAgdmFsdWUgPT09ICdtb3VzZScgJiYgaWdub3JlTWFwLmluZGV4T2YoZXZlbnRLZXkpID09PSAtMSB8fFxuXG5cdCAgICAgICAgLy8gZG9uJ3Qgc3dpdGNoIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSBmb3JtIGlucHV0XG5cdCAgICAgICAgdmFsdWUgPT09ICdrZXlib2FyZCcgJiYgYWN0aXZlSW5wdXQpIHtcblx0ICAgICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBhbmQgY2F0Y2gtYWxsIHZhcmlhYmxlXG5cdCAgICAgICAgICBjdXJyZW50SW5wdXQgPSBjdXJyZW50SW50ZW50ID0gdmFsdWU7XG5cblx0ICAgICAgICAgIHNldElucHV0KCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIHVwZGF0ZXMgdGhlIGRvYyBhbmQgYGlucHV0VHlwZXNgIGFycmF5IHdpdGggbmV3IGlucHV0XG5cdCAgdmFyIHNldElucHV0ID0gZnVuY3Rpb24gc2V0SW5wdXQoKSB7XG5cdCAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW5wdXQnLCBjdXJyZW50SW5wdXQpO1xuXHQgICAgZG9jRWxlbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtd2hhdGludGVudCcsIGN1cnJlbnRJbnB1dCk7XG5cblx0ICAgIGlmIChpbnB1dFR5cGVzLmluZGV4T2YoY3VycmVudElucHV0KSA9PT0gLTEpIHtcblx0ICAgICAgaW5wdXRUeXBlcy5wdXNoKGN1cnJlbnRJbnB1dCk7XG5cdCAgICAgIGRvY0VsZW0uY2xhc3NOYW1lICs9ICcgd2hhdGlucHV0LXR5cGVzLScgKyBjdXJyZW50SW5wdXQ7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8vIHVwZGF0ZXMgaW5wdXQgaW50ZW50IGZvciBgbW91c2Vtb3ZlYCBhbmQgYHBvaW50ZXJtb3ZlYFxuXHQgIHZhciBzZXRJbnRlbnQgPSBmdW5jdGlvbiBzZXRJbnRlbnQoZXZlbnQpIHtcblx0ICAgIC8vIHRlc3QgdG8gc2VlIGlmIGBtb3VzZW1vdmVgIGhhcHBlbmVkIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cblx0ICAgIC8vIHRvIGRldGVjdCBzY3JvbGxpbmcgdmVyc3VzIG1vdXNlbW92ZVxuXHQgICAgaWYgKG1vdXNlUG9zWyd4J10gIT09IGV2ZW50LnNjcmVlblggfHwgbW91c2VQb3NbJ3knXSAhPT0gZXZlbnQuc2NyZWVuWSkge1xuXHQgICAgICBpc1Njcm9sbGluZyA9IGZhbHNlO1xuXG5cdCAgICAgIG1vdXNlUG9zWyd4J10gPSBldmVudC5zY3JlZW5YO1xuXHQgICAgICBtb3VzZVBvc1sneSddID0gZXZlbnQuc2NyZWVuWTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlzU2Nyb2xsaW5nID0gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gb25seSBleGVjdXRlIGlmIHRoZSB0b3VjaCBidWZmZXIgdGltZXIgaXNuJ3QgcnVubmluZ1xuXHQgICAgLy8gb3Igc2Nyb2xsaW5nIGlzbid0IGhhcHBlbmluZ1xuXHQgICAgaWYgKCFpc0J1ZmZlcmluZyAmJiAhaXNTY3JvbGxpbmcpIHtcblx0ICAgICAgdmFyIHZhbHVlID0gaW5wdXRNYXBbZXZlbnQudHlwZV07XG5cdCAgICAgIGlmICh2YWx1ZSA9PT0gJ3BvaW50ZXInKSB2YWx1ZSA9IHBvaW50ZXJUeXBlKGV2ZW50KTtcblxuXHQgICAgICBpZiAoY3VycmVudEludGVudCAhPT0gdmFsdWUpIHtcblx0ICAgICAgICBjdXJyZW50SW50ZW50ID0gdmFsdWU7XG5cblx0ICAgICAgICBkb2NFbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS13aGF0aW50ZW50JywgY3VycmVudEludGVudCk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLy8gYnVmZmVycyB0b3VjaCBldmVudHMgYmVjYXVzZSB0aGV5IGZyZXF1ZW50bHkgYWxzbyBmaXJlIG1vdXNlIGV2ZW50c1xuXHQgIHZhciB0b3VjaEJ1ZmZlciA9IGZ1bmN0aW9uIHRvdWNoQnVmZmVyKGV2ZW50KSB7XG5cdCAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG5cdCAgICAgIGlzQnVmZmVyaW5nID0gZmFsc2U7XG5cblx0ICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IGlucHV0XG5cdCAgICAgIHVwZGF0ZUlucHV0KGV2ZW50KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlzQnVmZmVyaW5nID0gdHJ1ZTtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLypcblx0ICAgKiB1dGlsaXRpZXNcblx0ICAgKi9cblxuXHQgIHZhciBwb2ludGVyVHlwZSA9IGZ1bmN0aW9uIHBvaW50ZXJUeXBlKGV2ZW50KSB7XG5cdCAgICBpZiAodHlwZW9mIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbnVtYmVyJykge1xuXHQgICAgICByZXR1cm4gcG9pbnRlck1hcFtldmVudC5wb2ludGVyVHlwZV07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyB0cmVhdCBwZW4gbGlrZSB0b3VjaFxuXHQgICAgICByZXR1cm4gZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nID8gJ3RvdWNoJyA6IGV2ZW50LnBvaW50ZXJUeXBlO1xuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvLyBkZXRlY3QgdmVyc2lvbiBvZiBtb3VzZSB3aGVlbCBldmVudCB0byB1c2Vcblx0ICAvLyB2aWEgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsXG5cdCAgdmFyIGRldGVjdFdoZWVsID0gZnVuY3Rpb24gZGV0ZWN0V2hlZWwoKSB7XG5cdCAgICB2YXIgd2hlZWxUeXBlID0gdm9pZCAwO1xuXG5cdCAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgc3VwcG9ydCBcIndoZWVsXCJcblx0ICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcblx0ICAgICAgd2hlZWxUeXBlID0gJ3doZWVsJztcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIC8vIFdlYmtpdCBhbmQgSUUgc3VwcG9ydCBhdCBsZWFzdCBcIm1vdXNld2hlZWxcIlxuXHQgICAgICAvLyBvciBhc3N1bWUgdGhhdCByZW1haW5pbmcgYnJvd3NlcnMgYXJlIG9sZGVyIEZpcmVmb3hcblx0ICAgICAgd2hlZWxUeXBlID0gZG9jdW1lbnQub25tb3VzZXdoZWVsICE9PSB1bmRlZmluZWQgPyAnbW91c2V3aGVlbCcgOiAnRE9NTW91c2VTY3JvbGwnO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd2hlZWxUeXBlO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAqIGluaXRcblx0ICAgKi9cblxuXHQgIC8vIGRvbid0IHN0YXJ0IHNjcmlwdCB1bmxlc3MgYnJvd3NlciBjdXRzIHRoZSBtdXN0YXJkXG5cdCAgLy8gKGFsc28gcGFzc2VzIGlmIHBvbHlmaWxscyBhcmUgdXNlZClcblx0ICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIHdpbmRvdyAmJiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuXHQgICAgc2V0VXAoKTtcblx0ICB9XG5cblx0ICAvKlxuXHQgICAqIGFwaVxuXHQgICAqL1xuXG5cdCAgcmV0dXJuIHtcblx0ICAgIC8vIHJldHVybnMgc3RyaW5nOiB0aGUgY3VycmVudCBpbnB1dCB0eXBlXG5cdCAgICAvLyBvcHQ6ICdsb29zZSd8J3N0cmljdCdcblx0ICAgIC8vICdzdHJpY3QnIChkZWZhdWx0KTogcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgYGRhdGEtd2hhdGlucHV0YCBhdHRyaWJ1dGVcblx0ICAgIC8vICdsb29zZSc6IGluY2x1ZGVzIGBkYXRhLXdoYXRpbnRlbnRgIHZhbHVlIGlmIGl0J3MgbW9yZSBjdXJyZW50IHRoYW4gYGRhdGEtd2hhdGlucHV0YFxuXHQgICAgYXNrOiBmdW5jdGlvbiBhc2sob3B0KSB7XG5cdCAgICAgIHJldHVybiBvcHQgPT09ICdsb29zZScgPyBjdXJyZW50SW50ZW50IDogY3VycmVudElucHV0O1xuXHQgICAgfSxcblxuXHQgICAgLy8gcmV0dXJucyBhcnJheTogYWxsIHRoZSBkZXRlY3RlZCBpbnB1dCB0eXBlc1xuXHQgICAgdHlwZXM6IGZ1bmN0aW9uIHR5cGVzKCkge1xuXHQgICAgICByZXR1cm4gaW5wdXRUeXBlcztcblx0ICAgIH1cblx0ICB9O1xuXHR9KCk7XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2hhdC1pbnB1dC9kaXN0L3doYXQtaW5wdXQuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

eval("/**\n * Requires the Foundation scripts which enable it's all\n * dynamic components. Comment out all unnecessary\n * components to keep the output of file light.\n */\n\n// Require Foundation dependences.\n__webpack_require__(29);\n\n// Foundation core - needed if you want to use any of the components below.\n__webpack_require__(3);\n__webpack_require__(20);\n__webpack_require__(21);\n__webpack_require__(22);\n__webpack_require__(23);\n__webpack_require__(24);\n__webpack_require__(25);\n__webpack_require__(26);\n__webpack_require__(27);\n\n// Pick the components you need in your project.\n__webpack_require__(0);\n__webpack_require__(1);\n__webpack_require__(2);\n__webpack_require__(4);\n__webpack_require__(5);\n__webpack_require__(6);\n__webpack_require__(7);\n__webpack_require__(8);\n__webpack_require__(9);\n__webpack_require__(10);\n__webpack_require__(11);\n__webpack_require__(12);\n__webpack_require__(13);\n__webpack_require__(14);\n__webpack_require__(15);\n__webpack_require__(16);\n__webpack_require__(17);\n__webpack_require__(18);\n__webpack_require__(19);\n__webpack_require__(28);\n\n// Lets init Foundation scripts.\n;(function ($) {\n    $(document).foundation();\n})(jQuery);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2Fzc2V0cy9qcy9mb3VuZGF0aW9uLmpzPzZlN2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZXF1aXJlcyB0aGUgRm91bmRhdGlvbiBzY3JpcHRzIHdoaWNoIGVuYWJsZSBpdCdzIGFsbFxuICogZHluYW1pYyBjb21wb25lbnRzLiBDb21tZW50IG91dCBhbGwgdW5uZWNlc3NhcnlcbiAqIGNvbXBvbmVudHMgdG8ga2VlcCB0aGUgb3V0cHV0IG9mIGZpbGUgbGlnaHQuXG4gKi9cblxuLy8gUmVxdWlyZSBGb3VuZGF0aW9uIGRlcGVuZGVuY2VzLlxucmVxdWlyZSgnd2hhdC1pbnB1dCcpO1xuXG4vLyBGb3VuZGF0aW9uIGNvcmUgLSBuZWVkZWQgaWYgeW91IHdhbnQgdG8gdXNlIGFueSBvZiB0aGUgY29tcG9uZW50cyBiZWxvdy5cbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uY29yZScpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLmJveCcpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLmtleWJvYXJkJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeScpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLm1vdGlvbicpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi51dGlsLm5lc3QnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnV0aWwudG91Y2gnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udXRpbC50cmlnZ2VycycpO1xuXG4vLyBQaWNrIHRoZSBjb21wb25lbnRzIHlvdSBuZWVkIGluIHlvdXIgcHJvamVjdC5cbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uYWJpZGUnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uYWNjb3JkaW9uJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLmFjY29yZGlvbk1lbnUnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uZHJpbGxkb3duJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLmRyb3Bkb3duJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLmRyb3Bkb3duTWVudScpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5lcXVhbGl6ZXInKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uaW50ZXJjaGFuZ2UnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ubWFnZWxsYW4nKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ub2ZmY2FudmFzJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLm9yYml0Jyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVNZW51Jyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnJlc3BvbnNpdmVUb2dnbGUnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24ucmV2ZWFsJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnNsaWRlcicpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi5zdGlja3knKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24udGFicycpO1xucmVxdWlyZSgnZm91bmRhdGlvbi1zaXRlcy9kaXN0L2pzL3BsdWdpbnMvZm91bmRhdGlvbi50b2dnbGVyJyk7XG5yZXF1aXJlKCdmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvanMvcGx1Z2lucy9mb3VuZGF0aW9uLnRvb2x0aXAnKTtcbnJlcXVpcmUoJ2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9qcy9wbHVnaW5zL2ZvdW5kYXRpb24uemYucmVzcG9uc2l2ZUFjY29yZGlvblRhYnMnKTtcblxuLy8gTGV0cyBpbml0IEZvdW5kYXRpb24gc2NyaXB0cy5cbjsoZnVuY3Rpb24gKCQpIHtcbiAgICAkKGRvY3VtZW50KS5mb3VuZGF0aW9uKCk7XG59KShqUXVlcnkpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL2ZvdW5kYXRpb24uanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);